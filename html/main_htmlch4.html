<!DOCTYPE html> 
<html lang='en-US' xml:lang='en-US'> 
<head><title>4 CNOT circuits and phase-free ZX-diagrams</title> 
<meta charset='utf-8' /> 
<meta content='TeX4ht (https://tug.org/tex4ht/)' name='generator' /> 
<meta content='width=device-width,initial-scale=1' name='viewport' /> 
<link href='main_html.css' rel='stylesheet' type='text/css' /> 
<meta content='main_html.tex' name='src' /> 
 <script async='async' id='MathJax-script' src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/mml-chtml.js' type='text/javascript'></script>  
</head><body>
   <!-- l. 7 --><div class='crosslinks'><p class='noindent'>[<a href='main_htmlch5.html'>next</a>] [<a href='main_htmlch3.html'>prev</a>] [<a href='main_htmlch3.html#tailmain_htmlch3.html'>prev-tail</a>] [<a href='#tailmain_htmlch4.html'>tail</a>] [<a href='main_html.html#main_htmlch4.html'>up</a>] </p></div>
   <h2 class='chapterHead' id='cnot-circuits-and-phasefree-zxdiagrams'><span class='titlemark'>Chapter 4</span><br /><a id='x6-870004'></a>CNOT circuits and phase-free ZX-diagrams</h2>
<!-- l. 8 --><p class='noindent'>ZX-diagrams are a universal language for talking about quantum computing.
This makes them useful, but it also means that for generic ZX-diagrams, we
expect certain problems to be hard to solve with rewriting. For example, if we
could efficiently determine if two different ZX-diagrams describe the same
matrix, we can also determine if two quantum circuits actually describe the
same unitary. However, we have good, complexity-theoretic reasons to
believe that that is way harder than anything even a quantum computer
can do (much less a classical one). As a special case, this would let us
determine efficiently the complex number described by a diagram with no
inputs and outputs, which would let us efficiently simulate quantum
computers. This would of course make the whole project of quantum
computation (and essentially the jobs of the authors of this book) pointless.
Since we don’t believe we can efficiently solve certain problems for <span class='cmti-10x-x-109'>any</span>
ZX-diagram, it makes sense to restrict to classes of diagrams which can be
reasoned about efficiently. The restriction of the ZX-calculus to a family of
ZX-diagrams that is closed under composition and tensor product is a
<span class='cmbx-10x-x-109'>fragment </span>of the ZX-calculus. In this chapter we will look in detail at one
of the simplest possible fragments of the ZX-calculus: the <span class='cmbx-10x-x-109'>phase-free
ZX-calculus</span>. This fragment concerns ZX-diagrams where all the phases on the
spiders are required to be zero, and where we do not have Hadamard
gates. The phase-free diagrams turn out to behave very nicely, and we
can rewrite them in various fruitful ways. Their nice structure comes
from a deep connection with linear algebra over the two-element field
<!-- l. 12 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>. Whereas
quantum theory primarily concerns itself with (exponentially large) matrices whose elements
are in <!-- l. 12 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ℂ</mi></math>,
we’ll see in this chapter that a special class of operations can be described in
a different way using (much smaller) matrices whose elements are in
<!-- l. 12 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>. The
reason we care about phase-free ZX-diagrams is because such diagrams that are
unitary correspond precisely to quantum circuits consisting solely of CNOT
gates, so-called <span class='cmbx-10x-x-109'>CNOT circuits</span>. In this chapter we will explore in detail the
relation between CNOT circuits, phase-free ZX-diagrams and linear parity
maps.
</p>
   <h3 class='sectionHead' id='cnot-circuits-and-parity-matrices'><span class='titlemark'>4.1   </span> <a id='x6-880004.1'></a>CNOT circuits and parity matrices</h3>
<!-- l. 15 --><p class='noindent'>In this section, we will see that the action of a CNOT circuit on
<!-- l. 15 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math> qubits can be succinctly
represented as an <!-- l. 15 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>×</mo> <mi>n</mi></mrow></math>
                                                                     

                                                                     
matrix over the field <!-- l. 15 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>
and how to translate to and from this representation.
</p>
   <h4 class='subsectionHead' id='the-twoelement-field-and-the-parity-of-a-bit-string'><span class='titlemark'>4.1.1   </span> <a id='x6-890004.1.1'></a>The two-element field and the parity of a bit string</h4>
<!-- l. 17 --><p class='noindent'>First and foremost: what is <!-- l. 17 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>?
Let’s give a formal definition.
</p>
   <div class='newtheorem'>
<!-- l. 18 --><p class='noindent'><span class='head'>
<a id='x6-89001r1'></a>
<span class='cmbx-10x-x-109'>Definition 4.1.1.</span>  </span> The <span class='cmbx-10x-x-109'>field with 2 elements </span><!-- l. 19 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>
is defined as the set <!-- l. 19 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>{</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>
which comes equipped with addition and multiplication operations defined
as: <!-- l. 19 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>y</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>y</mi></mrow></math>
and <!-- l. 19 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>y</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>x</mi> <mo class='MathClass-bin' stretchy='false'>∧</mo> <mi>y</mi></mrow></math>,
where <!-- l. 19 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mo class='MathClass-bin' stretchy='false'>⊕</mo></math>
and <!-- l. 19 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mo class='MathClass-bin' stretchy='false'>∧</mo></math>
are the XOR and AND operations defined on bits, respectively.
</p>
   </div>
<!-- l. 20 --><p class='indent'>    This may not look much like the fields of numbers you are used to—like the real numbers
<!-- l. 21 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ℝ</mi></math>, complex numbers
<!-- l. 21 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ℂ</mi></math>, or rational
numbers <!-- l. 21 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ℚ</mi></math>—but
just by thinking about the behaviour of XOR and AND, we can verify
all of the field axioms. First off, we can easily see that XOR and AND
are both associative, commutative, and have units 0 and 1 respectively:
</p><table class='equation-star'><tr><td>
<!-- l. 22 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
            <mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>y</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>z</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>x</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>y</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>z</mi><mo class='MathClass-close' stretchy='false'>)</mo><mspace class='qquad' width='2em'></mspace><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>y</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>y</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>x</mi><mspace class='qquad' width='2em'></mspace><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>0</mn> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>x</mi>
</mrow></math></td></tr></table>
                                                                     

                                                                     
   <table class='equation-star'><tr><td>
<!-- l. 30 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                <mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>y</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>z</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>y</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>z</mi><mo class='MathClass-close' stretchy='false'>)</mo><mspace class='qquad' width='2em'></mspace><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>y</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>y</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>x</mi><mspace class='qquad' width='2em'></mspace><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mn>1</mn> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>x</mi>
</mrow></math></td></tr></table>
<!-- l. 38 --><p class='indent'>   But what about inverses? In a field, every number
<!-- l. 38 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>x</mi></math> has to have an
additive inverse <!-- l. 38 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>x</mi></mrow></math>
satisfying <!-- l. 38 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>x</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>x</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>. A
special property of <!-- l. 38 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>
is that every element is its own additive inverse. We have
<!-- l. 38 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>0</mn> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>0</mn> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mn>0</mn> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>, but also
<!-- l. 38 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>1</mn> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mn>1</mn> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>. Furthermore,
for <!-- l. 39 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>
to be a field, every non-zero number has to have a multiplicative
inverse. But here there is only one non-zero number:
<!-- l. 39 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>, and clearly
<!-- l. 39 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>1</mn> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mn>1</mn> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>. We sometimes refer
to an element in <!-- l. 40 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>
as a <span class='cmbx-10x-x-109'>parity</span>. Parity is a property of bit strings: if a bit string contains
an even number of 1s, we say it has parity 0, whereas if it contain
an odd number of 1s, we say it has parity 1. For a bit string
<!-- l. 40 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>b</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>b</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>, we can
compute the parity by taking the XOR of all of its bits, i.e. we sum up the bits as elements
of the field <!-- l. 40 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>:
</p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 41 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                         <mstyle class='text'><mtext class='textbf' mathvariant='bold'>parity</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo><munder class='msub'><mrow><mo> ∑</mo>
   </mrow><mrow><mi>i</mi></mrow></munder><msub><mrow><mi>b</mi></mrow><mrow><mi>i</mi></mrow></msub>
</mrow></math></td></tr></table>
<!-- l. 44 --><p class='indent'>   One is often interested not just in the overall parity of a bit string, but also
the parity of some subset of bits. This can be computed using simple matrix
operations. For example, we can express the operation of computing
the parity of the 1st, 3rd, and 4th bits of a 4-bit string as a row vector:
</p><table class='equation-star'><tr><td>
<!-- l. 45 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
 <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                       </mrow><mo fence='true' form='postfix'>)</mo></mrow> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <msub><mrow><mi>b</mi></mrow><mrow><mn>1</mn></mrow></msub>  </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <msub><mrow><mi>b</mi></mrow><mrow><mn>2</mn></mrow></msub>  </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <msub><mrow><mi>b</mi></mrow><mrow><mn>3</mn></mrow></msub>  </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <msub><mrow><mi>b</mi></mrow><mrow><mn>4</mn></mrow></msub>  </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                                                    </mrow><mo fence='true' form='postfix'>)</mo></mrow>  <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>b</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>⊕</mo><msub><mrow><mi>b</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>⊕</mo><msub><mrow><mi>b</mi></mrow><mrow><mn>4</mn></mrow></msub>
</mrow></math></td></tr></table>
<!-- l. 53 --><p class='indent'>   More generally, if we are interested in computing several parities at once, we
can arrange them in the rows of a matrix: </p><table class='equation-star'><tr><td>
<!-- l. 54 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
 <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn></mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                       </mrow><mo fence='true' form='postfix'>)</mo></mrow> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <msub><mrow><mi>b</mi></mrow><mrow><mn>1</mn></mrow></msub>  </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <msub><mrow><mi>b</mi></mrow><mrow><mn>2</mn></mrow></msub>  </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <msub><mrow><mi>b</mi></mrow><mrow><mn>3</mn></mrow></msub>  </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <msub><mrow><mi>b</mi></mrow><mrow><mn>4</mn></mrow></msub>  </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                                                    </mrow><mo fence='true' form='postfix'>)</mo></mrow>  <mo class='MathClass-rel' stretchy='false'>=</mo>  <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <msub><mrow><mi>b</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>b</mi></mrow><mrow><mn>3</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>b</mi></mrow><mrow><mn>4</mn></mrow></msub>  </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'>      <msub><mrow><mi>b</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>b</mi></mrow><mrow><mn>3</mn></mrow></msub>      </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'>      <msub><mrow><mi>b</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>b</mi></mrow><mrow><mn>4</mn></mrow></msub>      </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'>          <msub><mrow><mi>b</mi></mrow><mrow><mn>4</mn></mrow></msub>          </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                                    </mrow><mo fence='true' form='postfix'>)</mo></mrow>
</mrow></math></td></tr></table>
<!-- l. 71 --><p class='indent'>   By saving or transmitting some parity information about a bit
string, we can often detect and correct errors. For example, if the bit
<!-- l. 71 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>b</mi></mrow><mrow><mn>2</mn></mrow></msub></math>
got lost in transmission, but we know the values of
                                                                     

                                                                     
<!-- l. 71 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>b</mi></mrow><mrow><mn>3</mn></mrow></msub></math> and
<!-- l. 71 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>b</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>b</mi></mrow><mrow><mn>3</mn></mrow></msub></mrow></math>, we can
recover <!-- l. 71 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>b</mi></mrow><mrow><mn>2</mn></mrow></msub></math>
since <!-- l. 71 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>b</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>b</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>b</mi></mrow><mrow><mn>3</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>b</mi></mrow><mrow><mn>3</mn></mrow></msub></mrow></math>.
Such basic operations are the basis of classical linear error correcting
codes, and as we’ll see in Chapter <a href='main_htmlch11.html#quantum-error-correction'>11<!-- tex4ht:ref: ch:qec  --></a>, also play a major role in quantum
error correction. However, before we get there, we’ll see a much more
immediate connection between parity matrices and quantum circuits: the
behaviour of a CNOT circuit can be exactly captured by an invertible parity
matrix.
</p>
   <h4 class='subsectionHead' id='from-cnot-circuits-to-parity-maps'><span class='titlemark'>4.1.2   </span> <a id='x6-900004.1.2'></a>From CNOT circuits to parity maps</h4>
<!-- l. 75 --><p class='noindent'>The CNOT gate acts on a pair of qubits via
<!-- l. 75 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>x</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>↦</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mi>x</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>y</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
When we put multiple CNOT gates in a circuit, we can build unitaries that have
more complicated actions on the computational basis states. For instance,
suppose we have a CNOT from qubit 1 to 2, and then a CNOT from 2 to 1:
</p><table class='equation-star'><tr><td>
<!-- l. 78 --><object data="svgs/2cnots.svg" alt="diagram of 2cnots" class="svg-diagram"></object></td></tr></table>
<!-- l. 81 --><p class='indent'>   We can calculate its action on the computational basis state
<!-- l. 81 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi mathvariant='italic'>xy</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> as:
</p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 82 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
             <mo class='MathClass-rel' stretchy='false'>|</mo><mi>x</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>↦</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mi>x</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>y</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>↦</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>y</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>y</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mi>y</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>y</mi><mo class='MathClass-close' stretchy='false'>⟩</mo>
</mrow></math></td></tr></table>
<!-- l. 86 --><p class='indent'>   More generally, we can calculate the action of any CNOT circuit on a
computational basis state by labelling each of the input wires with a variable
<!-- l. 86 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mi>i</mi></mrow></msub></math>, then
pushing those variables through the circuit: </p><table class='equation'><tr><td>
<!-- l. 87 --><p class='indent'>
</p><!-- l. 87 --><object id='x6-90001r1' data="svgs/eq-cnot-parities.svg" alt="diagram of eq:cnot-parities" class="svg-diagram"></object></td><td class='eq-no'>(4.1)</td></tr></table>
<!-- l. 90 --><p class='indent'>   That is, we work from left to right. When we
encounter a CNOT gate whose input wires are labelled
<!-- l. 90 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>a</mi></math> on the control qubit
and <!-- l. 90 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>b</mi></math> on the target
qubit, we copy the label <!-- l. 90 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>a</mi></math>
onto the output wire of the control qubit and write
<!-- l. 90 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>b</mi></mrow></math> on
the output wire of the target qubit. Once we get to the output of the circuit, we
will have calculated the overall action of the unitary on computational basis
states. For example, the circuit (<a href='#x6-90001r1'>4.1<!-- tex4ht:ref: eq:cnot-parities  --></a>) implements the following unitary:
</p><table class='equation'><tr><td>
<!-- l. 91 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 91 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                    <mstyle class='label' id='x6-90002r2'></mstyle><!-- endlabel --><mi>U</mi><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-punc' stretchy='false'>:</mo> <mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>↦</mo><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo>
</mrow></math></td><td class='eq-no'>(4.2)</td></tr></table>
<!-- l. 94 --><p class='indent'>   Generally we can describe the action of a CNOT circuit by a parity
map:
</p>
   <div class='newtheorem'>
<!-- l. 95 --><p class='noindent'><span class='head'>
<a id='x6-90003r2'></a>
<span class='cmbx-10x-x-109'>Definition 4.1.2.</span>  </span> A <span class='cmbx-10x-x-109'>parity map </span>is a function <!-- l. 96 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi> <mo class='MathClass-punc' stretchy='false'>:</mo> <msup><mrow><mo class='MathClass-open' stretchy='false'>{</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>}</mo></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>→</mo><msup><mrow><mo class='MathClass-open' stretchy='false'>{</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>}</mo></mrow><mrow><mi>m</mi></mrow></msup></mrow></math>
where <!-- l. 96 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>f</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>f</mi></mrow><mrow><mi>m</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
and each <!-- l. 96 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>f</mi></mrow><mrow><mi>i</mi></mrow></msub></math>
calculates the parity of some of the input bits: <!-- l. 97 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>f</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>x</mi></mrow><mrow><msub><mrow><mi>j</mi></mrow><mrow><mi>i</mi><mn>1</mn></mrow></msub></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><msub><mrow><mi>j</mi></mrow><mrow><mi>i</mi><mn>2</mn></mrow></msub></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo><mo class='MathClass-rel' stretchy='false'>⋯</mo> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><msub><mrow><mi>j</mi></mrow><mrow><mi>i</mi><msub><mrow><mi>k</mi></mrow><mrow>
<mi>i</mi></mrow></msub></mrow></msub></mrow></msub></mrow></math>.
</p>
   </div>
<!-- l. 98 --><p class='indent'>    By pushing variables through a circuit as in the example above, we can
straightforwardly calculate the parity map for any CNOT circuit. Hence, the
following proposition is immediate.
</p>
   <div class='newtheorem'>
<!-- l. 100 --><p class='noindent'><span class='head'>
<a id='x6-90004r3'></a>
<span class='cmbx-10x-x-109'>Proposition 4.1.3.</span>  </span> Let <!-- l. 101 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>C</mi></math>
be an <!-- l. 101 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit
CNOT circuit describing the unitary <!-- l. 101 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>U</mi></mrow><mrow><mi>C</mi></mrow></msub></math>.
Then there is a parity map <!-- l. 101 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi> <mo class='MathClass-punc' stretchy='false'>:</mo> <msup><mrow><mo class='MathClass-open' stretchy='false'>{</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>}</mo></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>→</mo><msup><mrow><mo class='MathClass-open' stretchy='false'>{</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>}</mo></mrow><mrow><mi>n</mi></mrow></msup></mrow></math>
such that for every computational basis state <!-- l. 101 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
we have <!-- l. 101 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>U</mi></mrow><mrow><mi>C</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
</p>
   </div>
<!-- l. 102 --><p class='indent'>    Furthermore, the parity map totally defines the unitary associated with the
CNOT circuit. In particular, if we find another CNOT circuit with the same
parity map, it implements the same unitary. For example, the unitary
implemented by the CNOT circuit (<a href='#x6-90001r1'>4.1<!-- tex4ht:ref: eq:cnot-parities  --></a>) could also be implemented by this much
smaller CNOT circuit: </p><table class='equation'><tr><td>
<!-- l. 104 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 104 --><object id='x6-90005r3' data="svgs/eq-cnot-parities-simp.svg" alt="diagram of eq:cnot-parities-simp" class="svg-diagram"></object></td><td class='eq-no'>(4.3)</td></tr></table>
<!-- l. 107 --><p class='indent'>   By starting with a CNOT circuit, computing its parity map, then finding a
new circuit that implements that same parity map, we ended up with a circuit
that was a lot smaller, with just one CNOT gate rather than six. We call the
problem of generating a CNOT circuit that implements a given parity map the
<span class='cmbx-10x-x-109'>CNOT circuit synthesis </span>problem. In the next section, we will show that, as
long as a parity map is invertible, we can always synthesise a CNOT circuit that
implements it.
</p>
   <h4 class='subsectionHead' id='cnot-circuit-synthesis'><span class='titlemark'>4.1.3   </span> <a id='x6-910004.1.3'></a>CNOT circuit synthesis</h4>
<!-- l. 110 --><p class='noindent'>We can view a bit string <!-- l. 110 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>∈</mo><msup><mrow><mo class='MathClass-open' stretchy='false'>{</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>}</mo></mrow><mrow><mi>n</mi></mrow></msup></mrow></math> as
a vector of the vector space <!-- l. 110 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></math>.
With this in mind, it follows that parity maps, which only ever compute XORs of
their input bits, are actually linear maps over such vector spaces. Consequently,
we can always write them in matrix form.
</p>
   <div class='newtheorem'>
<!-- l. 111 --><p class='noindent'><span class='head'>
<a id='x6-91001r4'></a>
<span class='cmbx-10x-x-109'>Definition 4.1.4.</span>  </span>A <span class='cmbx-10x-x-109'>parity matrix </span>is a matrix with entries in <!-- l. 112 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔽</mi><mn>2</mn></mrow></math>.
</p>
   </div>
<!-- l. 113 --><p class='indent'>    One can show straightforwardly that for any parity map
<!-- l. 114 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math>, we can find a
parity matrix <!-- l. 114 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>
such that <!-- l. 114 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>A</mi><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></mrow></math>.
Indeed we saw an example of this in section <a href='#the-twoelement-field-and-the-parity-of-a-bit-string'>4.1.1<!-- tex4ht:ref: sec:parity  --></a> when we represented the parity
map: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 115 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
            <mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>b</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>b</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>b</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>b</mi></mrow><mrow><mn>4</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>b</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>b</mi></mrow><mrow><mn>3</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>b</mi></mrow><mrow><mn>4</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>b</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>b</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>b</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>b</mi></mrow><mrow><mn>4</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>b</mi></mrow><mrow><mn>4</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo>
</mrow></math></td></tr></table>
<!-- l. 124 --><p class='indent'>   with the matrix: </p><table class='equation-star'><tr><td>
<!-- l. 125 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mi>A</mi> <mo class='MathClass-rel' stretchy='false'>=</mo>  <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn></mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                               </mrow><mo fence='true' form='postfix'>)</mo></mrow>
</mrow></math></td></tr></table>
<!-- l. 133 --><p class='indent'>   In the last section, we saw how to represent the action of a CNOT circuit as a
parity map. It will be convenient to write this map as a parity matrix. Since
CNOT circuits represent reversible computations on bits, their associated parity
matrices are always invertible.
</p>
   <div class='newtheorem'>
<!-- l. 134 --><p class='noindent'><span class='head'>
<a id='x6-91002r5'></a>
<span class='cmbx-10x-x-109'>Remark 4.1.5.</span>  </span>Note that we now have two different ways to represent
CNOT circuits as matrices. On the one hand, treating them as quantum
circuits gives us a <!-- l. 135 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>×</mo> <msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></math>
unitary matrix <!-- l. 135 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
whose entries are all complex numbers <!-- l. 135 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>{</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>}</mo><mo class='MathClass-rel' stretchy='false'>⊆</mo> <mi>ℂ</mi></mrow></math>.
These matrices always correspond to permutations of computational basis
states, so there is always a single 1 in each row and column and <!-- l. 135 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>U</mi></mrow><mrow><mi>T</mi> </mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup></mrow></math>.
On the other hand, treating them as classical parity maps gives us a <!-- l. 136 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>×</mo> <mi>n</mi></mrow></math>
<span class='cmti-10x-x-109'>invertible </span>matrix <!-- l. 136 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>P</mi></math>
whose entries are bits <!-- l. 136 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>{</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>}</mo><mo class='MathClass-rel' stretchy='false'>⊆</mo> <msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></math>.
In general, these can have multiple 1’s in any give row/column and <!-- l. 136 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>P</mi></mrow><mrow><mi>T</mi> </mrow></msup></math>
                                                                     

                                                                     
might not equal <!-- l. 136 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>P</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup></math>.
</p>
   </div>
<!-- l. 138 --><p class='indent'>    Thinking about the action of a single CNOT gate: </p><table class='equation-star'><tr><td>
<!-- l. 140 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                     <mstyle class='text'><mtext>CNOT</mtext></mstyle><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo>
</mrow></math></td></tr></table>
<!-- l. 143 --><p class='indent'>   we get the parity map <!-- l. 143 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
and hence the following lower-triangular parity matrix: </p><table class='equation-star'><tr><td>
<!-- l. 144 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mi>E</mi> <mo class='MathClass-rel' stretchy='false'>=</mo>  <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn></mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                       </mrow><mo fence='true' form='postfix'>)</mo></mrow>
</mrow></math></td></tr></table>
<!-- l. 150 --><p class='indent'>   Notably, since <!-- l. 150 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>1</mn> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>
in <!-- l. 150 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>,
this matrix is its own inverse: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 151 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow>
<mi>E</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo>  <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'>    <mn>1</mn>    </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                  </mrow><mo fence='true' form='postfix'>)</mo></mrow> <mo class='MathClass-rel' stretchy='false'>=</mo>  <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn></mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                       </mrow><mo fence='true' form='postfix'>)</mo></mrow>
</mrow></math></td></tr></table>
<!-- l. 163 --><p class='indent'>   This captures the fact that two successive CNOT gates cancel out. We can
generalise this to a single CNOT gate appearing in a larger circuit as
follows.
</p>
   <div class='newtheorem'>
<!-- l. 165 --><p class='noindent'><span class='head'>
<a id='x6-91003r6'></a>
<span class='cmbx-10x-x-109'>Example 4.1.6.</span>  </span> For an <!-- l. 166 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit
circuit, the parity matrix corresponding to a CNOT with the control on qubit
<!-- l. 166 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math>
and the target on qubit <!-- l. 166 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>j</mi></math>
is the identity matrix with one additional <!-- l. 166 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>
in the <!-- l. 166 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math>-th
column and the <!-- l. 166 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>j</mi></math>-th
row. We will denote this matrix by <!-- l. 166 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>E</mi></mrow><mrow><mi mathvariant='italic'>ij</mi></mrow></msup></math>.
Just like with the matrix <!-- l. 166 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>E</mi></math>
above, we have <!-- l. 166 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>E</mi></mrow><mrow><mi mathvariant='italic'>ij</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi></mrow></math>.
</p>
   </div>
<!-- l. 167 --><p class='indent'>    You may have met matrices like these before in a linear algebra course.
Matrices that look like the identity matrix with the exception of one
additional non-zero value correspond to <span class='cmbx-10x-x-109'>primitive row and column
operations </span>used for Gaussian elimination. If I multiply a generic matrix
<!-- l. 169 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math> with
<!-- l. 169 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>E</mi></mrow><mrow><mi mathvariant='italic'>ij</mi></mrow></msup></math> on the left, this has the
effect of adding the <!-- l. 169 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math>-th
row of <!-- l. 169 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math> to
the <!-- l. 169 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>j</mi></math>-th
row: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 170 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow>
<mi>E</mi></mrow><mrow><mi mathvariant='italic'>ij</mi></mrow></msup> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mspace class='quad' width='1em'></mspace> </mtd><mtd class='array-td' columnalign='center'>  <msub><mrow><mi>R</mi></mrow><mrow><mn>1</mn></mrow></msub>  </mtd><mtd class='array-td' columnalign='center'>  <mspace class='quad' width='1em'></mspace>  </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <mspace class='quad' width='1em'></mspace>  </mtd><mtd class='array-td' columnalign='center'>   <mi>⋮</mi>  </mtd><mtd class='array-td' columnalign='center'> <mspace class='quad' width='1em'></mspace> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mspace class='quad' width='1em'></mspace> </mtd> <mtd class='array-td' columnalign='center'> <msub><mrow><mi>R</mi></mrow><mrow>
<mi>i</mi></mrow></msub>  </mtd><mtd class='array-td' columnalign='center'> <mspace class='quad' width='1em'></mspace> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mspace class='quad' width='1em'></mspace> </mtd> <mtd class='array-td' columnalign='center'> <mi>⋮</mi> </mtd> <mtd class='array-td' columnalign='center'> <mspace class='quad' width='1em'></mspace></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mspace class='quad' width='1em'></mspace> </mtd><mtd class='array-td' columnalign='center'> <msub><mrow><mi>R</mi></mrow><mrow><mi>j</mi></mrow></msub>  </mtd><mtd class='array-td' columnalign='center'> <mspace class='quad' width='1em'></mspace> </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mspace class='quad' width='1em'></mspace> </mtd><mtd class='array-td' columnalign='center'>   <mi>⋮</mi>  </mtd><mtd class='array-td' columnalign='center'> <mspace class='quad' width='1em'></mspace> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mspace class='quad' width='1em'></mspace> </mtd> <mtd class='array-td' columnalign='center'> <msub><mrow><mi>R</mi></mrow><mrow>
<mi>n</mi></mrow></msub> </mtd><mtd class='array-td' columnalign='center'> <mspace class='quad' width='1em'></mspace> </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                           </mrow><mo fence='true' form='postfix'>)</mo></mrow> <mo class='MathClass-rel' stretchy='false'>=</mo>  <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mspace class='quad' width='1em'></mspace> </mtd><mtd class='array-td' columnalign='center'>     <msub><mrow><mi>R</mi></mrow><mrow><mn>1</mn></mrow></msub>      </mtd><mtd class='array-td' columnalign='center'>  <mspace class='quad' width='1em'></mspace>  </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <mspace class='quad' width='1em'></mspace>  </mtd><mtd class='array-td' columnalign='center'>       <mi>⋮</mi>     </mtd><mtd class='array-td' columnalign='center'> <mspace class='quad' width='1em'></mspace> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mspace class='quad' width='1em'></mspace> </mtd> <mtd class='array-td' columnalign='center'> <msub><mrow><mi>R</mi></mrow><mrow>
<mi>i</mi></mrow></msub>     </mtd><mtd class='array-td' columnalign='center'> <mspace class='quad' width='1em'></mspace> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mspace class='quad' width='1em'></mspace> </mtd> <mtd class='array-td' columnalign='center'> <mi>⋮</mi> </mtd> <mtd class='array-td' columnalign='center'> <mspace class='quad' width='1em'></mspace></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mspace class='quad' width='1em'></mspace> </mtd><mtd class='array-td' columnalign='center'> <msub><mrow><mi>R</mi></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>R</mi></mrow><mrow><mi>j</mi></mrow></msub> </mtd><mtd class='array-td' columnalign='center'> <mspace class='quad' width='1em'></mspace> </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mspace class='quad' width='1em'></mspace> </mtd><mtd class='array-td' columnalign='center'>      <mi>⋮</mi>     </mtd><mtd class='array-td' columnalign='center'> <mspace class='quad' width='1em'></mspace> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mspace class='quad' width='1em'></mspace> </mtd> <mtd class='array-td' columnalign='center'> <msub><mrow><mi>R</mi></mrow><mrow>
<mi>n</mi></mrow></msub>     </mtd><mtd class='array-td' columnalign='center'> <mspace class='quad' width='1em'></mspace> </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                    </mrow><mo fence='true' form='postfix'>)</mo></mrow>
</mrow></math></td></tr></table>
<!-- l. 192 --><p class='indent'>   whereas if we multiply by <!-- l. 192 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>E</mi></mrow><mrow><mi mathvariant='italic'>ij</mi></mrow></msup></math>
on the right, it has the effect of adding the
<!-- l. 192 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>j</mi></math>-th column
to the <!-- l. 192 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math>-th
column: </p><table class='equation-star'><tr><td>
<!-- l. 193 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
 <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <msub><mrow><mi>C</mi></mrow><mrow><mn>1</mn></mrow></msub>  </mtd><mtd class='array-td' columnalign='center'>  <mspace class='negthinspace' width='-0.17em'></mspace><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-rel' stretchy='false'>⋯</mo><mspace class='negthinspace' width='-0.17em'></mspace><mspace class='negthinspace' width='-0.17em'></mspace> </mtd><mtd class='array-td' columnalign='center'> <msub><mrow><mi>C</mi></mrow><mrow><mi>i</mi></mrow></msub> </mtd><mtd class='array-td' columnalign='center'> <mspace class='negthinspace' width='-0.17em'></mspace><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-rel' stretchy='false'>⋯</mo><mspace class='negthinspace' width='-0.17em'></mspace><mspace class='negthinspace' width='-0.17em'></mspace> </mtd><mtd class='array-td' columnalign='center'> <msub><mrow><mi>C</mi></mrow><mrow><mi>j</mi></mrow></msub> </mtd><mtd class='array-td' columnalign='center'> <mspace class='negthinspace' width='-0.17em'></mspace><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-rel' stretchy='false'>⋯</mo><mspace class='negthinspace' width='-0.17em'></mspace><mspace class='negthinspace' width='-0.17em'></mspace> </mtd><mtd class='array-td' columnalign='center'> <msub><mrow><mi>C</mi></mrow><mrow><mi>n</mi></mrow></msub> </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                        </mrow><mo fence='true' form='postfix'>)</mo></mrow> <msup><mrow><mi>E</mi></mrow><mrow><mi mathvariant='italic'>ij</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo>  <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <msub><mrow><mi>C</mi></mrow><mrow><mn>1</mn></mrow></msub>  </mtd><mtd class='array-td' columnalign='center'>  <mspace class='negthinspace' width='-0.17em'></mspace><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-rel' stretchy='false'>⋯</mo><mspace class='negthinspace' width='-0.17em'></mspace><mspace class='negthinspace' width='-0.17em'></mspace> </mtd><mtd class='array-td' columnalign='center'> <msub><mrow><mi>C</mi></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>C</mi></mrow><mrow><mi>j</mi></mrow></msub> </mtd><mtd class='array-td' columnalign='center'> <mspace class='negthinspace' width='-0.17em'></mspace><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-rel' stretchy='false'>⋯</mo><mspace class='negthinspace' width='-0.17em'></mspace><mspace class='negthinspace' width='-0.17em'></mspace> </mtd><mtd class='array-td' columnalign='center'> <msub><mrow><mi>C</mi></mrow><mrow><mi>j</mi></mrow></msub> </mtd><mtd class='array-td' columnalign='center'> <mspace class='negthinspace' width='-0.17em'></mspace><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-rel' stretchy='false'>⋯</mo><mspace class='negthinspace' width='-0.17em'></mspace><mspace class='negthinspace' width='-0.17em'></mspace> </mtd><mtd class='array-td' columnalign='center'> <msub><mrow><mi>C</mi></mrow><mrow><mi>n</mi></mrow></msub> </mtd>
</mtr>    <!-- *\c@MaxMatrixCols c --></mtable>                                                                                                      </mrow><mo fence='true' form='postfix'>)</mo></mrow>
</mrow></math></td></tr></table>
<!-- l. 203 --><p class='indent'>   A general property of invertible square matrices is we can reduce
them to the identity matrix by means of primitive row operations or
primitive column operations. For a generic field, there are two kinds of
primitive row/column operations: multiplying a row/column by a
non-zero scalar and adding one row/column to another. This is what
happens when we apply the <span class='cmbx-10x-x-109'>Gauss-Jordan reduction </span>procedure,
sometimes called simply Gaussian elimination, to an invertible matrix. For
<!-- l. 203 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>, there is only one
non-zero scalar, <!-- l. 203 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>,
so in fact the second kind is all we need. There are two, essentially equivalent
ways we can do Gauss-Jordan reduction, either working from the left side of the
matrix with row operations or the right side of the matrix with column
operations. Although it is the (slightly) less typical version, here we’ll use column
operations. This will make things easier when it comes to generalising to
bigger families of circuits in Chapter <a href='main_htmlch7.html#universal-circuits'>7<!-- tex4ht:ref: ch:universal  --></a>. Suppose we find any sequence of
<!-- l. 205 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
primitive column operations that reduce a parity matrix to
the identity. Then we have a series of elementary matrices
                                                                     

                                                                     
<!-- l. 205 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>E</mi></mrow><mrow><msub><mrow><mi>i</mi></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mi>j</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></msup><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mi>E</mi></mrow><mrow><msub><mrow><mi>i</mi></mrow><mrow><mi>k</mi></mrow></msub><msub><mrow><mi>j</mi></mrow><mrow><mi>k</mi></mrow></msub></mrow></msup></mrow></math> such
that: </p><table class='equation-star'><tr><td>
<!-- l. 206 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                          <mi>A</mi><msup><mrow><mi>E</mi></mrow><mrow><msub><mrow><mi>i</mi></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mi>j</mi></mrow><mrow><mn>1</mn></mrow></msub>
      </mrow></msup><mo class='MathClass-rel' stretchy='false'>⋯</mo><msup><mrow><mi>E</mi></mrow><mrow><msub><mrow><mi>i</mi></mrow><mrow><mi>k</mi></mrow></msub><msub><mrow><mi>j</mi></mrow><mrow><mi>k</mi></mrow></msub>
     </mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi>
</mrow></math></td></tr></table>
<!-- l. 209 --><p class='indent'>   As we noted in Example <a href='#x6-91003r6'>4.1.6<!-- tex4ht:ref: ex:CNOT-parity-matrix  --></a>, each of the elementary matrices is their own
inverse. So, we can move them to the other side of this equation, reversing the
order: </p><table class='equation'><tr><td>
<!-- l. 210 --><p class='indent'>
</p><!-- l. 210 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                           <mstyle class='label' id='x6-91004r4'></mstyle><!-- endlabel --><mi>A</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>E</mi></mrow><mrow><msub><mrow><mi>i</mi></mrow><mrow><mi>k</mi></mrow></msub><msub><mrow><mi>j</mi></mrow><mrow><mi>k</mi></mrow></msub>
     </mrow></msup><mo class='MathClass-rel' stretchy='false'>⋯</mo><msup><mrow><mi>E</mi></mrow><mrow><msub><mrow><mi>i</mi></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mi>j</mi></mrow><mrow><mn>1</mn></mrow></msub>
      </mrow></msup>
</mrow></math></td><td class='eq-no'>(4.4)</td></tr></table>
<!-- l. 213 --><p class='indent'>   Hence, we can see Gaussian elimination as a way of decomposing
invertible matrices as a composition of elementary matrices. Since we know
that every parity matrix coming from a CNOT circuit is invertible and
that each elementary matrix corresponds to a CNOT gate, we see that
synthesising CNOT circuits from parity matrices amounts to Gaussian
elimination! We give the full synthesis procedure in Algorithm <a href='#x6-91005r1'>1<!-- tex4ht:ref: alg:cnot-synth  --></a>. Note we write
<!-- l. 214 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mstyle class='text'><mtext>CNOT</mtext></mstyle></mrow><mrow><mi mathvariant='italic'>ij</mi></mrow></msup></math> for a CNOT gate with a
control on the <!-- l. 214 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math>-th qubit
and a target on the <!-- l. 214 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>j</mi></math>-th
qubit. <a id='x6-91005r1'></a>
                                                                     

                                                                     
</p><!-- l. 215 --><p class='indent'>   </p><figure class='float' id='x6-91007'><span id='cnot-circuit-synthesis-by-gaussjordan-reduction'></span>
                                                                     

                                                                     
                                                                     

                                                                     
_____________________________________________________________________
  <span class='cmbx-10x-x-109'>Algorithm 1:</span> CNOT    circuit    synthesis    by    Gauss-Jordan
  reduction____________________________________________________________________________________ 
     <span class='cmbx-10x-x-109'>Input:</span> An
               <!-- l. 218 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>×</mo> <mi>n</mi></mrow></math>
             invertible
               parity
               matrix
               <!-- l. 218 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>
    <span class='cmbx-10x-x-109'>Output:</span> A
                  CNOT
                  circuit
                  implementing
                  <!-- l. 219 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>
    <span class='cmbx-10x-x-109'>Procedure</span> <span class='cmbx-10x-x-109'>CNOT-SYNTH</span><span class='cmti-10x-x-109'>(</span><!-- l. 245 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math><span class='cmti-10x-x-109'>)</span>
      
   let
     <!-- l. 245 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>C</mi></math>
    be
     an
     empty
     circuit
     on
     <!-- l. 245 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
    qubits
   <span class='cmbx-10x-x-109'>for</span> <!-- l. 245 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>i</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>
     <span class='cmbx-10x-x-109'>to</span>
    <!-- l. 245 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math> <span class='cmbx-10x-x-109'>do
    </span><span class='cmti-10x-x-109'>// forward
    part
    
   </span><span class='cmbx-10x-x-109'>if</span> <!-- l. 245 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>A</mi></mrow><mrow><mi mathvariant='italic'>ii</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math> <span class='cmbx-10x-x-109'>then 
   </span><span class='cmti-10x-x-109'>// ensure
       that
       a
       1
       is
       on
       the
       diagonal</span>
   find 
<!-- l. 245 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>&gt;</mo> <mi>i</mi></mrow></math> 
such 
that 
<!-- l. 245 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>A</mi></mrow><mrow><mi mathvariant='italic'>ik</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>≠</mo><mn>0</mn></mrow></math>
   add 
column 
<!-- l. 245 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> 
of 
<!-- l. 245 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math> 
to 
column 
<!-- l. 245 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math>
   append 
<!-- l. 245 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mstyle class='text'><mtext>CNOT</mtext></mstyle></mrow><mrow><mi mathvariant='italic'>ik</mi></mrow></msup></math> 
to 
<!-- l. 245 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>C</mi></math>
   <span class='cmbx-10x-x-109'>end
   for</span> <!-- l. 245 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>j</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>i</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn></mrow></math> 
<span class='cmbx-10x-x-109'>to</span> 
<!-- l. 245 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math> <span class='cmbx-10x-x-109'>do 
   if</span> <!-- l. 245 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>A</mi></mrow><mrow><mi mathvariant='italic'>ij</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>≠</mo><mn>0</mn></mrow></math> <span class='cmbx-10x-x-109'>then</span> 
   add 
column 
<!-- l. 245 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math> 
of 
<!-- l. 245 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math> 
to 
column 
<!-- l. 245 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>j</mi></math>
   append 
<!-- l. 245 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mstyle class='text'><mtext>CNOT</mtext></mstyle></mrow><mrow><mi mathvariant='italic'>ji</mi></mrow></msup></math> 
to 
<!-- l. 245 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>C</mi></math>
   <span class='cmbx-10x-x-109'>end
   end
   end
   for</span> <!-- l. 245 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>i</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>n</mi></mrow></math>
    <span class='cmbx-10x-x-109'>to</span>
    <!-- l. 245 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math> <span class='cmbx-10x-x-109'>do
    </span><span class='cmti-10x-x-109'>// backwards
    part
    
   </span><span class='cmbx-10x-x-109'>for</span> <!-- l. 245 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>j</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>i</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-punc' stretchy='false'>.</mo><mo class='MathClass-punc' stretchy='false'>.</mo><mo class='MathClass-punc' stretchy='false'>.</mo><mn>1</mn></mrow></math> <span class='cmbx-10x-x-109'>do 
   if</span> <!-- l. 245 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>A</mi></mrow><mrow><mi mathvariant='italic'>ij</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>≠</mo><mn>0</mn></mrow></math> <span class='cmbx-10x-x-109'>then</span> 
   add 
column 
<!-- l. 245 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math> 
of 
<!-- l. 245 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math> 
to 
column 
<!-- l. 245 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>j</mi></math>
   append 
<!-- l. 245 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mstyle class='text'><mtext>CNOT</mtext></mstyle></mrow><mrow><mi mathvariant='italic'>ji</mi></mrow></msup></math> 
to 
<!-- l. 245 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>C</mi></math>
   <span class='cmbx-10x-x-109'>end
   end
   end
   return</span>
    <!-- l. 245 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>C</mi></math>
    <span class='cmbx-10x-x-109'>end</span>_____________________________________________________________________________

                                                                     
                                                                     

                                                                     
   </figure>
   <div class='newtheorem'>
<!-- l. 246 --><p class='noindent'><span class='head'>
<a id='x6-91008r7'></a>
<span class='cmbx-10x-x-109'>Theorem 4.1.7.</span>  </span> Algorithm <a href='#x6-91005r1'>1<!-- tex4ht:ref: alg:cnot-synth  --></a> works.
</p>
   </div>
<!-- l. 248 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 250 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>This algorithm produces one CNOT gate corresponding to each elementary
column operation in the decomposition of <!-- l. 250 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>
from equation <a href='#x6-91004r4'>4.4<!-- tex4ht:ref: eq:gauss-decomp  --></a>. Hence, the overall effect of <!-- l. 250 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>C</mi></math>
on a computation basis input will be the composition of these elementary
matrices, which is <!-- l. 250 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>.
                                                                   □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 252 --><p class='noindent'><span class='head'>
<a id='x6-91009r1'></a>
<span class='cmbx-10x-x-109'>Exercise 4.1.</span>  </span>Consider the following CNOT circuit:
</p>
<div class='center'>
<!-- l. 255 --><p class='noindent'>
</p><!-- l. 256 --><p class='noindent'><object data="svgs/CNOT-circuit-exer.svg" alt="diagram of CNOT-circuit-exer" class="svg-diagram"></object> </p></div>
   <dl class='enumerate'><dt class='enumerate'>
a) </dt><dd class='enumerate'>
   <!-- l. 260 --><p class='noindent'>Calculate the parity matrix of this circuit.
   </p></dd><dt class='enumerate'>
b) </dt><dd class='enumerate'>
   <!-- l. 261 --><p class='noindent'>Resynthesise a new equivalent CNOT circuit from this parity matrix by
   using Algorithm <a href='#x6-91005r1'>1<!-- tex4ht:ref: alg:cnot-synth  --></a>. </p></dd></dl>
                                                                     

                                                                     
   </div>
<!-- l. 263 --><p class='indent'>
</p>
   <h3 class='sectionHead' id='the-phasefree-zx-calculus'><span class='titlemark'>4.2   </span> <a id='x6-920004.2'></a>The phase-free ZX calculus</h3>
   <figure class='figure' id='x6-920010'><span id='the-rules-of-the-phasefree-zx-calculus-the-spider-rules-sp-and-strong-complementarity-sc-note-the-righthandside-of-the-sc-rule-is-a-complete-bipartite-graph-of-m-z-spiders-and-n-x-spiders-with-a-normalisation-factor-mn-which-we-typically-drop-when-scalar-factors-are-irrelevant'></span> 

                                                                     

                                                                     

                                                                     

                                                                     
<!-- l. 266 --><p class='noindent'>figure<a id='figure._theHfigure_'></a>
</p><!-- l. 268 --><p class='noindent'><img src="svgs/zx-phase-free2.svg" alt="diagram of zx-phase-free2" class="inline-diagram" />
</p>
<figcaption class='caption'><span class='id'>Figure 4.0:    </span><span class='content'>    The    rules    of    the    phase-free    ZX    calculus:    the
spider    rules    (sp)    and    strong    complementarity    (sc).    Note    the
righthand-side   of   the   (sc)   rule   is   a   complete   bipartite   graph   of
<!-- l. 270 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>m</mi></math>
Z spiders and <!-- l. 270 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
X           spiders,           with           a           normalisation           factor
<!-- l. 270 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ν</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mn>2</mn></mrow><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>m</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn></mrow></msup></mrow></math>,
which we typically drop when scalar factors are irrelevant.</span></figcaption><!-- tex4ht:label?: x6-920010  -->
                                                                     

                                                                     
   </figure>
<!-- l. 272 --><p class='indent'>   Now that we understand CNOT circuits and their relationship to parity
matrices a bit better, let’s turn our attention to phase-free ZX-diagrams and the
phase-free ZX calculus. As we noted at the beginning of this chapter, phase-free
ZX-diagrams are those without Hadamard gates and whose spiders all have phase
0. It turns out that once we make this restriction, one can simplify the rules a
great deal. As we’ll see in Section <a href='#phasefree-completeness'>4.3.1<!-- tex4ht:ref: sec:pp-complete  --></a>, the rules in Figure <a href='#the-rules-of-the-phasefree-zx-calculus-the-spider-rules-sp-and-strong-complementarity-sc-note-the-righthandside-of-the-sc-rule-is-a-complete-bipartite-graph-of-m-z-spiders-and-n-x-spiders-with-a-normalisation-factor-mn-which-we-typically-drop-when-scalar-factors-are-irrelevant'>4.0<!-- tex4ht:ref: fig:pp-zx  --></a> suffice to prove
any true equation between phase-free ZX-diagrams.  We will see in this section
and the next that the phase-free ZX calculus encodes a great deal of
information about CNOT circuits, and more generally linear algebra over
<!-- l. 273 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>. To
start to get an idea of why this is the case, we’ll temporarily introduce some
<!-- l. 273 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>
phases into X spiders to represent basis states, and recap some of the things we
already saw in the previous chapter. Recall that we can represent the two
<!-- l. 274 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math>-basis states as X-spiders,
with a phase of <!-- l. 274 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math>
or <!-- l. 274 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>,
respectively: </p><table class='equation-star'><tr><td>
<!-- l. 275 --><object data="svgs/ket0-2.svg" alt="diagram of ket0-2" class="svg-diagram"></object></td></tr></table>
<!-- l. 278 --><p class='indent'>   where ‘<!-- l. 278 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-rel' stretchy='false'>∝</mo></mrow></math>‘
here means we are ignoring the scalar factor. Due to this fact, it will be
convenient to represent computational basis elements using a boolean variable
<!-- l. 278 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo><mo class='MathClass-open' stretchy='false'>{</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>:
</p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 279 --><object data="svgs/ket-a.svg" alt="diagram of ket-a" class="svg-diagram"></object></td></tr></table>
<!-- l. 282 --><p class='indent'>   A Z-spider acts on a computational basis state by copying it through, while
an X-spider calculates the XOR of its inputs: </p><table class='equation-star'><tr><td>
<!-- l. 284 --><object data="svgs/basis-spider-copy.svg" alt="diagram of basis-spider-copy" class="svg-diagram"></object></td></tr></table>
<!-- l. 287 --><p class='indent'>   The latter follows from the fact that, for boolean variables
<!-- l. 287 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>b</mi></mrow></math>, we
have <!-- l. 287 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>a</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>b</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi>π</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>a</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>b</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi>π</mi></mrow></math>,
modulo <!-- l. 287 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>2</mn><mi>π</mi></mrow></math>.
Recall what the CNOT gate looks like as a ZX-diagram: </p><table class='equation-star'><tr><td>
<!-- l. 289 --><object data="svgs/CNOT-composition.svg" alt="diagram of CNOT-composition" class="svg-diagram"></object></td></tr></table>
<!-- l. 292 --><p class='indent'>   With the interpretation of the Z-spider as copying and the X-spider as XOR
we see that we can interpret this diagram as saying that we first copy the first
bit, and then XOR it with the second bit, and this is indeed how we understand
the functioning of the CNOT:
</p>
                                                                     

                                                                     
<div class='center'>
<!-- l. 296 --><p class='noindent'>
</p><!-- l. 297 --><p class='noindent'><object data="svgs/cnot-basis-action.svg" alt="diagram of cnot-basis-action" class="svg-diagram"></object> </p></div>
<!-- l. 301 --><p class='indent'>   It turns out that this idea generalises to describe the action of an
arbitrary parity matrix in the following way: suppose we have an
<!-- l. 302 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>×</mo> <mi>m</mi></mrow></math> parity
matrix <!-- l. 302 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>,
then its corresponding ZX-diagram is given by </p>
     <ul class='itemize1'>
     <li class='itemize'>one Z-spider connected to each input <!-- l. 304 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>1</mn> <mo class='MathClass-rel' stretchy='false'>≤</mo> <mi>i</mi> <mo class='MathClass-rel' stretchy='false'>≤</mo> <mi>n</mi></mrow></math>
     and one X-spider connected to each output <!-- l. 304 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>1</mn> <mo class='MathClass-rel' stretchy='false'>≤</mo> <mi>j</mi> <mo class='MathClass-rel' stretchy='false'>≤</mo> <mi>m</mi></mrow></math>,
     </li>
     <li class='itemize'>a connection from the <!-- l. 305 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math>th
     Z-spider to the <!-- l. 305 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>j</mi></math>th
     X-spider if and only if <!-- l. 305 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>A</mi></mrow><mrow><mi mathvariant='italic'>ij</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>.
     </li></ul>
<!-- l. 307 --><p class='noindent'>Another way to say this is that the <span class='cmbx-10x-x-109'>biadjacency matrix </span>of the connectivity from
the Z-spiders to the X-spiders is equal to the parity matrix. This biadjacency
matrix has a row for each X-spider, and a column for every Z-spider, and there is
a <!-- l. 308 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math> in the
matrix when the corresponding Z-spider is connected to the corresponding X-spider,
and a <!-- l. 308 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math>
if they are not connected. Just like for CNOT circuits in the previous section, the
parity matrix of a ZX-diagram in parity form exactly captures the action of the
associated linear map on computational basis states.
</p>
   <div class='newtheorem'>
<!-- l. 310 --><p class='noindent'><span class='head'>
<a id='x6-92002r1'></a>
<span class='cmbx-10x-x-109'>Example 4.2.1.</span>  </span>We have the following correspondence between this parity
matrix and a ZX-diagram: </p><table class='equation'><tr><td>
<!-- l. 312 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 312 --><object id='x6-92003r5' data="svgs/eq-parity-form-ex.svg" alt="diagram of eq:parity-form-ex" class="svg-diagram"></object></td><td class='eq-no'>(4.5)</td></tr></table>
<!-- l. 315 --><p class='indent'>   From the parity matrix, we can compute the action of the linear map on basis
states (up to some scalar factor): </p><table class='equation-star'><tr><td>
<!-- l. 316 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
 <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn></mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                          </mrow><mo fence='true' form='postfix'>)</mo></mrow> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub>  </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub>  </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub>  </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                                                    </mrow><mo fence='true' form='postfix'>)</mo></mrow>  <mo class='MathClass-rel' stretchy='false'>=</mo>  <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub>  </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub>  </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                                           </mrow><mo fence='true' form='postfix'>)</mo></mrow>
</mrow></math></td></tr></table>
<!-- l. 330 --><p class='indent'>   In other words, the linear map depicted above acts as follows on basis states:
</p><table class='equation-star'><tr><td>
<!-- l. 331 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                   <mi>L</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-punc' stretchy='false'>:</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>↦</mo><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo>
</mrow></math></td></tr></table>
<!-- l. 334 --><p class='indent'>   We can check this by inputting a computational basis state, expressed in
terms of X-spiders and reducing: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 335 --><object data="svgs/ZX-parity-matrix-example-pf.svg" alt="diagram of ZX-parity-matrix-example-pf" class="svg-diagram"></object></td></tr></table>
   </div>
<!-- l. 338 --><p class='indent'>    It will be helpful to have a name for diagrams such as the one depicted in
equation (<a href='#x6-92003r5'>4.5<!-- tex4ht:ref: eq:parity-form-ex  --></a>) above.
</p>
   <div class='newtheorem'>
<!-- l. 340 --><p class='noindent'><span class='head'>
<a id='x6-92004r2'></a>
<span class='cmbx-10x-x-109'>Definition 4.2.2.</span>  </span> We say a phase-free ZX-diagram is in <span class='cmbx-10x-x-109'>parity normal form</span>
(PNF) when </p>
     <ul class='itemize1'>
     <li class='itemize'>every Z-spider is connected to exactly one input,
     </li>
     <li class='itemize'>every X-spider is connected to exactly one output,
     </li>
     <li class='itemize'>spiders are only connected to spiders of the opposite colour and via at
     most one wire. </li></ul>
   </div>
<!-- l. 347 --><p class='indent'>    If a diagram is in PNF, the only relevant information is the number of
inputs, number of outputs, and which inputs are connected to which outputs.
Hence biadjacency matrices are in 1-to-1 correspondence with ZX-diagrams in
parity normal form.
                                                                     

                                                                     
</p>
   <h4 class='subsectionHead' id='reducing-a-zxdiagram-to-normal-form'><span class='titlemark'>4.2.1   </span> <a id='x6-930004.2.1'></a>Reducing a ZX-diagram to normal form</h4>
<!-- l. 350 --><p class='noindent'>We have now seen that we can represent a CNOT circuit as a parity matrix and
parity matrices as ZX-diagrams in parity normal form. Additionally, using
Gaussian elimination we can go back from this parity form to a CNOT circuit.
There is just one step missing in this trifecta of representations: how to reduce a
unitary phase-free ZX-diagram to parity normal form. This is what we will do in
this section. Apart from it being useful to understand how CNOT circuits relate
to ZX-diagrams, it will also give us a first taste about how to define
simplification strategies in the ZX-calculus. The first step in this process of
simplification will be to bring the ZX-diagram into a more canonical
form.
</p>
   <div class='newtheorem'>
<!-- l. 353 --><p class='noindent'><span class='head'>
<a id='x6-93001r3'></a>
<span class='cmbx-10x-x-109'>Definition 4.2.3.</span>  </span> We say a ZX-diagram is <span class='cmbx-10x-x-109'>two-coloured </span>when
     </p><dl class='enumerate'><dt class='enumerate'>
  1.. </dt><dd class='enumerate'>
     <!-- l. 356 --><p class='noindent'>no spiders of the same colour are connected to each other,
     </p></dd><dt class='enumerate'>
  2.. </dt><dd class='enumerate'>
     <!-- l. 357 --><p class='noindent'>there are no self-loops,
     </p></dd><dt class='enumerate'>
  3.. </dt><dd class='enumerate'>
     <!-- l. 358 --><p class='noindent'>there is at most one wire between each pair of spiders,
     </p></dd><dt class='enumerate'>
  4.. </dt><dd class='enumerate'>
     <!-- l. 359 --><p class='noindent'>there are no Hadamards. </p></dd></dl>
   </div>
<!-- l. 361 --><p class='indent'>    We call such diagrams two-coloured because we can view them as simple
graphs (where the spiders are the vertices) with a two-colouring (corresponding
to the colours of the spiders).
</p>
   <div class='newtheorem'>
<!-- l. 363 --><p class='noindent'><span class='head'>
<a id='x6-93006r4'></a>
                                                                     

                                                                     
<span class='cmbx-10x-x-109'>Lemma 4.2.4.</span>  </span>  Any  ZX-diagram  (not  just  a  phase-free  one)  can  be
efficiently simplified to a two-coloured one.
</p>
   </div>
<!-- l. 365 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 367 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>Given a ZX-diagram we do the following rewrites. First, if there are
any Hadamards, we decompose them into spiders using <!-- l. 368 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='label' xlink:href='main_htmlch3.html#x5-580020' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'><mstyle mathvariant='bold'><mi>eu</mi></mstyle></mstyle><!-- endlabel --><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>,
so that the diagram will only contain actual spiders. Then we apply <!-- l. 369 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='label' xlink:href='main_htmlch3.html#x5-580020' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'><mstyle mathvariant='bold'><mi>sp</mi></mstyle></mstyle><!-- endlabel --><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
wherever we can. As a result, no two spider of the same colours are connected
to each other in the resulting diagram (since otherwise we would have fused
them). Second, we apply Eq. (<a href='main_htmlch3.html#x5-59006r39'>3.39<!-- tex4ht:ref: eq:self-loop-removal  --></a>) to remove all self-loops on the spiders, so
that the resulting diagrams has no self-loops left. Finally, whenever there is
more than one connection between a pair of spiders, we apply complementarity (<a href='main_htmlch3.html#x5-64005r64'>3.64<!-- tex4ht:ref: eq:hopf-rule  --></a>)
in order to remove a pair of these connections. This can always be done since
the connections must necessarily be between spiders of different colours.    □
</p>
   </div>
<!-- l. 373 --><p class='indent'>   Given a phase-free ZX-diagram we can apply the above procedure to reduce it
a two-coloured diagram. This diagram will of course still be phase-free. Now we
will apply rewrites to this diagram that bring it closer to parity normal form. In
the parity normal form, all Z-spiders are connected to an input, while all
X-spiders are connected to an output. So, ‘bringing it closer’ to the normal form
means reducing the number of Z-spiders that are <span class='cmti-10x-x-109'>not </span>connected to an input or
reducing the number of X-spiders <span class='cmti-10x-x-109'>not </span>connected to an output. The way we
do this will be to strategically apply the strong complementarity rule
<!-- l. 374 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='label' xlink:href='main_htmlch3.html#x5-580020' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'><mstyle mathvariant='bold'><mi>sc</mi></mstyle></mstyle><!-- endlabel --><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
</p>
   <div class='newtheorem'>
<!-- l. 375 --><p class='noindent'><span class='head'>
<a id='x6-93007r5'></a>
<span class='cmbx-10x-x-109'>Definition 4.2.5.</span>  </span>  We  say  a  spider  is  an  <span class='cmbx-10x-x-109'>input  spider</span>,  respectively
<span class='cmbx-10x-x-109'>output spider </span>when it is connected to at least one input, respectively
output. If a spider is neither an input spider nor an output spider, it is called
an <span class='cmbx-10x-x-109'>internal spider</span>.
                                                                     

                                                                     
</p>
   </div>
<!-- l. 377 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 378 --><p class='noindent'><span class='head'>
<a id='x6-93008r6'></a>
<span class='cmbx-10x-x-109'>Definition 4.2.6.</span>  </span> We say a phase-free ZX-diagram is in <span class='cmbx-10x-x-109'>generalised parity
form </span>when it is two-coloured and
     </p><dl class='enumerate'><dt class='enumerate'>
  1.. </dt><dd class='enumerate'>
     <!-- l. 381 --><p class='noindent'>every input is connected to a Z-spider and every output to a X-spider,
     </p></dd><dt class='enumerate'>
  2.. </dt><dd class='enumerate'>
     <!-- l. 382 --><p class='noindent'>every spider is connected to at most 1 input or output,
     </p></dd><dt class='enumerate'>
  3.. </dt><dd class='enumerate'>
     <!-- l. 383 --><p class='noindent'>there are no zero-arity (i.e. scalar) spiders, and
     </p></dd><dt class='enumerate'>
  4.. </dt><dd class='enumerate'>
     <!-- l. 384 --><p class='noindent'>no internal spiders are connected directly to each other. </p></dd></dl>
   </div>
<!-- l. 386 --><p class='indent'>    To phrase the condition above in a different way, it is saying that there are only
two kinds of Z-spiders: input Z-spiders and internal Z-spiders directly connected
to output X-spiders. A similar categorisation applies to X-spiders, reversing the
role of inputs/outputs. Hence, the generalised parity form looks like this, for
some <!-- l. 387 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>m</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>n</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>j</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mn>0</mn></mrow></math>:
</p><table class='equation'><tr><td>
<!-- l. 388 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 388 --><object id='x6-93013r6' data="svgs/eq-phase-free-nf.svg" alt="diagram of eq:phase-free-nf" class="svg-diagram"></object></td><td class='eq-no'>(4.6)</td></tr></table>
<!-- l. 391 --><p class='indent'>   What makes this form “generalised” as opposed to diagrams in
parity normal form is the possibility of some internal spiders. When
<!-- l. 391 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>j</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>k</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>, we
get exactly the parity normal form. In Algorithm <a href='#x6-93014r2'>2<!-- tex4ht:ref: alg:phase-free-reduce  --></a> we show how to
efficiently transform a phase-free ZX-diagram into generalised parity form.
<a id='x6-93014r2'></a>
                                                                     

                                                                     
</p><!-- l. 393 --><p class='indent'>   </p><figure class='float' id='x6-93016'><span id='reducing-to-generalised-parity-form'></span>
                                                                     

                                                                     
                                                                     

                                                                     
_____________________________________________________________________
  <span class='cmbx-10x-x-109'>Algorithm 2:</span> Reducing to generalised parity form____________________________ 
     <span class='cmbx-10x-x-109'>Input:</span> A
               phase-free
               ZX-diagram
     <span class='cmbx-10x-x-109'>Output:</span> A
                  phase-free
                  ZX-diagram
                  in
                  generalised
                  parity
                  form
            <dl class='enumerate'><dt class='enumerate'>
       1.. </dt><dd class='enumerate'>
            <!-- l. 399 --><p class='noindent'>Apply
            <!-- l. 399 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='label' xlink:href='main_htmlch3.html#x5-580020' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'><mstyle mathvariant='bold'><mi>sp</mi></mstyle></mstyle><!-- endlabel --><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
            as
            much
            as
            possible
            and
            remove
            zero-arity
            spiders
            by
            multiplying
            the
            overall
            scalar
            by
            2.
            </p></dd><dt class='enumerate'>
       2.. </dt><dd class='enumerate'>
            <!-- l. 400 --><p class='noindent'>Try to apply <!-- l. 400 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='label' xlink:href='main_htmlch3.html#x5-580020' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'><mstyle mathvariant='bold'><mi>sc</mi></mstyle></mstyle><!-- endlabel --><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
            where </p>
                   <ul class='itemize1'>
                   <li class='itemize'><img src="svgs/zdot.svg" alt="diagram of zdot" class="inline-diagram" />
                   is
                   <span class='cmbx-10x-x-109'>not</span>
                an
                   input
                   and
                   </li>
                   <li class='itemize'><img src="svgs/xdot.svg" alt="diagram of xdot" class="inline-diagram" />
                   is
                   <span class='cmbx-10x-x-109'>not</span>
                an
                   output.
                   </li></ul>
            </dd><dt class='enumerate'>
       3.. </dt><dd class='enumerate'>
            <!-- l. 409 --><p class='noindent'>If <!-- l. 409 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='label' xlink:href='main_htmlch3.html#x5-580020' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'><mstyle mathvariant='bold'><mi>sc</mi></mstyle></mstyle><!-- endlabel --><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> was
            applied at step 2, go to step 1, otherwise go to step 4.
            </p></dd><dt class='enumerate'>
       4.. </dt><dd class='enumerate'>
            <!-- l. 410 --><p class='noindent'>Use <!-- l. 410 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='label' xlink:href='main_htmlch3.html#x5-580020' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'><mstyle mathvariant='bold'><mi>id</mi></mstyle></mstyle><!-- endlabel --><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> in
            reverse to ensure inputs are connected to Z-spiders, outputs are connected
            to X-spiders, and that no spider is connected to multiple inputs/outputs.
            </p></dd></dl>______________________________________________________________________________________

                                                                     
                                                                     

                                                                     
   </figure>
   <div class='newtheorem'>
<!-- l. 413 --><p class='noindent'><span class='head'>
<a id='x6-93021r7'></a>
<span class='cmbx-10x-x-109'>Lemma 4.2.7.</span>  </span> Algorithm <a href='#x6-93014r2'>2<!-- tex4ht:ref: alg:phase-free-reduce  --></a> terminates efficiently with a ZX-diagram in
generalised parity form.
</p>
   </div>
<!-- l. 415 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 417 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>Note that step 1 always removes spiders from the diagram. Step 2
will remove a pair of spiders, but it will introduce new Z-spiders on all
the neighbours of <img src="svgs/xdot.svg" alt="diagram of xdot" class="inline-diagram" /> and new X-spiders on all the neighbours of
<img src="svgs/zdot.svg" alt="diagram of zdot" class="inline-diagram" /> . Since <img src="svgs/xdot.svg" alt="diagram of xdot" class="inline-diagram" />  is not an output, the only possibility
is that the new Z-spiders will be inputs or they will be adjacent to other
Z-spiders. In the latter case, they will get removed by spider fusion when
step 1 is repeated. Hence, step 2 removes a non-input Z-spider without
introducing any new non-input Z-spiders. This shows that the algorithm
terminates after a number of iterations of steps 1–3 bounded by the number
of non-output Z-spiders, where each of steps 1–4 takes polynomial time (in
the number of spiders), so the whole algorithm terminates in polynomial
time. The main loop in Algorithm <a href='#x6-93014r2'>2<!-- tex4ht:ref: alg:phase-free-reduce  --></a> will only terminate once condition 4
of Definition <a href='#x6-93008r6'>4.2.6<!-- tex4ht:ref: def:gen-parity-form  --></a> is satisfied, and since it applies step 1 just before exiting
the loop, it will be in two-coloured form. Finally, step 4 ensures condition 1
is satisfied while preserving the other conditions.                                 □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 426 --><p class='noindent'><span class='head'>
<a id='x6-93022r2'></a>
<span class='cmbx-10x-x-109'>Exercise 4.2.</span>  </span>Show how Step 4 in Algorithm <a href='#x6-93014r2'>2<!-- tex4ht:ref: alg:phase-free-reduce  --></a> works. That is, show that
we                                           can                                           use
<!-- l. 427 --><object data="svgs/phase-free-nf.svg" alt="diagram of phase-free-nf" class="svg-diagram"></object>
in reverse to fix (1) cases where inputs/outputs are not connected to the
correct type of spider and (2) cases where multiple inputs/outputs connect
to the same spider.
                                                                     

                                                                     
</p>
   </div>
<!-- l. 428 --><p class='indent'>    Now, why do we care about generalised parity form? Well, it turns out that
if the diagram describes a unitary, that such a diagram <span class='cmti-10x-x-109'>must </span>be in parity normal
form.
</p>
   <div class='newtheorem'>
<!-- l. 430 --><p class='noindent'><span class='head'>
<a id='x6-93023r8'></a>
<span class='cmbx-10x-x-109'>Proposition 4.2.8.</span>  </span>                                                          Let
<!-- l. 431 --><object data="svgs/phase-free-nf.svg" alt="diagram of phase-free-nf" class="svg-diagram"></object>
be a diagram in generalised parity form:
</p>
<div class='center'>
<!-- l. 433 --><p class='noindent'>
</p><!-- l. 434 --><p class='noindent'><object data="svgs/phase-free-nf.svg" alt="diagram of phase-free-nf" class="svg-diagram"></object> </p></div>
<!-- l. 437 --><p class='indent'>   If <!-- l. 437 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>D</mi></math> is an
isometry, then <!-- l. 437 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>j</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>
and if it is unitary <!-- l. 437 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>j</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>k</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>.
In particular, a unitary in generalised parity form is already in parity normal
form.
</p>
   </div>
<!-- l. 438 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 440 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>We first need to show that if <!-- l. 440 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>D</mi></math>
is an isometry then <!-- l. 440 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>.
That is, every Z-spider is connected to an input. Suppose there is an X-spider that is
not connected to any output. By assumption we don’t have any floating scalar
spiders, so it must be connected to at least some Z-spiders. Since the diagram is
in generalised parity form, these must then all be input Z-spiders. Input a
<!-- l. 441 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
to one of the input Z-spiders that the X-spider is connected to and
<!-- l. 441 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> to
all the others. Then after copying states and fusing spiders there is a
                                                                     

                                                                     
<!-- l. 441 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math> phase
on the X-spider: </p><table class='equation-star'><tr><td>
<!-- l. 442 --><object data="svgs/reduced-is-unitary-X.svg" alt="diagram of reduced-is-unitary-X" class="svg-diagram"></object></td></tr></table>
<!-- l. 445 --><p class='indent'>   Hence, we have some input state that is mapped to zero, which contradicts
<!-- l. 445 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>D</mi></math>
being an isometry. So all X-spiders must be connected to an
output, and hence to a unique one by the previous paragraph. If
<!-- l. 446 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>D</mi></math>
is furthermore unitary, then we can similarly show that
<!-- l. 446 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>, i.e. that
each Z-spider must be connected to an input. If this were not the case, we can
plug <!-- l. 446 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext class='MathClass-open' stretchy='false'>⟨−|⊗⟨+|⊗…⟨+|</mtext></mrow></math>
into a subset of the output qubits to send the whole diagram to
<!-- l. 446 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math>,
which contradicts unitarity (since unitaries also preserve the norm of bras, and
not just kets).                                                                               □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 448 --><p class='noindent'><span class='head'>
<a id='x6-93024r9'></a>
<span class='cmbx-10x-x-109'>Theorem 4.2.9.</span>  </span> Any  unitary  phase-free  ZX-diagram  can  be  efficiently
rewritten in parity normal form.
</p>
   </div>
<!-- l. 450 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 452 --><p class='indent'>   <span class='head'>
                                                                     

                                                                     
<span class='cmti-10x-x-109'>Proof.</span> </span>First  use  Lemma <a href='#x6-93006r4'>4.2.4<!-- tex4ht:ref: lem:two-coloured  --></a>  to  reduce  it  to  two-coloured  form.  Then
apply Algorithm <a href='#x6-93014r2'>2<!-- tex4ht:ref: alg:phase-free-reduce  --></a> to reduce it further to generalised parity form. Since
the diagram is unitary, it must then already be in parity normal form by
Proposition <a href='#x6-93023r8'>4.2.8<!-- tex4ht:ref: prop:unitary-reduced-is-parity  --></a>.                                                                         □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 454 --><p class='noindent'><span class='head'>
<a id='x6-93025r3'></a>
<span class='cmbx-10x-x-109'>Exercise 4.3.</span>  </span>Prove that phase-free ZX-diagrams are invertible if and only
if they are unitary. <span class='cmti-10x-x-109'>Hint: Look closely at the assumptions that are needed to
make the proof of Proposition </span><a href='#x6-93023r8'><span class='cmti-10x-x-109'>4.2.8</span><!-- tex4ht:ref: prop:unitary-reduced-is-parity  --></a> <span class='cmti-10x-x-109'>work.</span>
</p>
   </div>
<!-- l. 457 --><p class='indent'>
</p>
   <h4 class='subsectionHead' id='graphical-cnot-circuit-extraction'><span class='titlemark'>4.2.2   </span> <a id='x6-940004.2.2'></a>Graphical CNOT circuit extraction</h4>
<!-- l. 459 --><p class='noindent'>In this section, we will see that we can derive the exact same CNOT circuit
synthesis procedure from Section <a href='#cnot-circuit-synthesis'>4.1.3<!-- tex4ht:ref: sec:cnot-synth  --></a> starting with ZX-diagrams in parity
normal form and applying strong complementarity to extract a CNOT circuit via
Gaussian elimination. While the ZX reformulation doesn’t tell us something new
about the specific case of CNOT circuits <span class='cmti-10x-x-109'>per se</span>, we will see this basic graphical
technique appearing in various guises throughout the book, so it will be
instructive to work through it explicitly here. For instance, if we have
a diagram that is more complicated, but locally has a part that looks
like like a parity normal form, then we can still (partially) apply the
graphical Gaussian elimination strategy. The key point to the proof is
to realise that the phase-free ZX-calculus already ‘knows’ how to do
<!-- l. 460 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>-linear
algebra. To get started, we’ll see that we can prove that CNOT matrices perform
elementary column operations on parity matrices using just the ZX rules. First of
all, what does this look like graphically? In a parity normal form, the Z-spiders
correspond to columns of the biadjacency (i.e. parity) matrix, and the wires
coming out of the Z-spider correspond to 1’s in that column. In order to see a
CNOT as performing a column operation, we should therefore see that
pre-composing two Z-spiders by a CNOT has the effect of “adding” the
connections of one spider to the other, modulo 2. That is the content of the
following lemma.
                                                                     

                                                                     
</p>
   <div class='newtheorem'>
<!-- l. 462 --><p class='noindent'><span class='head'>
<a id='x6-94001r10'></a>
<span class='cmbx-10x-x-109'>Lemma 4.2.10.</span>  </span> The following identity holds in the ZX-calculus: </p><table class='equation-star'><tr><td>
<!-- l. 464 --><object data="svgs/CNOT-parity-reduce.svg" alt="diagram of CNOT-parity-reduce" class="svg-diagram"></object></td></tr></table>
   </div>
<!-- l. 467 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 469 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span></p><table class='equation-star'><tr><td>
<!-- l. 469 --><object data="svgs/CNOT-parity-reduce-pf.svg" alt="diagram of CNOT-parity-reduce-pf" class="svg-diagram"></object></td></tr></table>
   <table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 472 --><object data="svgs/CNOT-parity-reduce-pf-2.svg" alt="diagram of CNOT-parity-reduce-pf-2" class="svg-diagram"></object></td></tr></table>
                                                                   □
   </div>
<!-- l. 476 --><p class='indent'>   This lemma says that when we apply a CNOT to a pair of inputs in a
diagram in parity normal form that we can ‘absorb’ this CNOT at the
cost of changing the connectivity of the diagram. In the case of parity
normal form diagrams, this change in connectivity corresponds precisely to
an elementary column operation. This is easiest to see by means of an
example.
</p>
   <div class='newtheorem'>
<!-- l. 477 --><p class='noindent'><span class='head'>
<a id='x6-94002r11'></a>
<span class='cmbx-10x-x-109'>Example 4.2.11.</span>  </span> Consider the following ZX-diagram in parity normal form,
and its associated biadjacency matrix: </p><table class='equation-star'><tr><td>
<!-- l. 479 --><object data="svgs/parity-form-unitary-1.svg" alt="diagram of parity-form-unitary-1" class="svg-diagram"></object></td></tr></table>
<!-- l. 482 --><p class='indent'>   For unitaries, this matrix will always be a square and invertible. Since
the matrix is invertible, we can always reduce it to the identity using
primitive column operations, which in turn correspond to pre-composing with
CNOT gates. For example, consider this sequence of column operations:
</p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 483 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'>
 <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                          </mrow><mo fence='true' form='postfix'>)</mo></mrow><mover class='overset'><mrow><mo class='MathClass-rel' stretchy='false'>→</mo></mrow><mrow><msub><mrow><mi>c</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>c</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>c</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></mover> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                   </mrow><mo fence='true' form='postfix'>)</mo></mrow><mover class='overset'><mrow><mo class='MathClass-rel' stretchy='false'>→</mo></mrow><mrow><msub><mrow><mi>c</mi></mrow><mrow><mn>3</mn></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>c</mi></mrow><mrow><mn>3</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>c</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></mover> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                   </mrow><mo fence='true' form='postfix'>)</mo></mrow><mover class='overset'><mrow><mo class='MathClass-rel' stretchy='false'>→</mo></mrow><mrow><msub><mrow><mi>c</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>c</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>c</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></mover> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                   </mrow><mo fence='true' form='postfix'>)</mo></mrow>
</math></td></tr></table>
<!-- l. 508 --><p class='indent'>   This corresponds to a sequence of applications of Lemma <a href='#x6-94001r10'>4.2.10<!-- tex4ht:ref: lem:CNOT-parity-reduce  --></a>, where each
one introduces a CNOT gate and changes the connectivity of the rest of diagram:
</p><table class='equation-star'><tr><td>
<!-- l. 509 --><object data="svgs/parity-form-unitary.svg" alt="diagram of parity-form-unitary" class="svg-diagram"></object></td></tr></table>
<!-- l. 512 --><p class='indent'>   Here, the diagram to the right of the dashed line is always in PNF, and its
connectivity corresponds exactly to the intermediate steps of the Gauss-Jordan
reduction.
</p>
   </div>
<!-- l. 513 --><p class='indent'>    As we noted in Section <a href='#cnot-circuit-synthesis'>4.1.3<!-- tex4ht:ref: sec:cnot-synth  --></a>, whenever a parity matrix is invertible, it is
possible to reduce it all the way to the identity using just elementary column
operations. Hence, the following proposition follows immediately.
</p>
   <div class='newtheorem'>
<!-- l. 515 --><p class='noindent'><span class='head'>
<a id='x6-94003r12'></a>
<span class='cmbx-10x-x-109'>Proposition 4.2.12.</span>  </span>  A  ZX-diagram  in  parity  normal  form  whose
biadjacency matrix is invertible can be diagrammatically rewritten into a
CNOT circuit.
                                                                     

                                                                     
</p>
   </div>
<!-- l. 517 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 518 --><p class='noindent'><span class='head'>
<a id='x6-94004r4'></a>
<span class='cmbx-10x-x-109'>Exercise 4.4.</span>  </span>We need the assumption that the biadjacency matrix is
invertible. Generate the parity normal form diagram of the following
parity matrix and try to apply the strategy above. What goes wrong?
</p><table class='equation-star'><tr><td>
<!-- l. 520 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'>
 <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                          </mrow><mo fence='true' form='postfix'>)</mo></mrow>
</math></td></tr></table>
   </div>
<!-- l. 527 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 528 --><p class='noindent'><span class='head'>
<a id='x6-94005r5'></a>
<span class='cmbx-10x-x-109'>Exercise 4.5.</span>  </span> Show that a ZX diagram in PNF is unitary if and if only
its biadjacency matrix is invertible.
</p>
   </div>
<!-- l. 530 --><p class='indent'>     Combining Lemma <a href='#x6-93021r7'>4.2.7<!-- tex4ht:ref: lem:phase-free-reduce  --></a> and Proposition <a href='#x6-93023r8'>4.2.8<!-- tex4ht:ref: prop:unitary-reduced-is-parity  --></a> we see that we have a
strategy for simplifying any unitary phase-free ZX-diagram to parity
normal form. Additionally, such a diagram is equivalent to a CNOT
circuit.
</p>
   <div class='newtheorem'>
                                                                     

                                                                     
<!-- l. 535 --><p class='noindent'><span class='head'>
<a id='x6-94006r13'></a>
<span class='cmbx-10x-x-109'>Theorem 4.2.13.</span>  </span> Any unitary phase-free ZX-diagram can be efficiently
rewritten into a CNOT circuit.
</p>
   </div>
<!-- l. 537 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 539 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>By Theorem <a href='#x6-93024r9'>4.2.9<!-- tex4ht:ref: thm:unitary-phase-free-pnf  --></a> a unitary phase-free diagram can be simplified to
parity normal form. By Exercise <a href='#x6-94005r5'>4.5<!-- tex4ht:ref: exer:pnf-invertible  --></a>, we know the associated biadjacency
matrix is invertible, hence we can apply Proposition <a href='#x6-94003r12'>4.2.12<!-- tex4ht:ref: prop:parity-to-CNOTs  --></a> to extract a
CNOT circuit.                                                                              □
</p>
   </div>
<!-- l. 541 --><p class='indent'>   As CNOT circuits themselves are unitary phase-free ZX-diagrams, this
theorem gives us an evident technique for a purely ZX-based method for
optimising CNOT circuits: from a CNOT circuit compute the PNF, then
re-extract using strong complementarity as in Example <a href='#x6-94002r11'>4.2.11<!-- tex4ht:ref: ex:pnf-reduction  --></a>.
</p>
   <div class='newtheorem'>
<!-- l. 542 --><p class='noindent'><span class='head'>
<a id='x6-94007r6'></a>
<span class='cmbx-10x-x-109'>Exercise 4.6.</span>  </span>                  If                    the                    diagram
<!-- l. 543 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> </mrow></math>
is an isometry, then it can be written as:
</p>
<div class='center'>
<!-- l. 545 --><p class='noindent'>
</p><!-- l. 546 --><p class='noindent'><object data="svgs/Vp-with-ancillae.svg" alt="diagram of Vp-with-ancillae" class="svg-diagram"></object> </p></div>
                                                                     

                                                                     
<!-- l. 549 --><p class='indent'>   where <!-- l. 549 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>V</mi> </mrow><mrow><mi>′</mi></mrow></msup></math>
is in parity normal form with an injective parity matrix
<!-- l. 549 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>P</mi></math>.
Using this fact, show that we can then furthermore write
<!-- l. 549 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> </mrow></math>
as follows, in terms of a unitary phase-free diagram
<!-- l. 549 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>:
</p>
<div class='center'>
<!-- l. 551 --><p class='noindent'>
</p><!-- l. 552 --><p class='noindent'><object data="svgs/U-with-ancillae.svg" alt="diagram of U-with-ancillae" class="svg-diagram"></object> </p></div>
   </div>
<!-- l. 555 --><p class='indent'>
</p>
   <h3 class='sectionHead' id='phasefree-states-and-f-linear-subspaces'><span class='titlemark'>4.3   </span> <a id='x6-950004.3'></a>Phase-free states and <!-- l. 562 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>
linear subspaces</h3>
<!-- l. 563 --><p class='noindent'>Let’s have a look again at the generalised parity form (<a href='#x6-93013r6'>4.6<!-- tex4ht:ref: eq:phase-free-nf  --></a>): </p><table class='equation-star'><tr><td>
<!-- l. 564 --><object data="svgs/phase-free-nf.svg" alt="diagram of phase-free-nf" class="svg-diagram"></object></td></tr></table>
<!-- l. 567 --><p class='indent'>   In the previous section, we focussed on the special case where the phase-free
ZX-diagram diagram describes a unitary, in which case we must have
<!-- l. 567 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>j</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>k</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>. We now
turn to a <span class='cmti-10x-x-109'>different </span>special case, where the ZX-diagram depicts a state. In this
case, <!-- l. 568 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>m</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>,
and hence up to scalar factors, we can also take
<!-- l. 568 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>j</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>. Hence, we are only left
with a layer of <!-- l. 568 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> internal Z
                                                                     

                                                                     
spiders, followed by a layer of <!-- l. 568 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
output X spiders: </p><table class='equation'><tr><td>
<!-- l. 569 --><p class='indent'>
</p><!-- l. 569 --><object id='x6-95001r7' data="svgs/eq-z-x-nf.svg" alt="diagram of eq:z-x-nf" class="svg-diagram"></object></td><td class='eq-no'>(4.7)</td></tr></table>
<!-- l. 572 --><p class='indent'>   Note that we could still represent such a diagram by its biadjaceny matrix,
but columns correspond to internal Z spiders rather than inputs. In particular
the order of the columns no longer matters, so rather than representing such a
diagram as a matrix, it makes more sense to represent it simply as a set of
<!-- l. 572 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>-vectors.
</p>
   <div class='newtheorem'>
<!-- l. 573 --><p class='noindent'><span class='head'>
<a id='x6-95002r1'></a>
<span class='cmbx-10x-x-109'>Definition 4.3.1.</span>  </span> The <span class='cmbx-10x-x-109'>Z-X normal form </span>of a phase-free ZX-diagram
state consists of a row of internal Z spiders connected to a row of X spiders
each connected to precisely 1 output. It can be described as a set of vectors
<!-- l. 574 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>{</mo><msub><mrow><mi>v</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>v</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>
over <!-- l. 574 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>
where <!-- l. 574 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>v</mi></mrow><mrow><mi>p</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi>q</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>
if and only if the <!-- l. 574 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>p</mi></math>-th
internal Z spider is connected to the <!-- l. 574 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>q</mi></math>-th
X spider.
</p>
<div class='center'>
<!-- l. 576 --><p class='noindent'>
</p><!-- l. 577 --><p class='noindent'><object data="svgs/phase-free-state-sm-1.svg" alt="diagram of phase-free-state-sm-1" class="svg-diagram"></object> </p></div>
   </div>
                                                                     

                                                                     
<!-- l. 580 --><p class='indent'>    At this point, the careful reader may note that a Z-X normal form might contain
more than one Z spider connected to the exact same set of X spiders. From this, one
might think we should actually describe the Z-X normal form by a <span class='cmti-10x-x-109'>multi-set </span>of
<!-- l. 581 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>-vectors,
i.e. a set that allows duplicate elements. However, thanks to the rules of the
phase-free ZX calculus, we can always remove spiders corresponding to duplicate
bit-vectors.
</p>
   <div class='newtheorem'>
<!-- l. 582 --><p class='noindent'><span class='head'>
<a id='x6-95003r7'></a>
<span class='cmbx-10x-x-109'>Exercise 4.7.</span>  </span>Show, using the phase-free ZX calculus, that: </p><table class='equation'><tr><td>
<!-- l. 584 --><p class='indent'>
</p><!-- l. 584 --><object id='x6-95004r8' data="svgs/eq-z-x-dup-remove.svg" alt="diagram of eq:z-x-dup-remove" class="svg-diagram"></object></td><td class='eq-no'>(4.8)</td></tr></table>
   </div>
<!-- l. 587 --><p class='indent'>    Unlike the parity form, the Z-X normal form is not unique. However, we will
soon see that it is straightforward to discover when two Z-X normal forms
actually describe the same state, and how in that case we can transform one into
the other. The key point is to realise that the important information captured in
<!-- l. 589 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>{</mo><msub><mrow><mi>v</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>v</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math> is not the set itself, but
rather the subspace <!-- l. 589 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
of <!-- l. 589 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msubsup><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msubsup></math> spanned by it. The
usual way to define <!-- l. 589 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
is as the set of all of the possible linear combinations of
<!-- l. 589 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>{</mo><msub><mrow><mi>v</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>v</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>:
</p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 590 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
      <mi>S</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mstyle class='text'><mtext class='textrm' mathvariant='normal'>Span</mtext></mstyle><mo class='MathClass-open' stretchy='false'>{</mo><msub><mrow><mi>v</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>v</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>}</mo> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>{</mo><msub><mrow><mi>a</mi></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mi>v</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>a</mi></mrow><mrow><mn>2</mn></mrow></msub><msub><mrow><mi>v</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo>…</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>a</mi></mrow><mrow><mi>k</mi></mrow></msub><msub><mrow><mi>v</mi></mrow><mrow><mi>k</mi></mrow></msub><mspace class='thinspace' width='0.17em'></mspace><mo class='MathClass-rel' stretchy='false'>|</mo><mspace class='thinspace' width='0.17em'></mspace><msub><mrow><mi>a</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>a</mi></mrow><mrow><mi>k</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>∈</mo> <msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>}</mo>
</mrow></math></td></tr></table>
<!-- l. 593 --><p class='indent'>   Equivalently, since the field is <!-- l. 593 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>,
we can think of <!-- l. 593 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
as the set of all vectors obtained by XOR-ing any subset of
<!-- l. 593 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>{</mo><msub><mrow><mi>v</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>v</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>,
including the zero vector (which corresponds to XOR-ing the empty set). Since
<!-- l. 594 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math> is a finite field,
any subspace of <!-- l. 594 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msubsup><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msubsup></math>
(including <!-- l. 594 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msubsup><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msubsup></math>
itself) is a finite set of vectors, so we can compute it explicitly. For example:
</p><table class='equation'><tr><td>
<!-- l. 595 --><p class='indent'>
</p><!-- l. 595 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mstyle class='label' id='x6-95005r9'></mstyle><!-- endlabel --><mstyle class='text'><mtext class='textrm' mathvariant='normal'>Span</mtext></mstyle> <mrow><mo fence='true' form='prefix'>{</mo><mrow> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                           </mrow><mo fence='true' form='postfix'>)</mo></mrow><mo class='MathClass-punc' stretchy='false'>,</mo> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                           </mrow><mo fence='true' form='postfix'>)</mo></mrow> </mrow><mo fence='true' form='postfix'>}</mo></mrow> <mo class='MathClass-rel' stretchy='false'>=</mo> <mrow><mo fence='true' form='prefix'>{</mo><mrow> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                           </mrow><mo fence='true' form='postfix'>)</mo></mrow><mo class='MathClass-punc' stretchy='false'>,</mo> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                           </mrow><mo fence='true' form='postfix'>)</mo></mrow><mo class='MathClass-punc' stretchy='false'>,</mo> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                           </mrow><mo fence='true' form='postfix'>)</mo></mrow><mo class='MathClass-punc' stretchy='false'>,</mo> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                           </mrow><mo fence='true' form='postfix'>)</mo></mrow> </mrow><mo fence='true' form='postfix'>}</mo></mrow>
</mrow></math></td><td class='eq-no'>(4.9)</td></tr></table>
<!-- l. 620 --><p class='indent'>   Let’s look at the Z-X normal form corresponding to the pair of vectors on the
lefthand-side of (<a href='#x6-95005r9'>4.9<!-- tex4ht:ref: eq:span-ex  --></a>).
</p>
<div class='center'>
<!-- l. 622 --><p class='noindent'>
</p><!-- l. 623 --><p class='noindent'><object data="svgs/z-x-nf-ex-1.svg" alt="diagram of z-x-nf-ex-1" class="svg-diagram"></object> </p></div>
<!-- l. 626 --><p class='indent'>   We can compute the state explicitly by expanding each Z spider as a sum
over X spiders: </p><table class='equation'><tr><td>
<!-- l. 627 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 627 --><object id='x6-95006r10' data="svgs/eq-z-x-nf-ex1.svg" alt="diagram of eq:z-x-nf-ex1" class="svg-diagram"></object></td><td class='eq-no'>(4.10)</td></tr></table>
<!-- l. 630 --><p class='indent'>   The result is precisely the sum over all of the vectors in the subspace (<a href='#x6-95005r9'>4.9<!-- tex4ht:ref: eq:span-ex  --></a>),
written as elements of the computational basis. This is true in general, as stated
in the following theorem.
</p>
   <div class='newtheorem'>
<!-- l. 632 --><p class='noindent'><span class='head'>
<a id='x6-95007r2'></a>
<span class='cmbx-10x-x-109'>Theorem 4.3.2.</span>  </span> For any Z-X normal form described by a set of
<!-- l. 633 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>-vectors
<!-- l. 633 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>{</mo><msub><mrow><mi>v</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>v</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>, we
have: </p><table class='equation'><tr><td>
<!-- l. 634 --><p class='indent'>
</p><!-- l. 634 --><object id='x6-95008r11' data="svgs/eq-span-form.svg" alt="diagram of eq:span-form" class="svg-diagram"></object></td><td class='eq-no'>(4.11)</td></tr></table>
   </div>
<!-- l. 637 --><p class='indent'>    This can be seen by direct calculation similar to (<a href='#x6-95006r10'>4.10<!-- tex4ht:ref: eq:z-x-nf-ex1  --></a>), by expanding each of the Z
spiders as a sum <!-- l. 638 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>.</mo><mo class='MathClass-punc' stretchy='false'>.</mo><mo class='MathClass-punc' stretchy='false'>.</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>.</mo><mo class='MathClass-punc' stretchy='false'>.</mo><mo class='MathClass-punc' stretchy='false'>.</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
and using the fact that X spiders act like XOR.
</p>
   <div class='newtheorem'>
<!-- l. 639 --><p class='noindent'><span class='head'>
<a id='x6-95009r8'></a>
                                                                     

                                                                     
<span class='cmbx-10x-x-109'>Exercise 4.8.</span>  </span>Complete the proof of Theorem <a href='#x6-95007r2'>4.3.2<!-- tex4ht:ref: thm:z-x-concrete  --></a>.
</p>
   </div>
<!-- l. 641 --><p class='indent'>    Theorem <a href='#x6-95007r2'>4.3.2<!-- tex4ht:ref: thm:z-x-concrete  --></a> says that the state associated with an
<!-- l. 642 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit
Z-X normal form is uniquely described by an
<!-- l. 642 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>-linear
subspace <!-- l. 642 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
of <!-- l. 642 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msubsup><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msubsup></math>.
From the Z-X normal form itself, we can read off a spanning set of vectors for
<!-- l. 642 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>. As a
result, we are not too far from showing completeness of the phase-free ZX
calculus.
</p>
   <h4 class='subsectionHead' id='phasefree-completeness'><span class='titlemark'>4.3.1   </span> <a id='x6-960004.3.1'></a>Phase-free completeness</h4>
<!-- l. 644 --><p class='noindent'>Recall that a <span class='cmbx-10x-x-109'>completeness </span>theorem states that if any two diagrams
correspond to the same linear map, one can be transformed to the other
just using graphical rules. In this section, we will prove completeness of
the phase-free ZX-calculus for the fragment of phase-free ZX-diagrams.
Since we have already shown that phase free states correspond to linear
subspaces and their associated Z-X normal forms correspond to sets of vectors
spanning those spaces, the only thing left to do is show that we can
transform one spanning set into another using just the phase free ZX
rules.
</p>
   <div class='newtheorem'>
<!-- l. 646 --><p class='noindent'><span class='head'>
<a id='x6-96001r3'></a>
<span class='cmbx-10x-x-109'>Proposition 4.3.3.</span>  </span> Let <!-- l. 647 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>B</mi></mstyle></math>
and <!-- l. 647 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>C</mi></mstyle></math> be two sets
spanning the same <!-- l. 647 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>-linear
subspace <!-- l. 647 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>.
Then <!-- l. 647 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>B</mi></mstyle></math> can be
transformed into <!-- l. 647 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>C</mi></mstyle></math>
by
     </p><dl class='enumerate'><dt class='enumerate'>
  1.. </dt><dd class='enumerate'>
     <!-- l. 649 --><p class='noindent'>adding or removing the zero vector, or
                                                                     

                                                                     
     </p></dd><dt class='enumerate'>
  2.. </dt><dd class='enumerate'>
     <!-- l. 650 --><p class='noindent'>replacing a pair of vectors <!-- l. 650 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>v</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>w</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo><mstyle mathvariant='script'><mi>B</mi></mstyle></mrow></math>
     with the pair <!-- l. 650 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>v</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>v</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>w</mi></mrow></math>
     zero or more times. </p></dd></dl>
   </div>
<!-- l. 652 --><p class='indent'>    We will omit the proof here, as it is a standard result in linear
algebra. Note that usually case 2 consists of replacing the pair
<!-- l. 653 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>v</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>w</mi></mrow></math> with
<!-- l. 653 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>v</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi mathvariant='italic'>λv</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>w</mi></mrow></math> for some
non-zero scalar <!-- l. 653 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>λ</mi></math>.
But in <!-- l. 653 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>, the only
non-zero scalar is <!-- l. 653 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>,
so this simplifies. We can now prove the following lemma by reproducing the two
cases of Proposition <a href='#x6-96001r3'>4.3.3<!-- tex4ht:ref: prop:subspace-span  --></a> using the ZX calculus.
</p>
   <div class='newtheorem'>
<!-- l. 655 --><p class='noindent'><span class='head'>
<a id='x6-96004r4'></a>
<span class='cmbx-10x-x-109'>Lemma 4.3.4.</span>  </span> Let <!-- l. 656 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle mathvariant='script'><mi>B</mi></mstyle> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>{</mo><msub><mrow><mi>v</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>v</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>
and <!-- l. 656 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle mathvariant='script'><mi>C</mi></mstyle> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>{</mo><msub><mrow><mi>w</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>w</mi></mrow><mrow><mi>l</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>
describe two Z-X normal forms on <!-- l. 656 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
qubit space. If the sets <!-- l. 656 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>B</mi></mstyle></math>
and <!-- l. 656 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>C</mi></mstyle></math>
span the same subspace of <!-- l. 656 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msubsup><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msubsup></math>,
one can be transformed into the other, up to a scalar factor.
</p>
   </div>
<!-- l. 657 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 659 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>We will show that the Z-X normal form for <!-- l. 659 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>B</mi></mstyle></math>
can be transformed into that for <!-- l. 659 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>C</mi></mstyle></math>
using the two cases described in Proposition <a href='#x6-96001r3'>4.3.3<!-- tex4ht:ref: prop:subspace-span  --></a>. First, note that adding
or removing a zero vector corresponds to adding or removing a zero-legged Z
spider, which simply adds or removes a scalar factor of <!-- l. 659 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>2</mn></math>.
                                                                     

                                                                     
Hence, it suffices to show that we can transform a pair of Z-spiders described
by the vectors <!-- l. 660 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>v</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>w</mi></mrow></math>
into Z spiders described by <!-- l. 660 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>v</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>v</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>w</mi></mrow></math>.
That is, we can “add” the wires of one spider to the other one, modulo 2.
We can see this by splitting the X spiders into 3 groups: those connected to
<!-- l. 660 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>v</mi></math>,
those connected to <!-- l. 660 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>w</mi></math>,
and those connected to both. We can then perform the vector addition by
two applications of the (sc) rule. First, we apply the rule in reverse:
</p>
<div class='center'>
<!-- l. 662 --><p class='noindent'>
</p><!-- l. 663 --><p class='noindent'><object data="svgs/row-op1.svg" alt="diagram of row-op1" class="svg-diagram"></object> </p></div>
<!-- l. 666 --><p class='indent'>   then forward:
</p>
<div class='center'>
<!-- l. 668 --><p class='noindent'>
</p><!-- l. 669 --><p class='noindent'><object data="svgs/row-op2.svg" alt="diagram of row-op2" class="svg-diagram"></object> </p></div>
                                                                   □
   </div>
   <div class='newtheorem'>
<!-- l. 673 --><p class='noindent'><span class='head'>
<a id='x6-96005r5'></a>
<span class='cmbx-10x-x-109'>Proposition 4.3.5.</span>  </span> If two phase-free ZX-diagram states describe the same
linear map, one can be rewritten into the other using only the rules in
Figure <a href='#the-rules-of-the-phasefree-zx-calculus-the-spider-rules-sp-and-strong-complementarity-sc-note-the-righthandside-of-the-sc-rule-is-a-complete-bipartite-graph-of-m-z-spiders-and-n-x-spiders-with-a-normalisation-factor-mn-which-we-typically-drop-when-scalar-factors-are-irrelevant'>4.0<!-- tex4ht:ref: fig:pp-zx  --></a>.
</p>
   </div>
<!-- l. 675 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 677 --><p class='indent'>   <span class='head'>
                                                                     

                                                                     
<span class='cmti-10x-x-109'>Proof.</span> </span>Suppose two diagrams describe the same quantum state. Then, they
can both be brought into Z-X normal form. By equation (<a href='#x6-95008r11'>4.11<!-- tex4ht:ref: eq:span-form  --></a>), their associated
<!-- l. 677 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>-vectors
must span the same linear space <!-- l. 677 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>.
Hence, by Lemma <a href='#x6-96004r4'>4.3.4<!-- tex4ht:ref: lem:subspace  --></a>, one can be transformed into the other. The rules
we used were only accurate up to scalar factors, however if the states are
exactly equal, then once the non-scalar portion of the diagram is made equal,
these ignored scalar factors must then also be exactly equal.                  □
</p>
   </div>
<!-- l. 679 --><p class='indent'>   We now have completeness of the phase-free ZX-calculus for states. To get
the full completeness result we need to show how to adapt this to work
for arbitrary diagrams. Because we can just bend wires this is not too
hard.
</p>
   <div class='newtheorem'>
<!-- l. 680 --><p class='noindent'><span class='head'>
<a id='x6-96006r6'></a>
<span class='cmbx-10x-x-109'>Theorem 4.3.6 </span>(Completeness of phase-free ZX)<span class='cmbx-10x-x-109'>.</span>  </span>          If            two
phase-free ZX-diagrams describe the same linear map, one can be rewritten
into the other using only the rules in Figure <a href='#the-rules-of-the-phasefree-zx-calculus-the-spider-rules-sp-and-strong-complementarity-sc-note-the-righthandside-of-the-sc-rule-is-a-complete-bipartite-graph-of-m-z-spiders-and-n-x-spiders-with-a-normalisation-factor-mn-which-we-typically-drop-when-scalar-factors-are-irrelevant'>4.0<!-- tex4ht:ref: fig:pp-zx  --></a>.
</p>
   </div>
<!-- l. 682 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 684 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>Suppose                the                phase-free                diagrams
<!-- l. 684 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>D</mi></mrow><mrow><mn>1</mn></mrow></msub></math>
and
<!-- l. 684 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>D</mi></mrow><mrow><mn>2</mn></mrow></msub></math>
are equal as linear maps. Then we know if we bend all the input wires to
be output wires so that they are both states, that we still have equality.
Additionally,  because  of  completeness  for  states,  we  know  that  we  can
then rewrite one into the other. We can use this to show we can rewrite
<!-- l. 684 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>D</mi></mrow><mrow><mn>1</mn></mrow></msub></math>
into
                                                                     

                                                                     
<!-- l. 684 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>D</mi></mrow><mrow><mn>2</mn></mrow></msub></math>
diagrammatically:
</p>
<div class='center'>
<!-- l. 686 --><p class='noindent'>
</p><!-- l. 687 --><p class='noindent'><object data="svgs/phase-free-completeness-bend.svg" alt="diagram of phase-free-completeness-bend" class="svg-diagram"></object> </p></div>
<!-- l. 690 --><p class='indent'>   Here we marked with a dotted box the states that we rewrite into each
other using the completeness for phase-free states (Proposition <a href='#x6-96005r5'>4.3.5<!-- tex4ht:ref: prop:phase-free-completeness-states  --></a>)
                                                                   □
</p>
   </div>
<!-- l. 692 --><p class='indent'>   In this proof we implicitly rewrote the “state form” of
<!-- l. 692 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>D</mi></mrow><mrow><mn>1</mn></mrow></msub></math> and
<!-- l. 692 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>D</mi></mrow><mrow><mn>2</mn></mrow></msub></math> into
the Z-X normal form. If we take this normal form, and bend the input wires back
we get a diagram that looks like the following: </p><table class='equation'><tr><td>
<!-- l. 693 --><p class='indent'>
</p><!-- l. 693 --><object id='x6-96007r12' data="svgs/Z-X-nf-maps.svg" alt="diagram of Z-X-nf-maps" class="svg-diagram"></object></td><td class='eq-no'>(4.12)</td></tr></table>
<!-- l. 696 --><p class='indent'>   We then have a layer of X-spiders connected to both the inputs and outputs,
and these are connected via some internal Z-spiders. This is hence an alternative
normal form for phase-free diagrams.
</p>
   <h4 class='subsectionHead' id='xz-normal-forms-and-orthogonal-subspaces'><span class='titlemark'>4.3.2   </span> <a id='x6-970004.3.2'></a>X-Z normal forms and orthogonal subspaces</h4>
<!-- l. 698 --><p class='noindent'>All of the rules of the ZX calculus are colour-symmetric, so we could just as
well obtain a normal form for phase-free ZX-diagrams consisting only
of a row of internal X-spiders and a row of boundary Z-spiders. One
way to see this is to start yet again from the generalised parity form:
</p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 699 --><object data="svgs/phase-free-nf.svg" alt="diagram of phase-free-nf" class="svg-diagram"></object></td></tr></table>
<!-- l. 702 --><p class='indent'>   and set <!-- l. 702 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>n</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>
this time. We’ll obtain a colour-reversed, mirror image of the Z-X normal form
from (<a href='#x6-95001r7'>4.7<!-- tex4ht:ref: eq:z-x-nf  --></a>): </p><table class='equation'><tr><td>
<!-- l. 703 --><p class='indent'>
</p><!-- l. 703 --><object id='x6-97001r13' data="svgs/eq-x-z-nf-effect.svg" alt="diagram of eq:x-z-nf-effect" class="svg-diagram"></object></td><td class='eq-no'>(4.13)</td></tr></table>
<!-- l. 706 --><p class='indent'>   Just like before, we can describe this object by a set of bit-vectors
<!-- l. 706 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>{</mo><msub><mrow><mi>w</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>w</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>.
</p>
   <div class='newtheorem'>
<!-- l. 707 --><p class='noindent'><span class='head'>
<a id='x6-97002r7'></a>
<span class='cmbx-10x-x-109'>Definition 4.3.7.</span>  </span> The <span class='cmbx-10x-x-109'>X-Z normal form </span>of a phase-free ZX-diagram
consists of a row of internal X spiders connected to a row of Z spiders,
each connected to precisely 1 input. It can be described as a set of vectors
<!-- l. 708 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>{</mo><msub><mrow><mi>w</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>w</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>
over <!-- l. 708 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>,
where <!-- l. 708 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>w</mi></mrow><mrow><mi>p</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi>q</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>
if and only if the <!-- l. 708 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>p</mi></math>-th
internal X spider is connected to the <!-- l. 708 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>q</mi></math>-th
Z spider.
</p>
   </div>
                                                                     

                                                                     
<!-- l. 709 --><p class='indent'>    Suppose we plug some basis state
<!-- l. 710 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>v</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>v</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> into
an X-Z normal form. The result will be a scalar, which depends on the XORs of
some subsets of the input bits. For example: </p><table class='equation-star'><tr><td>
<!-- l. 711 --><object data="svgs/X-Z-nf-on-basis.svg" alt="diagram of X-Z-nf-on-basis" class="svg-diagram"></object></td></tr></table>
<!-- l. 714 --><p class='indent'>   If either of the scalar X spiders has a phase of
<!-- l. 714 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>, the whole
thing goes to zero. If both X spiders have a phase of 0, then the scalar equals a fixed
non-zero value <!-- l. 714 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>N</mi></math>.
In other words, the result is non-zero precisely when a collection of parities of
input variables all equal zero. Hence, we can write the linear map as follows:
</p><table class='equation-star'><tr><td>
<!-- l. 715 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mi>N</mi><mo class='MathClass-bin' stretchy='false'>⋅</mo><munder class='msub'><mrow><mo>∑</mo>
  </mrow><mrow><mi>b</mi><mo class='MathClass-rel' stretchy='false'>∈</mo><mi>S</mi></mrow></munder><mo class='MathClass-open' stretchy='false'>⟨</mo><mi>b</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mspace class='qquad' width='2em'></mspace><mstyle class='text'><mtext class='textrm' mathvariant='normal'>where</mtext></mstyle><mspace class='qquad' width='2em'></mspace><mi>S</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mrow><mo fence='true' form='prefix'>{</mo><mrow> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <msub><mrow><mi>v</mi></mrow><mrow><mn>1</mn></mrow></msub>  </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <msub><mrow><mi>v</mi></mrow><mrow><mn>2</mn></mrow></msub>  </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <msub><mrow><mi>v</mi></mrow><mrow><mn>3</mn></mrow></msub>  </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                                                    </mrow><mo fence='true' form='postfix'>)</mo></mrow> <mspace class='nbsp' width='0.33em'></mspace><mstyle mathsize='2.03em'><mrow><mo fence='true' form='prefix'>|</mo><mrow></mrow><mo fence='true' form='postfix'></mo></mrow></mstyle><mspace class='nbsp' width='0.33em'></mspace><mtable class='aligned'><mtr><mtd columnalign='right'><msub><mrow><mi>v</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>v</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>v</mi></mrow><mrow><mn>3</mn></mrow></msub></mtd><mtd columnalign='left'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mtd><mtd columnalign='right'></mtd>
</mtr><mtr><mtd columnalign='right'><msub><mrow><mi>v</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>v</mi></mrow><mrow><mn>3</mn></mrow></msub></mtd>        <mtd columnalign='left'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mtd>
     </mtr>                                                                                              </mtable></mrow><mo fence='true' form='postfix'>}</mo></mrow>
</mrow></math></td></tr></table>
<!-- l. 729 --><p class='indent'>   Recalling that in <!-- l. 729 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>,
<!-- l. 729 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-bin' stretchy='false'>⊕</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-bin' stretchy='false'>+</mo></mrow></math>
and the only possible coefficients in a linear equation are zero
and one, requiring a set of parities to all be zero is the same
thing as saying we have a solution to a system of <span class='cmbx-10x-x-109'>homogeneous</span>
<!-- l. 729 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math><span class='cmbx-10x-x-109'>-linear
equations</span>. The term <span class='cmti-10x-x-109'>homogeneous </span>just means all the righthand-sides are equal
to zero, and famously the set of solutions to a homogeneous system of equations
                                                                     

                                                                     
always forms a subspace. A handy perspective on a system of homogenous equations
is to think of them as a spanning set of vectors for the <span class='cmbx-10x-x-109'>orthogonal subspace</span>, or
“perp”, <!-- l. 730 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>S</mi></mrow><mrow><mo class='MathClass-rel' stretchy='false'>⊥</mo></mrow></msup></math>
of <!-- l. 730 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>,
defined this way: </p><table class='equation-star'><tr><td>
<!-- l. 731 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                   <msup><mrow><mi>S</mi></mrow><mrow><mo class='MathClass-rel' stretchy='false'>⊥</mo></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>{</mo><mi>w</mi><mspace class='thinspace' width='0.17em'></mspace><mo class='MathClass-rel' stretchy='false'>|</mo><mspace class='thinspace' width='0.17em'></mspace><mstyle class='text'><mtext class='textrm' mathvariant='normal'> for all </mtext></mstyle><mi>v</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>S</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mspace class='nbsp' width='0.33em'></mspace><msup><mrow><mi>w</mi></mrow><mrow><mi>T</mi> </mrow></msup><mi>v</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn><mo class='MathClass-close' stretchy='false'>}</mo><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td></tr></table>
<!-- l. 734 --><p class='indent'>   Then, note: </p><table class='equation-star'><tr><td>
<!-- l. 735 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
 <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <msub><mrow><mi>w</mi></mrow><mrow><mn>1</mn></mrow></msub>  </mtd><mtd class='array-td' columnalign='center'>  <msub><mrow><mi>w</mi></mrow><mrow><mn>2</mn></mrow></msub>  </mtd><mtd class='array-td' columnalign='center'>  <mo class='MathClass-rel' stretchy='false'>⋯</mo> </mtd><mtd class='array-td' columnalign='center'> <msub><mrow><mi>w</mi></mrow><mrow><mi>n</mi></mrow></msub> </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                  </mrow><mo fence='true' form='postfix'>)</mo></mrow> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <msub><mrow><mi>v</mi></mrow><mrow><mn>1</mn></mrow></msub>  </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <msub><mrow><mi>v</mi></mrow><mrow><mn>2</mn></mrow></msub>  </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'>   <mi>⋮</mi>  </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <msub><mrow><mi>v</mi></mrow><mrow>
<mi>n</mi></mrow></msub> </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                                  </mrow><mo fence='true' form='postfix'>)</mo></mrow> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn><mspace class='thickpace' width='0.28em'></mspace><mo class='MathClass-rel' stretchy='false'>⟺</mo><mspace class='thickpace' width='0.28em'></mspace><msub><mrow><mi>w</mi></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mi>v</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>⊕</mo><msub><mrow><mi>w</mi></mrow><mrow><mn>2</mn></mrow></msub><msub><mrow><mi>v</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>⊕</mo><mo>…</mo><mo class='MathClass-bin' stretchy='false'>⊕</mo><msub><mrow><mi>w</mi></mrow><mrow><mi>n</mi></mrow></msub><msub><mrow><mi>v</mi></mrow><mrow><mi>n</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td></tr></table>
<!-- l. 745 --><p class='indent'>   So,  giving  a  spanning  vector  for
<!-- l. 745 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>S</mi></mrow><mrow><mo class='MathClass-rel' stretchy='false'>⊥</mo></mrow></msup></math> is really just giving a
list of coefficients <!-- l. 745 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>w</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>w</mi></mrow><mrow><mi>n</mi></mrow></msub></mrow></math>
for a linear equation. Rewriting the example above in terms of
<!-- l. 746 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>S</mi></mrow><mrow><mo class='MathClass-rel' stretchy='false'>⊥</mo></mrow></msup></math>, we
have: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 747 --><object data="svgs/X-Z-nf-ex.svg" alt="diagram of X-Z-nf-ex" class="svg-diagram"></object></td></tr></table>
   <div class='newtheorem'>
<!-- l. 750 --><p class='noindent'><span class='head'>
<a id='x6-97003r9'></a>
<span class='cmbx-10x-x-109'>Exercise 4.9.</span>  </span>Show that this interpretation for X-Z normal forms is true in
general, namely that: </p><table class='equation'><tr><td>
<!-- l. 752 --><p class='indent'>
</p><!-- l. 752 --><object id='x6-97004r14' data="svgs/eq-cospan-form.svg" alt="diagram of eq:cospan-form" class="svg-diagram"></object></td><td class='eq-no'>(4.14)</td></tr></table>
   </div>
<!-- l. 755 --><p class='indent'>    As in the case for spanning sets of vectors for
<!-- l. 756 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>, there are many choices
of spanning set for <!-- l. 756 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>S</mi></mrow><mrow><mo class='MathClass-rel' stretchy='false'>⊥</mo></mrow></msup></math>,
which correspond to equivalent systems of linear equations. For example, adding
one of the equations in a system to another one doesn’t change the set of
solutions: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 757 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mtable class='aligned'><mtr><mtd columnalign='right'><msub><mrow><mi>v</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>v</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>v</mi></mrow><mrow><mn>3</mn></mrow></msub></mtd><mtd columnalign='left'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mtd><mtd columnalign='right'></mtd>
</mtr><mtr><mtd columnalign='right'><msub><mrow><mi>v</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>v</mi></mrow><mrow><mn>3</mn></mrow></msub></mtd>     <mtd columnalign='left'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mtd>
   </mtr>                                                                 </mtable><mspace class='qquad' width='2em'></mspace><mspace class='thickpace' width='0.28em'></mspace><mo class='MathClass-rel' stretchy='false'>⟺</mo><mspace class='thickpace' width='0.28em'></mspace><mspace class='qquad' width='2em'></mspace><mtable class='aligned'><mtr><mtd columnalign='right'><msub><mrow><mi>v</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>v</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>v</mi></mrow><mrow><mn>3</mn></mrow></msub></mtd><mtd columnalign='left'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mtd><mtd columnalign='right'></mtd>
</mtr><mtr><mtd columnalign='right'><msub><mrow><mi>v</mi></mrow><mrow><mn>2</mn></mrow></msub></mtd>                 <mtd columnalign='left'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mtd>
     </mtr>                                                                                              </mtable>
</mrow></math></td></tr></table>
<!-- l. 768 --><p class='indent'>   Such a move just corresponds to changing the spanning set for
<!-- l. 768 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>S</mi></mrow><mrow><mo class='MathClass-rel' stretchy='false'>⊥</mo></mrow></msup></math>:
</p><table class='equation-star'><tr><td>
<!-- l. 769 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow>
<mi>S</mi></mrow><mrow><mo class='MathClass-rel' stretchy='false'>⊥</mo></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mstyle class='text'><mtext class='textrm' mathvariant='normal'>Span</mtext></mstyle> <mrow><mo fence='true' form='prefix'>{</mo><mrow> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                           </mrow><mo fence='true' form='postfix'>)</mo></mrow><mo class='MathClass-punc' stretchy='false'>,</mo> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                           </mrow><mo fence='true' form='postfix'>)</mo></mrow> </mrow><mo fence='true' form='postfix'>}</mo></mrow><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mstyle class='text'><mtext class='textrm' mathvariant='normal'>Span</mtext></mstyle> <mrow><mo fence='true' form='prefix'>{</mo><mrow> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                           </mrow><mo fence='true' form='postfix'>)</mo></mrow><mo class='MathClass-punc' stretchy='false'>,</mo> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                           </mrow><mo fence='true' form='postfix'>)</mo></mrow> </mrow><mo fence='true' form='postfix'>}</mo></mrow>
</mrow></math></td></tr></table>
<!-- l. 788 --><p class='indent'>   which, like in the Z-X case, can be replicated graphically thanks to strong
complementarity:
</p>
<div class='center'>
<!-- l. 790 --><p class='noindent'>
</p><!-- l. 791 --><p class='noindent'><object data="svgs/X-Z-nf-ex1.svg" alt="diagram of X-Z-nf-ex1" class="svg-diagram"></object> </p></div>
   <div class='newtheorem'>
<!-- l. 794 --><p class='noindent'><span class='head'>
<a id='x6-97005r10'></a>
<span class='cmbx-10x-x-109'>Exercise 4.10.</span>  </span>Prove    the    two    equations    above    using    strong
complementarity.
</p>
   </div>
<!-- l. 796 --><p class='indent'>
</p>
   <div class='newtheorem'>
                                                                     

                                                                     
<!-- l. 797 --><p class='noindent'><span class='head'>
<a id='x6-97006r11'></a>
<span class='cmbx-10x-x-109'>Exercise 4.11.</span>  </span>Prove   the   general   case   of   changing   a   basis   for
<!-- l. 798 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>S</mi></mrow><mrow><mo class='MathClass-rel' stretchy='false'>⊥</mo></mrow></msup></math>
using strong complementarity. Use this to give an alternative proof of the
phase-free completeness Theorem <a href='#x6-96006r6'>4.3.6<!-- tex4ht:ref: thm:completeness-pp-zx  --></a> that relies on the X-Z normal form.
</p>
   </div>
<!-- l. 799 --><p class='indent'>    The fact that we ended up writing X-Z normal forms as bra’s rather than
ket’s is just an artifact of the convention we chose back in Section <a href='#reducing-a-zxdiagram-to-normal-form'>4.2.1<!-- tex4ht:ref: sec:phase-free-simp  --></a> to get Z
spiders on the left and X spiders on the right in our generalised parity form.
Everything in ZX is colour-symmetric, so we could have just as well done this the
other way around to obtain an X-Z normal form for states. Hence, we actually
get two equivalent ways to represent a state: the Z-X normal form and the X-Z
normal form: </p><table class='equation-star'><tr><td>
<!-- l. 801 --><object data="svgs/phase-free-state-sm.svg" alt="diagram of phase-free-state-sm" class="svg-diagram"></object></td></tr></table>
   <table class='equation-star'><tr><td>
<!-- l. 804 --><object data="svgs/eq-X-Z-nf-state.svg" alt="diagram of eq:X-Z-nf-state" class="svg-diagram"></object></td></tr></table>
                                                                     

                                                                     
<!-- l. 807 --><p class='indent'>   It is important to note that, most of the time, the number of vectors in these
two forms will be different. For example, the GHZ state, given by the subspace
<!-- l. 807 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>S</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mstyle class='text'><mtext class='textrm' mathvariant='normal'>Span</mtext></mstyle><mo class='MathClass-open' stretchy='false'>{</mo><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>}</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>{</mo><mo class='MathClass-open' stretchy='false'>(</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-punc' stretchy='false'>,</mo><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math> has
this Z-X normal form: </p><table class='equation-star'><tr><td>
<!-- l. 808 --><object data="svgs/ghz-span.svg" alt="diagram of ghz-span" class="svg-diagram"></object></td></tr></table>
<!-- l. 811 --><p class='indent'>   whereas <!-- l. 811 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>S</mi></mrow><mrow><mo class='MathClass-rel' stretchy='false'>⊥</mo></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mstyle class='text'><mtext class='textrm' mathvariant='normal'>Span</mtext></mstyle><mo class='MathClass-open' stretchy='false'>{</mo><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-punc' stretchy='false'>,</mo><mo class='MathClass-open' stretchy='false'>(</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>,
so it has this X-Z normal form: </p><table class='equation-star'><tr><td>
<!-- l. 812 --><object data="svgs/ghz-perp.svg" alt="diagram of ghz-perp" class="svg-diagram"></object></td></tr></table>
<!-- l. 815 --><p class='indent'>   But of course, these two are equal, thanks to the rules of the ZX
calculus:
</p>
<div class='center'>
<!-- l. 817 --><p class='noindent'>
</p><!-- l. 818 --><p class='noindent'><object data="svgs/ghz-2forms.svg" alt="diagram of ghz-2forms" class="svg-diagram"></object> </p></div>
<!-- l. 821 --><p class='indent'>   This relationship between the Z-X and X-Z normal form will come
in handy when we start thinking of quantum error correcting codes in
Chapter <a href='main_htmlch11.html#quantum-error-correction'>11<!-- tex4ht:ref: ch:qec  --></a>.
                                                                     

                                                                     
</p>
   <h4 class='subsectionHead' id='relating-parity-matrices-and-subspaces'><span class='titlemark'>4.3.3   </span> <a id='x6-980004.3.3'></a>Relating parity matrices and subspaces</h4>
<!-- l. 823 --><p class='noindent'>We’ve seen that phase-free unitaries can be represented efficiently as
<!-- l. 823 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>
linear maps and phase-free states can be represented as
<!-- l. 823 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math> linear
subspaces. So, a natural question is: what happens when we hit a phase-free state
with a phase-free unitary? You may not be particularly surprised to find out that
we can compute the subspace of the resulting state as the <span class='cmbx-10x-x-109'>direct image </span>of
the original subspace. That is, for a phase-free unitary with parity map
<!-- l. 824 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>p</mi></math>:
</p><table class='equation-star'><tr><td>
<!-- l. 825 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                           <mi>U</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mi>p</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>⟩</mo>
</mrow></math></td></tr></table>
<!-- l. 828 --><p class='indent'>   and a phase-free state corresponding to a subspace
<!-- l. 828 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>S</mi> <mo class='MathClass-rel' stretchy='false'>⊆</mo> <msubsup><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msubsup></mrow></math>:
</p><table class='equation-star'><tr><td>
<!-- l. 829 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                          <mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>∝</mo><munder class='msub'><mrow><mo>∑</mo>
   </mrow><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>∈</mo><mi>S</mi></mrow></munder><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo>
</mrow></math></td></tr></table>
<!-- l. 832 --><p class='indent'>   we have that <!-- l. 832 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
gets mapped to a new phase-free state described by the subspace
<!-- l. 832 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>p</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>S</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>:
</p><table class='equation'><tr><td>
                                                                     

                                                                     
<!-- l. 833 --><p class='indent'>
</p><!-- l. 833 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
           <mstyle class='label' id='x6-98001r15'></mstyle><!-- endlabel --><mi>U</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>∝</mo><munder class='msub'><mrow><mo>∑</mo>
   </mrow><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>∈</mo><mi>p</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>S</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></munder><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='qquad' width='2em'></mspace><mstyle class='text'><mtext class='textrm' mathvariant='normal'>where</mtext></mstyle><mspace class='qquad' width='2em'></mspace><mi>p</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>S</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>{</mo><mi>p</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo><mspace class='thinspace' width='0.17em'></mspace><mo class='MathClass-rel' stretchy='false'>|</mo><mspace class='thinspace' width='0.17em'></mspace><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>S</mi><mo class='MathClass-close' stretchy='false'>}</mo>
</mrow></math></td><td class='eq-no'>(4.15)</td></tr></table>
<!-- l. 838 --><p class='indent'>   In fact, this just follows from linearity, and the fact that
<!-- l. 838 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
(which is injective) never takes two bit strings to the same place: </p><table class='equation-star'><tr><td>
<!-- l. 839 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mi>U</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>∝</mo> <mi>U</mi><mo class='MathClass-open' stretchy='false'>(</mo><munder class='msub'><mrow><mo>∑</mo>
  </mrow><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>∈</mo><mi>S</mi></mrow></munder><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo><munder class='msub'><mrow><mo> ∑</mo>
   </mrow><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>∈</mo><mi>S</mi></mrow></munder><mi>U</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo><munder class='msub'><mrow><mo> ∑</mo>
   </mrow><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>∈</mo><mi>S</mi></mrow></munder><mo class='MathClass-rel' stretchy='false'>|</mo><mi>p</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo><munder class='msub'><mrow><mo> ∑</mo>
   </mrow><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>∈</mo><mi>p</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>S</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></munder><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo>
</mrow></math></td></tr></table>
   <div class='newtheorem'>
<!-- l. 846 --><p class='noindent'><span class='head'>
<a id='x6-98002r12'></a>
<span class='cmbx-10x-x-109'>Exercise 4.12.</span>  </span>Consider the following phase-free state, corresponding to the
subspace <!-- l. 847 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext class='textrm' mathvariant='normal'>Span</mtext></mstyle><mo class='MathClass-open' stretchy='false'>{</mo><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-punc' stretchy='false'>,</mo><mo class='MathClass-open' stretchy='false'>(</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>:
</p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 848 --><object data="svgs/z-x-nf-ex.svg" alt="diagram of z-x-nf-ex" class="svg-diagram"></object></td></tr></table>
<!-- l. 851 --><p class='indent'>   Compute <!-- l. 851 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>U</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
for the following phase-free unitaries: </p><table class='equation-star'><tr><td>
<!-- l. 852 --><object data="svgs/phase-free-U-exer.svg" alt="diagram of phase-free-U-exer" class="svg-diagram"></object></td></tr></table>
<!-- l. 855 --><p class='indent'>   using the ZX calculus.
</p>
   </div>
<!-- l. 856 --><p class='indent'>
</p>
   <h3 class='sectionHead' id='summary-what-to-remember2'><span class='titlemark'>4.4   </span> <a id='x6-990004.4'></a>Summary: What to remember</h3>
<!-- l. 859 --><p class='noindent'>
     </p><dl class='enumerate'><dt class='enumerate'>
  1.. </dt><dd class='enumerate'>
     <!-- l. 859 --><p class='noindent'>An <!-- l. 859 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit
     CNOT circuit corresponds to an <!-- l. 859 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>×</mo> <mi>n</mi></mrow></math>
     <span class='cmti-10x-x-109'>parity </span>matrix: a matrix over the field with 2 elements <!-- l. 859 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔽</mi><mn>2</mn> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>{</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>.
     </p></dd><dt class='enumerate'>
  2.. </dt><dd class='enumerate'>
     <!-- l. 860 --><p class='noindent'>A  CNOT  circuit  can  be  synthesised  from  a  parity  matrix  using
     Gaussian elimination.
                                                                     

                                                                     
     </p></dd><dt class='enumerate'>
  3.. </dt><dd class='enumerate'>
     <!-- l. 861 --><p class='noindent'>Phase-free ZX-diagrams are those diagrams where all the phases on
     the  spiders  are  zero.  They  have  a  restricted  rule  set  presented  in
     Figure <a href='#the-rules-of-the-phasefree-zx-calculus-the-spider-rules-sp-and-strong-complementarity-sc-note-the-righthandside-of-the-sc-rule-is-a-complete-bipartite-graph-of-m-z-spiders-and-n-x-spiders-with-a-normalisation-factor-mn-which-we-typically-drop-when-scalar-factors-are-irrelevant'>4.0<!-- tex4ht:ref: fig:pp-zx  --></a>.
     </p></dd><dt class='enumerate'>
  4.. </dt><dd class='enumerate'>
     <!-- l. 862 --><p class='noindent'>Phase-free ZX-diagrams can efficiently be rewritten to several different
     normal  forms:  generalised  parity  form,  Z-X  normal  form,  or  X-Z
     normal form.
     </p></dd><dt class='enumerate'>
  5.. </dt><dd class='enumerate'>
     <!-- l. 863 --><p class='noindent'>Unitary phase-free diagrams correspond to CNOT circuits.
     </p></dd><dt class='enumerate'>
  6.. </dt><dd class='enumerate'>
     <!-- l. 864 --><p class='noindent'>The row operations of Gaussian elimination correspond to doing strong
     complementarity in the ZX-calculus. </p></dd></dl>
<!-- l. 866 --><p class='noindent'>
</p>
   <h3 class='sectionHead' id='advanced-material2'><span class='titlemark'>4.5   </span> <a id='x6-1000004.5'></a>Advanced Material*</h3>
<!-- l. 867 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='better-cnot-circuit-extraction'><span class='titlemark'>4.5.1   </span> <a id='x6-1010004.5.1'></a>Better CNOT circuit extraction*</h4>
<!-- l. 868 --><p class='noindent'>In the discussion on universal gate sets in Section <a href='main_htmlch2.html#approximate-universality'>2.3.5<!-- tex4ht:ref: sec:universal-gates  --></a> we saw that the only
multi-qubit gate we need is the CNOT gate. In current physical devices
entangling gates are harder to implement than single-qubit gates, incurring more
noise and taking a longer time to execute. All this is to say that CNOT gates are
important, and we should think hard about how we can optimise their use as
much as possible. We saw in this chapter that we can always resynthesise a
CNOT circuit using Gaussian elimination. Whereas a starting CNOT circuit can
be as long as we want, with this resynthesis we can get a definite bound on how
long the circuits can get. Each row operation in the elimination procedure
gives us one CNOT gate. The question then is: how many row operations
do we need in the worst case? Let’s suppose we have some arbitrary
<!-- l. 870 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>×</mo> <mi>n</mi></mrow></math>
parity matrix. We will find an upper bound to how many row operations we need
                                                                     

                                                                     
to reduce it to the identity matrix. Let’s recall the distinct steps of Gaussian
elimination. For every column we need to make sure there is a 1 on the diagonal.
Then we eliminate all the elements on the column below the diagonal. Once we
have done this with every column, the matrix is in upper-triangular form. We
then need to do the same elimination, column-by-column, for all the elements
above the diagonal. The first column in the first stage then gives us at most
<!-- l. 872 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
row operations: 1 for correcting the diagonal, and
<!-- l. 872 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math> for
correcting all the elements below the diagonal. Similarly, the second column takes
<!-- l. 872 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math>
operations. Reducing the matrix to upper-triangular form hence takes
<!-- l. 872 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mrow><mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
   <!-- nolimits --></mrow><mrow><mi>k</mi><mo class='MathClass-rel' stretchy='false'>=</mo><mn>1</mn></mrow><mrow><mi>n</mi></mrow></msubsup><mi>k</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>n</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math>, where
this last <!-- l. 872 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math>
comes from the fact the final column will already have a
<!-- l. 872 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>
on the diagonal when we are doing elimination and the matrix is
full rank. To reduce the rest of the matrix we no longer have to
correct the diagonal, and hence fixing the last column only takes
<!-- l. 873 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math> operations, and the
second <!-- l. 873 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>2</mn></mrow></math>, and so on. This
hence occurs <!-- l. 873 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mrow><mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>k</mi><mo class='MathClass-rel' stretchy='false'>=</mo><mn>1</mn></mrow><mrow><mi>n</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msubsup><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo><mi>n</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn></mrow></math> operations.
This gives us a total of <!-- l. 874 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo><mi>n</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>n</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>n</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math>
operations exactly.
</p>
   <div class='newtheorem'>
<!-- l. 875 --><p class='noindent'><span class='head'>
<a id='x6-101001r1'></a>
<span class='cmbx-10x-x-109'>Proposition 4.5.1.</span>  </span>Every  CNOT  circuit  can  be  resynthesised  using  at
most
<!-- l. 876 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>n</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math>
CNOT gates.
</p>
   </div>
<!-- l. 877 --><p class='indent'>    Requiring just <!-- l. 878 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>n</mi></mrow><mrow><mn>2</mn></mrow></msup></math>
gates, even though naively these circuits could be arbitrarily long is already
pretty good. But is it also the best we can do? To determine this, we need to find
some way to figure out how many CNOT gates the worst-case parity matrices
require. We will do this by using a <span class='cmbx-10x-x-109'>counting argument</span>: we will count how
many different possible invertible parity matrices there are, and then argue
that therefore circuits must reach at least a certain length to represent
                                                                     

                                                                     
them all. For instance, if we have just a single CNOT gate acting on
<!-- l. 878 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math> qubits, then this can
represent at most <!-- l. 878 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
different parity matrices, as these are all the different ways
we can place the CNOT in the circuit. If instead we have
<!-- l. 878 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>d</mi></math> CNOT gates,
then there are <!-- l. 878 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi>d</mi></mrow></msup></math>
different ways to place them, so that this is the maximum number
of parity matrices we can represent. Since we actually care about
how many parity matrices we can write down with circuits <span class='cmti-10x-x-109'>up to</span>
<!-- l. 878 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>D</mi></math> CNOT
gates, we should also allow the identity operation as one possibility, so that there is
actually <!-- l. 878 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn></mrow></math>
ways to optionally place a CNOT gate. Now let’s count how many
invertible parity-matrices there are. Suppose we wish to build an invertible
<!-- l. 879 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>×</mo> <mi>n</mi></mrow></math>
parity matrix. We will do this column by column. The first column
we can pick arbitrarily, as long as it is not all zero. We hence have
<!-- l. 879 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math> options for that column.
Let’s call this vector <!-- l. 879 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>c</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub></math>.
Now for the second column we need to make sure that it is independent of the first column.
So it can’t be <!-- l. 879 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>c</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub></math>
or <!-- l. 879 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mn>0</mn></mrow><mo accent='true'>→</mo></mover></math>,
but otherwise we are free to choose it. So there are
<!-- l. 879 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>2</mn></mrow></math> options for
<!-- l. 879 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>c</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>2</mn></mrow></msub></math>. Now to choose
<!-- l. 879 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>c</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>3</mn></mrow></msub></math>, we need to make sure
it is independent of <!-- l. 879 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>c</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub></math>
and <!-- l. 879 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>c</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>2</mn></mrow></msub></math>.
The vector space spanned by these vectors has 4 elements, and hence there are
<!-- l. 879 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>4</mn></mrow></math>
options. At this point we can spot a pattern! The
<!-- l. 879 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>th column
has <!-- l. 879 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mn>2</mn></mrow><mrow><mi>k</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup></mrow></math>
options to choose from. The total number of invertible parity matrices is
then
                                                                     

                                                                     
<!-- tex4ht:inline --></p><!-- l. 881 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
  <mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mn>2</mn></mrow><mrow><mn>0</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mn>2</mn></mrow><mrow><mn>1</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>⋯</mo><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>≥</mo><mspace class='nbsp' width='0.33em'></mspace><mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>⋅</mo><mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>⋯</mo><mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi>n</mi></mrow></msup><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math>
<!-- l. 881 --><p class='nopar'> If we then claim that we can represent any invertible parity matrix by a CNOT circuit
of at most <!-- l. 882 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>d</mi></math>
CNOT gates, then we must at least have:
<!-- tex4ht:inline --></p><!-- l. 883 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow>
                       <mrow><mo fence='true' form='prefix'>(</mo><mrow><mi>n</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn></mrow><mo fence='true' form='postfix'>)</mo></mrow></mrow><mrow><mi>d</mi></mrow></msup><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>≥</mo><mspace class='nbsp' width='0.33em'></mspace><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math>
<!-- l. 883 --><p class='nopar'> If this wasn’t the case, then there would be no way for use to write down all the
different parity matrices, since we just don’t have enough space in our circuit for
that many unique options. Let’s take the logarithm in this equation, and
rearrange the terms:
<!-- tex4ht:inline --></p><!-- l. 885 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                   <mi>d</mi><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>≥</mo><mspace class='nbsp' width='0.33em'></mspace>  <mfrac><mrow><mi>n</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow> 
<mrow><mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --><mi>n</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn></mrow></mfrac><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>O</mi> <mrow><mo fence='true' form='prefix'>(</mo><mrow>  <mfrac><mrow><msup><mrow><mi>n</mi></mrow><mrow><mn>2</mn></mrow></msup></mrow>
<mrow> <mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --><mi>n</mi></mrow></mfrac> </mrow><mo fence='true' form='postfix'>)</mo></mrow><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math>
<!-- l. 885 --><p class='nopar'> We see then that just to be able to represent all the parity
matrices, we need circuits that have length at least of order
<!-- l. 886 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>n</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-bin' stretchy='false'>∕</mo><mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --><mi>n</mi></mrow></math>, and
hence there will be parity matrices that require at least that many CNOT
gates to write down. Our naive Gaussian elimination strategy gave us
<!-- l. 887 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>n</mi></mrow><mrow><mn>2</mn></mrow></msup></math>
                                                                     

                                                                     
CNOT operations, and we see that this lower bound is
<!-- l. 887 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>n</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-bin' stretchy='false'>∕</mo><mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --><mi>n</mi></mrow></math>. It
would certainly be nice if we could do some smarter elimination, just to squeeze
out that last bit of logarithmic factor. And we can! The idea is that we don’t
want to eliminate the matrix just element per element, but instead we divide
each row up into small ‘chunks’. We then first try to eliminate whole chunks at a
time. For instance, suppose we pick our chunk size to be 3, then we would first
consider the first 3 columns at a whole, and we would look for any duplicate 3-bit
strings in these columns. If we find any, then we apply a row operation to
get rid of this whole bit string. Once we have done that, we proceed to
eliminate these 3 columns as usual, and then go on to the second set
of 3 columns. The benefit of doing this, is that when the chunk size is
<!-- l. 889 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>c</mi></math>, there
are only <!-- l. 889 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mn>2</mn></mrow><mrow><mi>c</mi></mrow></msup></math>
different types of sub-rows, meaning that of all the
<!-- l. 889 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math> elements in a row,
at most <!-- l. 889 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mn>2</mn></mrow><mrow><mi>c</mi></mrow></msup></math> can be
non-zero after the chunk elimination, and hence the further standard elimination step only requires
<!-- l. 889 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>c</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>c</mi></mrow></msup></mrow></math> row operations
to clear out the <!-- l. 889 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>c</mi></math>
columns. The cost of first doing the chunk elimination is
<!-- l. 889 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
(ignoring some details here regarding chunks being counted
twice across the diagonal), and both these steps need to happen
<!-- l. 889 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><mi>c</mi></mrow></math> number of times
(assuming <!-- l. 889 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>c</mi></math>
divides <!-- l. 889 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>),
once for each of the chunked columns. We also have a cost of
<!-- l. 889 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math> total
to insert the right diagonal elements. The total cost is then
<!-- tex4ht:inline --></p><!-- l. 890 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                   <mo class='MathClass-open' stretchy='false'>(</mo><mi>c</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>c</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo><mfrac><mrow><mi>n</mi></mrow>
<mrow><mi>c</mi></mrow></mfrac> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>n</mi><mfrac><mrow><mi>n</mi></mrow>
<mrow><mi>c</mi></mrow></mfrac> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>n</mi><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mfrac><mrow><msup><mrow><mi>n</mi></mrow><mrow><mn>2</mn></mrow></msup></mrow> 
 <mrow><mi>c</mi></mrow></mfrac>  <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>n</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>c</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>n</mi><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math>
<!-- l. 890 --><p class='nopar'> Setting <!-- l. 891 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>c</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>α</mi><mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --><mi>n</mi></mrow></math> for some
                                                                     

                                                                     
<!-- l. 891 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>α</mi> <mo class='MathClass-rel' stretchy='false'>&lt;</mo> <mn>1</mn></mrow></math> then simplifies this
cost to <!-- l. 891 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo>  <mfrac><mrow><msup><mrow><mi>n</mi></mrow><mrow><mn>2</mn></mrow></msup></mrow>
<mrow> <mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --><mi>n</mi></mrow></mfrac><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>. Note that
<!-- l. 891 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>α</mi> <mo class='MathClass-rel' stretchy='false'>&lt;</mo> <mn>1</mn></mrow></math> is needed for the
<!-- l. 891 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>c</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>n</mi></mrow><mrow><mn>1</mn><mo class='MathClass-bin' stretchy='false'>+</mo><mi>α</mi></mrow></msup></mrow></math> term to be asymptotically
smaller then <!-- l. 891 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>n</mi></mrow><mrow><mn>2</mn></mrow></msup> <mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --><mi>n</mi></mrow></math>.
This hence gives us an algorithm with an asymptotically optimal CNOT
count!
</p>
   <div class='newtheorem'>
<!-- l. 893 --><p class='noindent'><span class='head'>
<a id='x6-101002r2'></a>
<span class='cmbx-10x-x-109'>Theorem 4.5.2.</span>  </span>Every CNOT circuit can be resynthesised using at most
<!-- l. 894 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>n</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-bin' stretchy='false'>∕</mo><mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --><mi>n</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
CNOT gates.
</p>
   </div>
<!-- l. 895 --><p class='indent'>    This algorithm isn’t just theoretically interesting: in practice it already gives
better results than naive Gaussian elimination for very small number of
qubits.
</p>
   <h3 class='sectionHead' id='references-and-further-reading2'><span class='titlemark'>4.6   </span> <a id='x6-1020004.6'></a>References and further reading</h3>
<!-- l. 898 --><p class='noindent'><span class='paragraphHead' id='cnot-circuit-synthesis1'><a id='x6-103000'></a><span class='cmbx-10x-x-109'>CNOT circuit synthesis</span></span>
   An efficient CNOT circuit synthesis procedure based on Gaussian
elimination was proposed by [<a href='main_htmlli2.html#Xalber2001quantum'>7</a>]. This was later refined by Markov, Patel, and
Hayes in [<a href='main_htmlli2.html#Xmarkov2008optimal'>169</a>]. This algorithm is the one described in Section <a href='#better-cnot-circuit-extraction'>4.5.1<!-- tex4ht:ref: sec:better-CNOT-extraction  --></a>.
This algorithm remains one of the best for unconstrained architectures,
obtaining an asymptotically optimal gate count. Recently, there has also been
work on synthesising CNOT circuits for architectures with topological
constraints, such as superconducting devices. In these approaches, a graph is
provided whose nodes are qubits and edges are places where CNOTs may be
placed. This can be accomplished by constraining which row operations
are allowed in Gaussian elimination using <span class='cmbx-10x-x-109'>Steiner trees</span>, a technique
proposed simultaneously by [<a href='main_htmlli2.html#XKissingerCNOT2019'>143</a>] and [<a href='main_htmlli2.html#Xnash2019quantum'>186</a>]. A different technique, based on
<!-- l. 900 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>-linear
decoding, was given by [<a href='main_htmlli2.html#Xdebrugiere2020quantum'>78</a>].
                                                                     

                                                                     
</p>
<!-- l. 901 --><p class='noindent'><span class='paragraphHead' id='interacting-bialgebras'><a id='x6-104000'></a><span class='cmbx-10x-x-109'>Interacting bialgebras</span></span>
   The phase-free ZX calculus has also been called <span class='cmbx-10x-x-109'>IB</span>, for <span class='cmbx-10x-x-109'>interacting
bialgebras</span>, in the categorical algebra literature [<a href='main_htmlli2.html#Xbonchi2014interacting'>31</a>]. This is because this set of
generating maps: </p><table class='equation'><tr><td>
<!-- l. 903 --><p class='indent'>
</p><!-- l. 903 --><object id='x6-104001r16' data="svgs/eq-bialg-gens.svg" alt="diagram of eq:bialg-gens" class="svg-diagram"></object></td><td class='eq-no'>(4.16)</td></tr></table>
<!-- l. 906 --><p class='indent'>   as well as this set: </p><table class='equation'><tr><td>
<!-- l. 907 --><p class='indent'>
</p><!-- l. 907 --><object id='x6-104002r17' data="svgs/eq-bialg-gens2.svg" alt="diagram of eq:bialg-gens2" class="svg-diagram"></object></td><td class='eq-no'>(4.17)</td></tr></table>
<!-- l. 910 --><p class='indent'>   each form an algebraic structure called a <span class='cmbx-10x-x-109'>bialgebra</span>. Bialgebras, and the
more specific structure of Hopf algebras, have been extensively studied in
representation theory, as they generalise group algebras. This system is called
<span class='cmti-10x-x-109'>interacting </span>bialgebras because the two bialgebras (<a href='#x6-104001r16'>4.16<!-- tex4ht:ref: eq:bialg-gens  --></a>) and (<a href='#x6-104002r17'>4.17<!-- tex4ht:ref: eq:bialg-gens2  --></a>) interact with
each other, via the spider fusion laws. In algebraic terms, this means
the four Z generators and the four X generators each form <span class='cmbx-10x-x-109'>Frobenius
algebras</span>.
</p>
<!-- l. 912 --><p class='noindent'><span class='paragraphHead' id='normal-forms'><a id='x6-105000'></a><span class='cmbx-10x-x-109'>Normal forms</span></span>
   In [<a href='main_htmlli2.html#Xbonchi2014interacting'>31</a>], the authors showed that any diagram built out the generators
(<a href='#x6-104001r16'>4.16<!-- tex4ht:ref: eq:bialg-gens  --></a>) and (<a href='#x6-104002r17'>4.17<!-- tex4ht:ref: eq:bialg-gens2  --></a>), i.e. any phase-free ZX diagram, can be put into
one of two normal forms, which they called the <span class='cmti-10x-x-109'>span </span>and <span class='cmti-10x-x-109'>cospan</span>
form. These are closely related to the Z-X and X-Z normal forms we
                                                                     

                                                                     
used in this chapter. They also showed that the resulting maps from
<!-- l. 913 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>m</mi></math> wires to
<!-- l. 913 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math> wires are in 1-to-1
correspondence with <!-- l. 913 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math><span class='cmbx-10x-x-109'>-linear
relations</span>, i.e. subspaces <!-- l. 913 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>S</mi> <mo class='MathClass-rel' stretchy='false'>⊆</mo> <msubsup><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>m</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mi>n</mi></mrow></msubsup></mrow></math>.
Up to bending wires, this is what we showed in Section <a href='#phasefree-states-and-f-linear-subspaces'>4.3<!-- tex4ht:ref: sec:phase-free-subspace  --></a>.
</p>
<!-- l. 914 --><p class='noindent'><span class='paragraphHead' id='props'><a id='x6-106000'></a><span class='cmbx-10x-x-109'>PROPs</span></span>
   This work lives in the broader field of studying <span class='cmbx-10x-x-109'>PROPs</span>, or PROduct
categories with Permutations, a categorical formulation of algebraic structures
whose generators can have many inputs or outputs. PROPs were first formulated
by Mac Lane [<a href='main_htmlli2.html#Xmaclane1965categorical'>166</a>] and an important technique for composing PROPs together
was developed by Lack [<a href='main_htmlli2.html#XLack'>160</a>]. The techniques used to get normal forms in [<a href='main_htmlli2.html#Xbonchi2014interacting'>31</a>]
used abstract arguments based on composing PROPs, and did not directly show
how to compute normal forms by applying graphical rules. The rewriting strategy
used for obtaining normal forms in Section <a href='#reducing-a-zxdiagram-to-normal-form'>4.2.1<!-- tex4ht:ref: sec:phase-free-simp  --></a> is new to this book.
Similar strategies have been known, but not published, for a while. For
example, the graphical proof assistant Quantomatic [<a href='main_htmlli2.html#Xkissinger2015quantomatic'>151</a>] and the ZX library
PyZX [<a href='main_htmlli2.html#Xpyzx'>146</a>] both have implementations of such strategies, with the former
implementation dating back to the mid-2010s.    </p><!-- l. 11 --><div class='crosslinks'><p class='noindent'>[<a href='main_htmlch5.html'>next</a>] [<a href='main_htmlch3.html'>prev</a>] [<a href='main_htmlch3.html#tailmain_htmlch3.html'>prev-tail</a>] [<a href='main_htmlch4.html'>front</a>]
[<a href='main_html.html#main_htmlch4.html'>up</a>] </p></div>
<!-- l. 11 --><p class='indent'>   <a id='tailmain_htmlch4.html'></a></p> 
<script type="text/javascript" src="proof_collapse.js"></script> 
<script type="text/javascript" src="navigation_menu.js"></script> </body> 
</html>