<!DOCTYPE html> 
<html lang='en-US' xml:lang='en-US'> 
<head><title>10 Clifford+T</title> 
<meta charset='utf-8' /> 
<meta content='TeX4ht (https://tug.org/tex4ht/)' name='generator' /> 
<meta content='width=device-width,initial-scale=1' name='viewport' /> 
<link href='main_html.css' rel='stylesheet' type='text/css' /> 
<meta content='main_html.tex' name='src' /> 
 <script async='async' id='MathJax-script' src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/mml-chtml.js' type='text/javascript'></script>  
</head><body>
   <!-- l. 7 --><div class='crosslinks'><p class='noindent'>[<a href='main_htmlch11.html'>next</a>] [<a href='main_htmlch9.html'>prev</a>] [<a href='main_htmlch9.html#tailmain_htmlch9.html'>prev-tail</a>] [<a href='#tailmain_htmlch10.html'>tail</a>] [<a href='main_html.html#main_htmlch10.html'>up</a>] </p></div>
   <h2 class='chapterHead' id='cliffordt'><span class='titlemark'>Chapter 10</span><br /><a id='x12-24000010'></a>Clifford+T</h2>
<!-- l. 8 --><p class='noindent'>In the previous chapters, we have often seen a dichotomy between two
classes of quantum computations. On the one hand, we have Clifford
computations, which have a great deal of structure we can exploit to
efficiently solve problems like circuit synthesis, deciding equality of
computations, and strong classical simulation. On the other hand, we have
looked at universal quantum computation, typically arising from adding
<!-- l. 8 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math> gates for
arbitrary angles <!-- l. 8 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>α</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mo class='MathClass-open' stretchy='false'>[</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>2</mn><mi>π</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>.
While Clifford angles, i.e. integer multiples of
<!-- l. 8 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>,
satisfy many identities, we have so far treated non-Clifford angles as “black
boxes”, which don’t seem to satisfy <span class='cmti-10x-x-109'>any </span>extra rules, except for trivial ones
coming from the spider fusion rule like
</p>
<div class='center'>
<!-- l. 10 --><p class='noindent'>
</p><!-- l. 11 --><p class='noindent'><object data="svgs/gate-fusion.svg" alt="diagram of gate-fusion" class="svg-diagram"></object> </p></div>
<!-- l. 14 --><p class='indent'>   and variations thereof. It turns out that for generic angles, this is pretty much
all we can do. In fact, as we’ll explain in the References, there is a way to make
this statement precise. However, for <span class='cmbx-10x-x-109'>dyadic angles</span>, i.e. angles of the form
<!-- l. 15 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mfrac><mrow><mi>π</mi></mrow>
<mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>k</mi></mrow></msup></mrow></mfrac></mrow></math> for some
integer <!-- l. 15 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>,
there is a great deal more structure at play. As we’ll see in this chapter, we can
take advantage of this dyadic structure in a variety of ways. First, we will
see that it simplifies the problem of synthesising generic unitary maps
using just Clifford gates and the first non-Clifford dyadic phase gate
<!-- l. 16 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>T</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>Z</mi><mo class='MathClass-open' stretchy='false'>[</mo><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> <mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>. We
can characterise the set of unitary matrices that we can synthesise exactly using
Clifford+T gates as those whose entries are all within a certain subset, called
<!-- l. 16 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>, of the
complex numbers. Using some special properties of this set, and a little (light)
ring theory, we can figure out precisely how many gates we need to synthesise
such a matrix exactly and do this synthesis efficiently. Note, here “efficient”
means efficient in the size of the matrix, not the number of qubits. For generic
unitaries, this is the best we can hope for. We’ll also see that for any tolerance
<!-- l. 16 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝜖</mi> <mo class='MathClass-rel' stretchy='false'>&gt;</mo> <mn>0</mn></mrow></math>,
we can approximate any unitary matrix within
<!-- l. 16 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>𝜖</mi></math> with a
<!-- l. 16 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>-matrix,
                                                                     

                                                                     
which we can in turn synthesise exactly using Clifford+T gates. Second, we
will see that for dyadic angles, new rules start to hold that wouldn’t for
generic angles. In particular, certain complex configurations of phase
gadgets can all cancel each other out in ways that are not implied by
the gadget-fusion law we met back in Chapter <a href='main_htmlch7.html#universal-circuits'>7<!-- tex4ht:ref: ch:universal  --></a>. These so-called
<span class='cmbx-10x-x-109'>spider nest identities </span>come from a particular interaction between
the parity (i.e. mod-2) structure of the phase gadget itself and the
mod-<!-- l. 17 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mn>2</mn></mrow><mrow><mi>k</mi></mrow></msup></math>
structure of its angle. Similar to the representation from Chapter <a href='main_htmlch7.html#universal-circuits'>7<!-- tex4ht:ref: ch:universal  --></a> of
CNOT+phase circuits, we can represent phase gadgets as collections of binary
vectors representing parities of qubits where phases get applied, and as before
we can stick these vectors together into a matrix. We introduce a new
<span class='cmbx-10x-x-109'>Scalable ZX notation </span>so that we can directly represent these matrices
in an efficient way in our diagrams. Using these matrices representing
collections of phase gadgets we can also recognise which configurations of
<!-- l. 19 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></math> phase
gadgets will cancel out. Namely, it will be those whose “gadget matrix”
satisfies a condition called <span class='cmbx-10x-x-109'>strongly 3-even</span>. In this chapter, we will work
out some properties of strongly 3-even matrices and a closely related
<!-- l. 19 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>-linear
structure called <span class='cmbx-10x-x-109'>Reed-Muller codes</span>. Finally, we will put the pieces together by
classifying all the spider nest identities and explaining how they can be used for
T count optimisation. Clifford+T circuits are especially important for
fault-tolerant quantum computation, so in this chapter we will also be (secretly)
laying the groundwork for Chapter <a href='main_htmlch11.html#quantum-error-correction'>11<!-- tex4ht:ref: ch:qec  --></a>, where we explain techniques for
implementing universal quantum computation within a quantum error
correcting code. In particular, in Section <a href='#catalysis'>10.5<!-- tex4ht:ref: sec:catalysis  --></a> we will see how we can
relate circuits over different types of gate sets together using a technique
called <span class='cmbx-10x-x-109'>catalysis </span>that allows you to perform certain ‘hard’ operations in
an easy way as long as you have a suitable catalyst state lying around.
Together with the classification of spider nest identities this will prove very
handy for when we want to implement non-Clifford gates in fault-tolerant
architectures.
</p>
   <h3 class='sectionHead' id='universality-of-cliffordt-circuits'><span class='titlemark'>10.1   </span> <a id='x12-24100010.1'></a>Universality of Clifford+T circuits</h3>
<!-- l. 22 --><p class='noindent'>Back in Chapter <a href='main_htmlch2.html#the-quantum-circuit-model'>2<!-- tex4ht:ref: ch:circuit  --></a>, we noted that CNOT gates plus arbitrary
single-qubit unitaries are universal for quantum computation, in
the sense that they can be used to build arbitrary unitaries over
<!-- l. 22 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
qubits. In this section, we will show that, in fact Clifford+T circuits are
approximately universal, in the sense that they can get arbitrarily close to any
<!-- l. 22 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit
                                                                     

                                                                     
unitary. One way to show this, is to show how for any single-qubit unitary
<!-- l. 23 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math> there exists some
<!-- l. 23 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>U</mi></mrow><mrow><mi>′</mi></mrow></msup></math> arbitrary close
to <!-- l. 23 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math> expressed
totally in terms of <!-- l. 23 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math>
and <!-- l. 23 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates. There are several ways to prove this. The “classic” way is to show that
<!-- l. 23 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi mathvariant='italic'>HT</mi></mrow></math>
corresponds to a rotation about some axis of the Bloch sphere by an irrational multiple
of <!-- l. 23 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>. Then,
by raising <!-- l. 23 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> </mrow></math>
to larger and larger powers, we will eventually land close to <span class='cmti-10x-x-109'>any </span>possible rotation
around that axis. We can do the same around some other axis, e.g. with
<!-- l. 23 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>V</mi> </mrow><mrow><mi>′</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi mathvariant='italic'>TH</mi></mrow></math>, to
obtain a pair of rotation gates that suffice to build any single-qubit unitary. It
takes quite some work to spell out the details of this argument, and this has been
done in several standard textbooks on quantum computing. There are also many
variations one can use to obtain more or less efficient decompositions of
single-qubit unitaries. We’ll give some pointers to where you can find all the gory
details of this approach and variations at end of this chapter. However, in this
section, we will start with a totally different approach to synthesis of unitaries
in Clifford+T, which is based on number theory. This approach starts
from the realisation that the numbers appearing in a unitary matrix
built from CNOT, H, and T are not just any old complex numbers, but
are actually quite special. First, lets have a look at the matrices again:
</p><table class='equation-star'><tr><td>
<!-- l. 26 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mstyle class='text'><mtext>CNOT</mtext></mstyle> <mo class='MathClass-rel' stretchy='false'>=</mo>  <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn></mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                               </mrow><mo fence='true' form='postfix'>)</mo></mrow><mspace class='qquad' width='2em'></mspace><mi>H</mi> <mo class='MathClass-rel' stretchy='false'>=</mo>  <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'>   <mn>1</mn>   </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                     </mrow><mo fence='true' form='postfix'>)</mo></mrow><mspace class='qquad' width='2em'></mspace><mi>T</mi> <mo class='MathClass-rel' stretchy='false'>=</mo>  <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'>    <mn>0</mn>    </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iπ</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>4</mn> </mrow> </msup></mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                                          </mrow><mo fence='true' form='postfix'>)</mo></mrow>
</mrow></math></td></tr></table>
<!-- l. 47 --><p class='indent'>   Clearly any <!-- l. 47 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
that we can construct from these gates will have as its entries sums and products of integers,
<!-- l. 47 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mfrac><mrow><mn>1</mn></mrow>
<mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac></mrow></math>, and the complex
phase <!-- l. 47 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ω</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iπ</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>4</mn></mrow></msup></mrow></math>. If we think
about where <!-- l. 47 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ω</mi></math>
                                                                     

                                                                     
lies on the complex plane: </p><table class='equation'><tr><td>
<!-- l. 48 --><p class='indent'>
</p><!-- l. 48 --><object id='x12-241001r1' data="svgs/eq-complex-plane-omega.svg" alt="diagram of eq:complex-plane-omega" class="svg-diagram"></object></td><td class='eq-no'>(10.1)</td></tr></table>
<!-- l. 51 --><p class='indent'>   we see that <!-- l. 51 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ω</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mfrac><mrow><mn>1</mn><mo class='MathClass-bin' stretchy='false'>+</mo><mi>i</mi></mrow> 
<mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac> </mrow></math>
and <!-- l. 51 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='false' class='mml-overline'><mrow><mi>ω</mi></mrow><mo accent='true'>¯</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-bin' stretchy='false'>−</mo><msup><mrow><mi>ω</mi></mrow><mrow><mn>3</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mfrac><mrow><mn>1</mn><mo class='MathClass-bin' stretchy='false'>−</mo><mi>i</mi></mrow> 
<mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac> </mrow></math>.
Using these facts, it’s not hard to see that we can already build
<!-- l. 51 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mfrac><mrow><mn>1</mn></mrow>
<mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac></mrow></math> using just
integers, <!-- l. 51 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mfrac><mrow><mn>1</mn></mrow>
<mrow><mn>2</mn></mrow></mfrac></math>,
and <!-- l. 51 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ω</mi></math>:
</p><table class='equation-star'><tr><td>
<!-- l. 52 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                           <mfrac><mrow><mn>1</mn></mrow>
<mrow><mn>2</mn></mrow></mfrac><mo class='MathClass-open' stretchy='false'>(</mo><mi>ω</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>ω</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo>  <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac>
</mrow></math></td></tr></table>
<!-- l. 55 --><p class='indent'>   If we look at just the numbers we can build with integers and
<!-- l. 55 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mfrac><mrow><mn>1</mn></mrow>
<mrow><mn>2</mn></mrow></mfrac></math>, this
consists of precisely the rational numbers whose denominator is a power of two.
We give this set of numbers a special name.
</p>
   <div class='newtheorem'>
<!-- l. 56 --><p class='noindent'><span class='head'>
<a id='x12-241002r1'></a>
                                                                     

                                                                     
<span class='cmbx-10x-x-109'>Definition 10.1.1.</span>  </span>The <span class='cmbx-10x-x-109'>dyadic rational numbers </span><!-- l. 57 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>𝔻</mi></math>
consist of all rational numbers of the form <!-- l. 57 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mfrac><mrow><mi>z</mi></mrow>
<mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>k</mi></mrow></msup></mrow></mfrac></mrow></math>
for <!-- l. 57 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>z</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi></mrow></math>.
</p>
   </div>
<!-- l. 58 --><p class='indent'>    Clearly <!-- l. 59 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>𝔻</mi></mrow></math>,
and for <!-- l. 59 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>q</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>r</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>𝔻</mi></mrow></math>,
<!-- l. 59 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>q</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>q</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>r</mi></mrow></math> and
<!-- l. 59 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>qr</mi></mrow></math> are also
in <!-- l. 59 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>𝔻</mi></math>.
Hence, <!-- l. 59 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>𝔻</mi></math>
forms a ring. However, unlike the full set of rational numbers, not every
<!-- l. 59 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>q</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>𝔻</mi></mrow></math> has a multiplicative
inverse in <!-- l. 59 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>𝔻</mi></math>,
so it is not a field. It turns out that, for the purposes of circuit synthesis, this is
not a bug, but a feature, since rings can have very interesting properties owing to
the fact that we cannot arbitrarily divide numbers by each other. To discuss the
single-qubit synthesis algorithm, there are two relevant rings based on
<!-- l. 60 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>𝔻</mi></math> we need to study.
The first is <!-- l. 60 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>, the
ring obtained by allowing arbitrary sums and products of dyadic rationals with the complex
number <!-- l. 60 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ω</mi></math>. The
second is <!-- l. 60 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo> <mo class='MathClass-rel' stretchy='false'>⊊</mo> <mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>,
which is restricted just to integer multiples of powers of
<!-- l. 60 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ω</mi></math>. Such
rings are called <span class='cmbx-10x-x-109'>ring extensions</span>, i.e. rings obtained by adding one or more
elements outside of the original ring and closing under sums and products. Since
<!-- l. 61 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>ω</mi></mrow><mrow><mn>4</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iπ</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></math>, we can concretely
represent elements of <!-- l. 61 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
and elements of <!-- l. 61 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
using quadruples of numbers taken respectively from
<!-- l. 61 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ℤ</mi></math> or
<!-- l. 61 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>𝔻</mi></math>:
                                                                     

                                                                     
</p><!-- tex4ht:inline --><!-- l. 65 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mtable class='align-star' columnalign='left' displaystyle='true'>
               <mtr><mtd class='align-odd' columnalign='right'><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mtd>               <mtd class='align-even'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>{</mo><mspace class='thinspace' width='0.17em'></mspace><mi>a</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi mathvariant='italic'>bω</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>c</mi><msup><mrow><mi>ω</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>d</mi><msup><mrow><mi>ω</mi></mrow><mrow><mn>3</mn></mrow></msup><mspace class='thinspace' width='0.17em'></mspace><mo class='MathClass-rel' stretchy='false'>|</mo><mspace class='thinspace' width='0.17em'></mspace><mi>a</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>b</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>c</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>d</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi><mspace class='thinspace' width='0.17em'></mspace><mo class='MathClass-close' stretchy='false'>}</mo><mspace width='2em'></mspace></mtd>               <mtd class='align-label' columnalign='right'></mtd>               <mtd class='align-label'>
               <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'><mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mtd>               <mtd class='align-even'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>{</mo><mspace class='thinspace' width='0.17em'></mspace><mi>a</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi mathvariant='italic'>bω</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>c</mi><msup><mrow><mi>ω</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>d</mi><msup><mrow><mi>ω</mi></mrow><mrow><mn>3</mn></mrow></msup><mspace class='thinspace' width='0.17em'></mspace><mo class='MathClass-rel' stretchy='false'>|</mo><mspace class='thinspace' width='0.17em'></mspace><mi>a</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>b</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>c</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>d</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>𝔻</mi><mspace class='thinspace' width='0.17em'></mspace><mo class='MathClass-close' stretchy='false'>}</mo><mspace width='2em'></mspace></mtd>               <mtd class='align-label' columnalign='right'></mtd>               <mtd class='align-label'>
   <mspace width='2em'></mspace></mtd></mtr></mtable></math>
   <div class='newtheorem'>
<!-- l. 66 --><p class='noindent'><span class='head'>
<a id='x12-241003r1'></a>
<span class='cmbx-10x-x-109'>Exercise 10.1.</span>  </span>Define ring addition and multiplication for <!-- l. 67 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
and <!-- l. 67 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
as operations acting on quadruples <!-- l. 67 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>a</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>b</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>c</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>d</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
of numbers respectively taken from <!-- l. 67 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ℤ</mi></math>
and <!-- l. 67 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>𝔻</mi></math>.
</p>
   </div>
<!-- l. 68 --><p class='indent'>    Clearly any unitary matrix built out of CNOT, H, and T will consist of elements
from <!-- l. 69 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>.
Perhaps surprisingly, the converse is also true: any unitary matrix whose elements
are in <!-- l. 69 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
can be constructed <span class='cmti-10x-x-109'>exactly </span>as a composition of CNOT, H, and T gates. We will
show this by giving a concrete algorithm for synthesising unitaries over
<!-- l. 69 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math> in
the following sections, then conclude with some remarks on how this lifts
to an approximate synthesis algorithm for unitaries over all complex
numbers.
</p>
   <h4 class='subsectionHead' id='exact-synthesis-of-onequbit-gates'><span class='titlemark'>10.1.1   </span> <a id='x12-24200010.1.1'></a>Exact synthesis of one-qubit gates</h4>
<!-- l. 71 --><p class='noindent'>We’ll begin by considering the simplest non-trivial synthesis problem
we can have: namely preparation of an arbitrary single-qubit state
<!-- l. 71 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>. That is, we want to
find a sequence of <!-- l. 71 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math>
and <!-- l. 71 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> to
transform <!-- l. 71 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> into
<!-- l. 71 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>. Equivalently, we can
find a sequence of <!-- l. 71 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math>
and <!-- l. 71 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
transforming <!-- l. 71 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
into <!-- l. 71 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>,
                                                                     

                                                                     
then take the adjoint. One way to do this is starting with a state whose entries are
in <!-- l. 72 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>,
and then applying gates to it until all of the entries are in
<!-- l. 72 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>. The
following lemma should make clear why this helps us.
</p>
   <div class='newtheorem'>
<!-- l. 73 --><p class='noindent'><span class='head'>
<a id='x12-242001r2'></a>
<span class='cmbx-10x-x-109'>Lemma 10.1.2.</span>  </span> If <!-- l. 74 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
is normalised and all of its entries are in <!-- l. 74 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>,
then it must be a computational basis vector, up to a global phase.
</p>
   </div>
<!-- l. 75 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 77 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>For any element <!-- l. 77 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>z</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>a</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi mathvariant='italic'>bω</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>c</mi><msup><mrow><mi>ω</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>d</mi><msup><mrow><mi>ω</mi></mrow><mrow><mn>3</mn></mrow></msup></mrow></math>
in <!-- l. 77 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>, we can get an
explicit form for <!-- l. 77 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>z</mi><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='false' class='mml-overline'><mrow><mi>z</mi></mrow><mo accent='true'>¯</mo></mover><mi>z</mi></mrow></math>
in terms of <!-- l. 77 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msqrt><mrow><mn>2</mn></mrow></msqrt> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>ω</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>ω</mi></mrow><mrow><mn>3</mn></mrow></msup></mrow></math>:
</p><table class='equation'><tr><td>
<!-- l. 78 --><p class='indent'>
</p><!-- l. 78 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
         <mstyle class='label' id='x12-242002r2'></mstyle><!-- endlabel --><mo class='MathClass-rel' stretchy='false'>|</mo><mi>z</mi><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='false' class='mml-overline'><mrow><mi>z</mi></mrow><mo accent='true'>¯</mo></mover><mi>z</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>a</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>b</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>c</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>d</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi mathvariant='italic'>ab</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi mathvariant='italic'>bc</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi mathvariant='italic'>cd</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi mathvariant='italic'>da</mi><mo class='MathClass-close' stretchy='false'>)</mo><msqrt><mrow><mn>2</mn></mrow></msqrt><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td><td class='eq-no'>(10.2)</td></tr></table>
<!-- l. 81 --><p class='indent'>   If we suppose that all the <!-- l. 81 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>b</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>c</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>d</mi></mrow></math>
are integers, then the only way to have
<!-- l. 81 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>0</mn> <mo class='MathClass-rel' stretchy='false'>≤</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mi>z</mi><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>≤</mo> <mn>1</mn></mrow></math> is when the
<!-- l. 81 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msqrt><mrow>
<mn>2</mn></mrow></msqrt></math> part here is negative.
                                                                     

                                                                     
Let <!-- l. 82 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow> <mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>i</mi></mrow></msub><msub><mrow><mi>ψ</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><mi>i</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> be a normalised
state with entries in <!-- l. 82 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>.
Writing <!-- l. 82 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>ψ</mi></mrow><mrow><mi>i</mi></mrow></msub><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>n</mi></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>m</mi></mrow><mrow><mi>i</mi></mrow></msub><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></math>
where <!-- l. 82 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>m</mi></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi></mrow></math>
and <!-- l. 82 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>n</mi></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mn>0</mn></mrow></math> and
<!-- l. 82 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>m</mi></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>≤</mo> <mn>0</mn></mrow></math>, we have
<!-- l. 82 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>1</mn> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>⟨</mo><mi>ψ</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow> <mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>i</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>ψ</mi></mrow><mrow><mi>i</mi></mrow></msub><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow><mo> ∑</mo>
<!-- nolimits --></mrow><mrow><mi>i</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>n</mi></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>m</mi></mrow><mrow><mi>i</mi></mrow></msub><msqrt><mrow><mn>2</mn></mrow></msqrt><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>. Since we know that
the total sum is <!-- l. 82 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>,
the <!-- l. 82 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msqrt><mrow><mn>2</mn></mrow></msqrt></math> components
should cancel: <!-- l. 82 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>i</mi></mrow></msub><msub><mrow><mi>m</mi></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>.
But all the <!-- l. 82 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>m</mi></mrow><mrow><mi>i</mi></mrow></msub></math>
are negative, so the only way this can happen is if all
<!-- l. 82 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>m</mi></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>. Similarly, since all the
<!-- l. 82 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>n</mi></mrow><mrow><mi>i</mi></mrow></msub></math> are positive integers and
they sum to <!-- l. 82 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>, they must
all be zero except for one <!-- l. 82 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>n</mi></mrow><mrow><mi>j</mi></mrow></msub></math>
which is equal to <!-- l. 82 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>. But
then exactly one of <!-- l. 82 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>a</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>b</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>c</mi></mrow><mrow><mi>j</mi></mrow></msub></mrow></math>
and <!-- l. 82 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>d</mi></mrow><mrow><mi>j</mi></mrow></msub></math> is
<!-- l. 82 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>±</mo> <mn>1</mn></mrow></math>, and the rest
are zero. Hence <!-- l. 82 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>ω</mi></mrow><mrow><mi>k</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>j</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
for some <!-- l. 82 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>i</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>k</mi></mrow></math>.
                                                                   □
</p>
   </div>
<!-- l. 84 --><p class='indent'>   If we get to <!-- l. 84 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>ω</mi></mrow><mrow><mi>j</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>,
mission accomplished, up to a global phase. If we get to
<!-- l. 84 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>ω</mi></mrow><mrow><mi>j</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>, we simply
apply an <!-- l. 84 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>
gate (i.e. <!-- l. 84 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>H</mi><msup><mrow><mi>T</mi></mrow><mrow><mn>4</mn></mrow></msup><mi>H</mi></mrow></math>)
and again we are done. So, the name of the game is turning the coefficients of
<!-- l. 84 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> into elements of
<!-- l. 84 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>. One potential
strategy is to factor <!-- l. 84 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
as: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 85 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                  <mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo>  <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>k</mi></mrow></msup></mrow></mfrac> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mi>x</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>y</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow><mo fence='true' form='postfix'>)</mo></mrow><mspace class='qquad' width='2em'></mspace><mstyle class='text'><mtext class='textrm' mathvariant='normal'> for </mtext></mstyle><mi>x</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo>
</mrow></math></td></tr></table>
<!-- l. 89 --><p class='indent'>   then apply gates to <!-- l. 89 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> to
try and make the coefficients <!-- l. 89 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>x</mi></math>
and <!-- l. 89 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>y</mi></math>
into even numbers. Then, we can factor out a
<!-- l. 89 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>2</mn></math> from
<!-- l. 89 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>x</mi></math> and
<!-- l. 89 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>y</mi></math> and the leading
scalar becomes <!-- l. 89 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>  <mfrac><mrow><mn>1</mn></mrow>
<mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>k</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup></mrow></mfrac></mrow></math>
and we’ve made some progress toward getting a state whose coefficients are in
<!-- l. 89 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>. This
does work, but it is a bit tricky to find the gates we need to apply to
<!-- l. 89 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
to “make progress”. We can make life a bit easier if we express
<!-- l. 90 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
differently, as: </p><table class='equation'><tr><td>
<!-- l. 91 --><p class='indent'>
</p><!-- l. 91 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                  <mstyle class='label' id='x12-242003r3'></mstyle><!-- endlabel --><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo>  <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msup><mrow><mi>δ</mi></mrow><mrow><mi>k</mi></mrow></msup></mrow></mfrac> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mi>x</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>y</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow><mo fence='true' form='postfix'>)</mo></mrow><mspace class='qquad' width='2em'></mspace><mstyle class='text'><mtext class='textrm' mathvariant='normal'> for </mtext></mstyle><mi>x</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo>
</mrow></math></td><td class='eq-no'>(10.3)</td></tr></table>
<!-- l. 95 --><p class='indent'>   where <!-- l. 95 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>δ</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>ω</mi></mrow></math>
is a “special” number that has some nice number-theoretic properties that will help
with our synthesis algorithm (for more details on the number theory side of things,
check out the advanced section <a href='#exact-synthesis-of-cliffordt-states'>10.7.1<!-- tex4ht:ref: sec:synthesis-exact-clifford-t  --></a>). First, we should be able to check that
<!-- l. 96 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> is indeed a vector
over <!-- l. 96 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>. For this, we
should check that <!-- l. 96 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mn>1</mn></mrow>
<mrow><mi>δ</mi></mrow></mfrac> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>,
which is not immediate because not every element in
<!-- l. 96 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
has a multiplicative inverse. The elements of a ring that do
                                                                     

                                                                     
have multiplicative inverses are called <span class='cmbx-10x-x-109'>units</span>. We can see that
<!-- l. 96 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math> is a unit in
<!-- l. 96 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math> by letting
<!-- l. 96 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>δ</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>ω</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>ω</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>ω</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> and calculating
<!-- l. 96 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>δ</mi><msup><mrow><mi>δ</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>. Conversely, we would
like to know that any <!-- l. 97 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
with coefficients in <!-- l. 97 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
can be written in the form of (<a href='#x12-242003r3'>10.3<!-- tex4ht:ref: eq:lde-form  --></a>). This is true if any
<!-- l. 97 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>q</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math> can be written
as <!-- l. 97 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mfrac><mrow><mi>x</mi></mrow>
<mrow><msup><mrow><mi>δ</mi></mrow><mrow><mi>k</mi></mrow></msup></mrow></mfrac></mrow></math> for some
<!-- l. 97 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math> and a high
enough power <!-- l. 97 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
of <!-- l. 97 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math>.
Put another way, we need to prove the following property of
<!-- l. 97 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math>.
</p>
   <div class='newtheorem'>
<!-- l. 98 --><p class='noindent'><span class='head'>
<a id='x12-242004r2'></a>
<span class='cmbx-10x-x-109'>Exercise 10.2.</span>  </span>Show that, for any <!-- l. 99 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>q</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>,
there exists <!-- l. 99 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
such that <!-- l. 99 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>δ</mi></mrow><mrow><mi>k</mi></mrow></msup><mi>q</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>.
<span class='cmti-10x-x-109'>Hint: Using the fact that </span><!-- l. 99 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msqrt><mrow><mn>2</mn></mrow></msqrt> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>ω</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>ω</mi></mrow><mrow><mn>3</mn></mrow></msup></mrow></math><span class='cmti-10x-x-109'>,
first show that </span><!-- l. 99 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>δ</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>λ</mi><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></math><span class='cmti-10x-x-109'>,
where </span><!-- l. 99 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>λ</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>ω</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>ω</mi></mrow><mrow><mn>2</mn></mrow></msup></mrow></math>
<span class='cmti-10x-x-109'>is in </span><!-- l. 99 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math><span class='cmti-10x-x-109'>.</span>
</p>
   </div>
<!-- l. 100 --><p class='indent'>    The smallest <!-- l. 101 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
needed to express <!-- l. 101 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
in the form of equation (<a href='#x12-242003r3'>10.3<!-- tex4ht:ref: eq:lde-form  --></a>) is called the <span class='cmbx-10x-x-109'>least denominator exponent </span>(lde). If the
lde is <!-- l. 101 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math>, then
<!-- l. 101 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> is already has
coefficients in <!-- l. 101 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>,
so by Lemma <a href='#x12-242001r2'>10.1.2<!-- tex4ht:ref: lem:norm-Zom-unit  --></a>, it must be a basis state, up to a phase. It is easy to see that
<!-- l. 101 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> is minimal
precisely when <!-- l. 101 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>x</mi></math>
and <!-- l. 101 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>y</mi></math> are not both
divisible by <!-- l. 101 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math>, i.e. when
there exists no pair <!-- l. 101 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>b</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
such that <!-- l. 101 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>aδ</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>x</mi></mrow></math> and
                                                                     

                                                                     
<!-- l. 101 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>bδ</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>y</mi></mrow></math>. We can easily
check divisibility by <!-- l. 102 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math>
using <!-- l. 102 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>δ</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup></math>. Since
<!-- l. 102 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>δ</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup><mo class='MathClass-rel' stretchy='false'>∉</mo><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>, then it is not
necessarily the case that <!-- l. 102 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>z</mi><msup><mrow><mi>δ</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
for some <!-- l. 102 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>. In
fact, it will be in <!-- l. 102 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
precisely when <!-- l. 102 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math>
divides <!-- l. 102 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>x</mi></math>.
The final piece of the puzzle is the following lemma, which lets us decrease the
lde by applying H and T gates.
</p>
   <div class='newtheorem'>
<!-- l. 104 --><p class='noindent'><span class='head'>
<a id='x12-242005r3'></a>
<span class='cmbx-10x-x-109'>Lemma 10.1.3.</span>  </span> Let <!-- l. 105 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo>  <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msup><mrow><mi>δ</mi></mrow><mrow><mi>k</mi></mrow></msup></mrow></mfrac><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>y</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
be a state where <!-- l. 105 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
are non-zero. Then there exists some <!-- l. 105 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>l</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo><mo class='MathClass-open' stretchy='false'>{</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><mn>7</mn><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>
such that <!-- l. 105 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>H</mi><msup><mrow><mi>T</mi></mrow><mrow><mi>l</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo>  <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msup><mrow><mi>δ</mi></mrow><mrow><mi>k</mi></mrow></msup></mrow></mfrac><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>x</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>y</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
for <!-- l. 105 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>x</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mi>y</mi></mrow><mrow><mi>′</mi></mrow></msup></mrow></math>
divisible by <!-- l. 105 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math>.
</p>
   </div>
<!-- l. 106 --><p class='indent'>    Since <!-- l. 107 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>x</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mi>y</mi></mrow><mrow><mi>′</mi></mrow></msup></mrow></math> become
divisible by <!-- l. 107 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math>, we
can factor a <!-- l. 107 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math>
out and reduce the least denominator exponent by 1. If we
repeat this process over and over, eventually the lde will be
<!-- l. 107 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math>,
so by Lemma <a href='#x12-242001r2'>10.1.2<!-- tex4ht:ref: lem:norm-Zom-unit  --></a> it will be a basis vector. The reason why
Lemma <a href='#x12-242005r3'>10.1.3<!-- tex4ht:ref: lem:delta-reduce  --></a> works has to do with the special behaviour of
<!-- l. 108 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math> within
the ring <!-- l. 108 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>.
Namely, if we start computing numbers modulo
<!-- l. 108 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math> (or
powers of <!-- l. 108 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math>)
in <!-- l. 108 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>, we will
see that <!-- l. 108 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>x</mi></math>
and <!-- l. 108 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>y</mi></math>
can always be broken down into a particular form that tells us how many
<!-- l. 108 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates
                                                                     

                                                                     
to apply to make progress. To understand this, we will need to define the notion
of a <span class='cmbx-10x-x-109'>residue class</span>, which lets us formalise what it means to work “modulo”
some element of an arbitrary ring. We will do this and provide a proof
for Lemma <a href='#x12-242005r3'>10.1.3<!-- tex4ht:ref: lem:delta-reduce  --></a> in Section <a href='#exact-synthesis-of-cliffordt-states'>10.7.1<!-- tex4ht:ref: sec:synthesis-exact-clifford-t  --></a>. However, if we believe the lemma,
we now have a synthesis algorithm for qubit states. In fact, this also
already gives a synthesis algorithm for single-qubit unitaries. This is
because the columns of a unitary matrix must be orthogonal, so if we
send the first column to a basis vector, the second column will also get
sent to a basis vector, up to a phase. So after transforming the basis
vector to the correct positions and phases, we will have synthesised the
entire single-qubit unitary. We summarise this procedure in Algorithm <a href='#x12-2420074'>4<!-- tex4ht:ref: alg:single-qubit-synth  --></a>.
<a id='x12-242006r4'></a>
                                                                     

                                                                     
</p><!-- l. 111 --><p class='indent'>   </p><figure class='float' id='x12-242008'><span id='exact-synthesis-for-qubit-cliffordt-gates'></span>
                                                                     

                                                                     
                                                                     

                                                                     
_____________________________________________________________________
  <span class='cmbx-10x-x-109'>Algorithm 4:</span> Exact synthesis for qubit Clifford+T gates___________________ 
     <a id='x12-2420074'></a>
     <span class='cmbx-10x-x-109'>Input:</span> A
               unitary
               <!-- l. 114 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
             with
               elements
               in
               <!-- l. 114 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
     <span class='cmbx-10x-x-109'>Output:</span> A
                  list
                  of
                  <!-- l. 115 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math>
               and
                  <!-- l. 115 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
               gates
                  implementing
                  <!-- l. 115 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
          <dl class='enumerate'><dt class='enumerate'>
      1.. </dt><dd class='enumerate'>
            <!-- l. 117 --><p class='noindent'>Let
            <!-- l. 117 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
     and
            <!-- l. 117 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ϕ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
     be
            the
            columns
            of
            <!-- l. 117 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>.
            Since
            <!-- l. 117 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
          is
            unitary,
            <!-- l. 117 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
     and
            <!-- l. 117 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ϕ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
     must
            be
            orthogonal.
            </p></dd><dt class='enumerate'>
       2.. </dt><dd class='enumerate'>
            <!-- l. 118 --><p class='noindent'>Express <!-- l. 118 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
     as: </p><table class='equation-star'><tr><td>
            <!-- l. 119 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                     <mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo>  <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msup><mrow><mi>δ</mi></mrow><mrow><mi>k</mi></mrow></msup></mrow></mfrac> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mi>x</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>y</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow><mo fence='true' form='postfix'>)</mo></mrow><mspace class='qquad' width='2em'></mspace><mstyle class='text'><mtext class='textrm' mathvariant='normal'> for </mtext></mstyle><mi>x</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo>
</mrow></math></td></tr></table>
            <!-- l. 121 --><p class='noindent'>where
            <!-- l. 121 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
          is
            the
            least
            denominator
            exponent.
            </p></dd><dt class='enumerate'>
       3.. </dt><dd class='enumerate'>
            <!-- l. 122 --><p class='noindent'>Try
            to
            apply
            <!-- l. 122 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>H</mi><msup><mrow><mi>T</mi></mrow><mrow><mi>l</mi></mrow></msup></mrow></math>
             for
            all
            <!-- l. 122 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>l</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo><mo class='MathClass-open' stretchy='false'>{</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><mn>7</mn><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>
     to
            <!-- l. 122 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>y</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
     to
            obtain
            <!-- l. 122 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>x</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>y</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
     where
            <!-- l. 122 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math>
          divides
            <!-- l. 122 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>x</mi></mrow><mrow><mi>′</mi></mrow></msup></math>
       and
            <!-- l. 122 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>y</mi></mrow><mrow><mi>′</mi></mrow></msup></math>.
            </p></dd><dt class='enumerate'>
       4.. </dt><dd class='enumerate'>
            <!-- l. 123 --><p class='noindent'>Factor out a <!-- l. 123 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math>
          to obtain: </p><table class='equation-star'><tr><td>
            <!-- l. 124 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                      <mo class='MathClass-rel' stretchy='false'>|</mo><msup><mrow><mi>ψ</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>H</mi><msup><mrow><mi>T</mi></mrow><mrow><mi>l</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo>   <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msup><mrow><mi>δ</mi></mrow><mrow><mi>k</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup></mrow></mfrac> <mrow><mo fence='true' form='prefix'>(</mo><mrow><msup><mrow><mi>x</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>y</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow><mo fence='true' form='postfix'>)</mo></mrow>
</mrow></math></td></tr></table>
     </dd><dt class='enumerate'>
   5.. </dt><dd class='enumerate'>
            <!-- l. 127 --><p class='noindent'>Repeat
            until
            the
            lde
            is
            <!-- l. 127 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math>
            to
            obtain
            a
            sequence
            of
            gates
            sending
            <!-- l. 127 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
     to
            <!-- l. 127 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>ω</mi></mrow><mrow><mi>j</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>i</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
            Optionally,
            apply
            a
            final
            <!-- l. 127 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>
          gate
            to
            send
            <!-- l. 127 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
     to
            <!-- l. 127 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>ω</mi></mrow><mrow><mi>j</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
            </p></dd><dt class='enumerate'>
       6.. </dt><dd class='enumerate'>
            <!-- l. 128 --><p class='noindent'>Since
            unitaries
            preserve
            orthogonality,
            the
            same
            sequence
            of
            gates
            will
            send
            <!-- l. 128 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ϕ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
     to
            <!-- l. 128 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>ω</mi></mrow><mrow><msup><mrow><mi>j</mi></mrow><mrow><mi>′</mi></mrow></msup>
 </mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
            Perform
            a
            final
            <!-- l. 128 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>T</mi></mrow><mrow><mi>j</mi><mo class='MathClass-bin' stretchy='false'>−</mo><msup><mrow><mi>j</mi></mrow><mrow><mi>′</mi></mrow></msup>
   </mrow></msup></math>
        to
            remove
            the
            relative
            phase
            between
            <!-- l. 128 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
     and
            <!-- l. 128 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
            Then
            <!-- l. 128 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>G</mi></mrow><mrow><mi>s</mi></mrow></msub><mo>…</mo><msub><mrow><mi>G</mi></mrow><mrow><mn>1</mn></mrow></msub><mi>U</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>ω</mi></mrow><mrow><mi>j</mi></mrow></msup><mi>I</mi></mrow></math>.
            </p></dd><dt class='enumerate'>
       7.. </dt><dd class='enumerate'>
            <!-- l. 129 --><p class='noindent'>Return
            <!-- l. 129 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mrow><mi>G</mi></mrow><mrow><mn>1</mn></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msubsup><mo>…</mo><msubsup><mrow><mi>G</mi></mrow><mrow><mi>s</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msubsup></mrow></math>,
            which
            implements
            <!-- l. 129 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
          up
            to
            a
            global
            phase.
            </p></dd></dl>______________________________________________________________________________________

                                                                     
                                                                     

                                                                     
   </figure>
   <div class='newtheorem'>
<!-- l. 132 --><p class='noindent'><span class='head'>
<a id='x12-242016r4'></a>
<span class='cmbx-10x-x-109'>Example 10.1.4.</span>  </span>Consider the following unitary over
<!-- l. 133 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>:
</p><table class='equation-star'><tr><td>
<!-- l. 134 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mi>U</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'>   <mn>1</mn> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>ω</mi></mrow><mrow><mn>3</mn></mrow></msup>    </mtd><mtd class='array-td' columnalign='center'>   <mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>ω</mi>  </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mo class='MathClass-bin' stretchy='false'>−</mo><msup><mrow><mi>ω</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>ω</mi></mrow><mrow><mn>3</mn></mrow></msup>  </mtd><mtd class='array-td' columnalign='center'>  <mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>ω</mi></mrow><mrow><mn>3</mn></mrow></msup>  </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                      </mrow><mo fence='true' form='postfix'>)</mo></mrow>
</mrow></math></td></tr></table>
<!-- l. 141 --><p class='indent'>   We need to first express <!-- l. 141 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
in terms of a <!-- l. 141 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math> matrix
multiplied by <!-- l. 141 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mfrac><mrow><mn>1</mn></mrow>
<mrow><msup><mrow><mi>δ</mi></mrow><mrow><mi>k</mi></mrow></msup></mrow></mfrac></mrow></math>,
where <!-- l. 141 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> is the lde of
<!-- l. 141 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>. This can be accomplished
by multiplying <!-- l. 141 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math> by
<!-- l. 141 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math> repeatedly until we
get a matrix <!-- l. 141 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>U</mi></mrow><mrow><mi>′</mi></mrow></msup></math> whose
entries are in <!-- l. 141 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>. For our
chosen <!-- l. 141 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>, we needed
to multiply by <!-- l. 141 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math>
three times to get a <!-- l. 141 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
matrix, giving us the following expression: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 142 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mi>U</mi> <mo class='MathClass-rel' stretchy='false'>=</mo>  <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msup><mrow><mi>δ</mi></mrow><mrow><mn>3</mn></mrow></msup></mrow></mfrac> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <mn>2</mn> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>3</mn><mi>ω</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>2</mn><msup><mrow><mi>ω</mi></mrow><mrow><mn>2</mn></mrow></msup>  </mtd><mtd class='array-td' columnalign='center'>    <mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>ω</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>ω</mi></mrow><mrow><mn>3</mn></mrow></msup>    </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <mo class='MathClass-bin' stretchy='false'>−</mo><mi>ω</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>ω</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>ω</mi></mrow><mrow><mn>3</mn></mrow></msup>  </mtd><mtd class='array-td' columnalign='center'>  <mo class='MathClass-bin' stretchy='false'>−</mo><mn>2</mn> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>3</mn><mi>ω</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>2</mn><msup><mrow><mi>ω</mi></mrow><mrow><mn>2</mn></mrow></msup>  </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                    </mrow><mo fence='true' form='postfix'>)</mo></mrow>
</mrow></math></td></tr></table>
<!-- l. 149 --><p class='indent'>   So, we have an initial lde of 3. We then try to apply
<!-- l. 149 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>T</mi></mrow><mrow><mi>l</mi></mrow></msup></math> for some
<!-- l. 149 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>l</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo><mo class='MathClass-open' stretchy='false'>{</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><mn>7</mn><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math> followed by an
<!-- l. 149 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math> gate to reduce the
lde. Picking <!-- l. 149 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>l</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math> (i.e. just
applying an <!-- l. 149 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math> gate) does
not reduce the lde, but <!-- l. 149 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>l</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>
reduces the lde from 3 to 2: </p><table class='equation-star'><tr><td>
<!-- l. 150 --><object data="svgs/synth1.svg" alt="diagram of synth1" class="svg-diagram"></object></td></tr></table>
<!-- l. 153 --><p class='indent'>   The lde is not zero yet, so we do another iteration, this time finding we can reduce the
lde at <!-- l. 153 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>l</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>3</mn></mrow></math>. Namely,
if we apply <!-- l. 153 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>T</mi></mrow><mrow><mn>3</mn></mrow></msup></math>
followed by <!-- l. 153 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math>,
we reduce the lde from 2 to 0: </p><table class='equation-star'><tr><td>
<!-- l. 154 --><object data="svgs/synth2.svg" alt="diagram of synth2" class="svg-diagram"></object></td></tr></table>
                                                                     

                                                                     
<!-- l. 157 --><p class='indent'>   Our matrix now contains only elements of
<!-- l. 157 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>, so
we know the first column must be a basis vector, up to a phase. We find it is
<!-- l. 157 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>ω</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>. We can
change it to <!-- l. 157 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>ω</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> by
applying an <!-- l. 157 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>
gate: </p><table class='equation-star'><tr><td>
<!-- l. 158 --><object data="svgs/synth3.svg" alt="diagram of synth3" class="svg-diagram"></object></td></tr></table>
<!-- l. 161 --><p class='indent'>   Finally, we finish by correcting the relative phase with a final application of
<!-- l. 161 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>T</mi></mrow><mrow><mn>3</mn></mrow></msup></math>,
obtaining identity, up to a global phase: </p><table class='equation-star'><tr><td>
<!-- l. 162 --><object data="svgs/synth4.svg" alt="diagram of synth4" class="svg-diagram"></object></td></tr></table>
<!-- l. 165 --><p class='indent'>   Moving everything but <!-- l. 165 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
to the RHS, we conclude that: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 166 --><object data="svgs/synth5.svg" alt="diagram of synth5" class="svg-diagram"></object></td></tr></table>
   </div>
<!-- l. 169 --><p class='indent'>
</p>
   <h4 class='subsectionHead' id='approximating-arbitrary-singlequbit-gates'><span class='titlemark'>10.1.2   </span> <a id='x12-24300010.1.2'></a>Approximating arbitrary single-qubit gates</h4>
<!-- l. 171 --><p class='noindent'>Suppose we want to use the exact synthesis algorithm from the previous section
to approximate arbitrary, single-qubit unitaries. We now know that we can build any
<!-- l. 171 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>2</mn> <mo class='MathClass-bin' stretchy='false'>×</mo> <mn>2</mn></mrow></math> unitary matrix
over the ring <!-- l. 171 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>,
and it is not hard to see that any complex number can be
approximated to arbitrarily high precision by some element of
<!-- l. 171 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>. Indeed, if
we take <!-- l. 171 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mfrac><mrow><mi>a</mi></mrow>
<mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>j</mi></mrow></msup></mrow></mfrac> <mo class='MathClass-bin' stretchy='false'>+</mo>  <mfrac><mrow><mi>b</mi></mrow> 
<mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>k</mi></mrow></msup></mrow></mfrac><msup><mrow><mi>ω</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo>  <mfrac><mrow><mi>a</mi></mrow> 
<mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>j</mi></mrow></msup></mrow></mfrac> <mo class='MathClass-bin' stretchy='false'>+</mo>  <mfrac><mrow><mi>b</mi></mrow> 
<mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>k</mi></mrow></msup></mrow></mfrac><mi>i</mi></mrow></math> for
<!-- l. 171 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>b</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi></mrow></math> and some suitably
high values of <!-- l. 171 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>j</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℕ</mi></mrow></math>,
we can get as close as we like to an arbitrary complex number. We seem to
be most of the way there on coming up with an approximate synthesis
algorithm. The problem is, if we go through a complex-valued unitary matrix
<!-- l. 172 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
element-by-element and approximate each complex number with an element of
<!-- l. 172 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>, odds
are we won’t get something unitary but just very nearly unitary. So we need a
better idea. Like in the exact synthesis case, inspiration comes from looking at
the least denominator exponenent. The idea is, for a target unitary matrix
<!-- l. 173 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math> and a fixed
error bound <!-- l. 173 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝜖</mi> <mo class='MathClass-rel' stretchy='false'>&gt;</mo> <mn>0</mn></mrow></math>,
we progressively raise the denominator exponent
<!-- l. 173 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> until we can
find some <!-- l. 173 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> <mo class='MathClass-rel' stretchy='false'>=</mo>  <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msup><mrow><mi>δ</mi></mrow><mrow><mi>k</mi></mrow></msup></mrow></mfrac><msup><mrow><mi>V</mi> </mrow><mrow><mi>′</mi></mrow></msup></mrow></math>
where
     </p><dl class='enumerate'><dt class='enumerate'>
  1.. </dt><dd class='enumerate'>
     <!-- l. 175 --><p class='noindent'><!-- l. 175 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>V</mi> </mrow><mrow><mi>′</mi></mrow></msup></math>
     is a matrix over <!-- l. 175 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>,
                                                                     

                                                                     
     </p></dd><dt class='enumerate'>
  2.. </dt><dd class='enumerate'>
     <!-- l. 176 --><p class='noindent'><!-- l. 176 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> </mrow></math>
     is unitary, and
     </p></dd><dt class='enumerate'>
  3.. </dt><dd class='enumerate'>
     <!-- l. 177 --><p class='noindent'>for some global phase <!-- l. 177 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>α</mi></math>,
     <!-- l. 177 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>∥</mo><mi>V</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iα</mi></mrow></msup><mi>U</mi><mo class='MathClass-rel' stretchy='false'>∥</mo><mo class='MathClass-rel' stretchy='false'>≤</mo> <mi>𝜖</mi></mrow></math>.
     </p></dd></dl>
<!-- l. 179 --><p class='noindent'>It turns out condition 2 is already quite restrictive. Since
<!-- l. 179 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> </mrow></math> is a
unitary, its columns need to be normalised. Hence, the norm-squared of the columns of
<!-- l. 179 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>V</mi> </mrow><mrow><mi>′</mi></mrow></msup></math> must be
<!-- l. 179 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>δ</mi><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn><mi>k</mi></mrow></msup></mrow></math>. Using this fact, we can
prove that for fixed <!-- l. 179 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>, there
are only finitely many <!-- l. 179 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>V</mi> </mrow><mrow><mi>′</mi></mrow></msup></math>
to choose from.
</p>
   <div class='newtheorem'>
<!-- l. 180 --><p class='noindent'><span class='head'>
<a id='x12-243004r3'></a>
<span class='cmbx-10x-x-109'>Exercise 10.3.</span>  </span>Show that, for a fixed <!-- l. 181 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℕ</mi></mrow></math>,
there are only finitely many <!-- l. 181 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
such that <!-- l. 181 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>x</mi><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mi>y</mi><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mi>K</mi><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup></mrow></math>
for any constant <!-- l. 181 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>K</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>.
Show that this implies there are only finitely many matrices <!-- l. 181 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>V</mi> </mrow><mrow><mi>′</mi></mrow></msup></math>
over <!-- l. 181 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
such that <!-- l. 181 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> <mo class='MathClass-rel' stretchy='false'>=</mo>  <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msup><mrow><mi>δ</mi></mrow><mrow><mi>k</mi></mrow></msup></mrow></mfrac><msup><mrow><mi>V</mi> </mrow><mrow><mi>′</mi></mrow></msup></mrow></math>
is unitary for any fixed <!-- l. 181 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>.
<span class='cmti-10x-x-109'>Hint: Use</span> (<a href='#x12-242002r2'>10.2<!-- tex4ht:ref: eq:ring-norm  --></a>) <span class='cmti-10x-x-109'>to get an explicit form for </span><!-- l. 181 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>x</mi><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup></mrow></math>
<span class='cmti-10x-x-109'>and </span><!-- l. 181 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>y</mi><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup></mrow></math>
<span class='cmti-10x-x-109'>in terms of their integer coefficients.</span>
</p>
   </div>
<!-- l. 182 --><p class='indent'>    Since we already know that there are finitely many
<!-- l. 183 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> </mrow></math> satisfying conditions 1
and 2 above for fixed <!-- l. 183 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>,
we know that there must also be finitely many
<!-- l. 183 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> </mrow></math>
                                                                     

                                                                     
satisfying all 3 conditions. Hence, we can enumerate them for a fixed
<!-- l. 183 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>.
If we find a solution, we accept it. Otherwise, we increase
<!-- l. 183 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> and
try again. It turns out that there is a way to do this enumeration of
candidates satisfying conditions 1–3 efficiently, and that it terminates for
<!-- l. 184 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><mi>𝜖</mi></mrow></mfrac><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>. The
way this works has to do with properties of certain discrete subsets of the
complex plane, which are a bit advanced for our purposes. Hence, we’ll finish our
story on synthesis here, and make a few more remarks about this in the advanced
Section* <a href='#approximate-singlequbit-cliffordt-synthesis'>10.7.3<!-- tex4ht:ref: sec:synthesis-approx  --></a>.
</p>
   <h3 class='sectionHead' id='scalable-zx-notation'><span class='titlemark'>10.2   </span> <a id='x12-24400010.2'></a>Scalable ZX notation</h3>
<!-- l. 187 --><p class='noindent'>So far in this book we have used ZX-diagrams where each wire represents a single
qubit. As we have seen, this already allows us to do a lot of interesting stuff.
However, sometimes there is repetitive structure in the diagram that we should
really try to abstract away, so that we don’t miss the forest for the trees.
The way we do that will be with <span class='cmbx-10x-x-109'>scalable ZX notation</span>. This notation
allows us to compactly represent operations on registers of many qubits,
while still maintaining much of the flavour of calculations with standard
ZX-diagrams. We will represent a register of qubits as a single thick wire:
</p><table class='equation'><tr><td>
<!-- l. 190 --><p class='indent'>
</p><!-- l. 190 --><object id='x12-244001r4' data="svgs/eq-scalable-wire.svg" alt="diagram of eq:scalable-wire" class="svg-diagram"></object></td><td class='eq-no'>(10.4)</td></tr></table>
<!-- l. 193 --><p class='indent'>   Sometimes we will need to split a register into two registers, peal one qubit off
to do something with, or merge registers together again. For that we introduce a
little bit of extra notation: </p><table class='equation'><tr><td>
<!-- l. 194 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 194 --><object id='x12-244002r5' data="svgs/eq-divide-gather.svg" alt="diagram of eq:divide-gather" class="svg-diagram"></object></td><td class='eq-no'>(10.5)</td></tr></table>
<!-- l. 197 --><p class='indent'>   We call these operations <span class='cmbx-10x-x-109'>divide </span>and <span class='cmbx-10x-x-109'>gather</span>. They don’t actually <span class='cmti-10x-x-109'>do</span>
anything as linear maps (they are just the identity), but they help us compactly
write down more complicated maps. They come with some simple rewrites:
</p><table class='equation'><tr><td>
<!-- l. 199 --><p class='indent'>
</p><!-- l. 199 --><object id='x12-244003r6' data="svgs/eq-divide-gather-rewrite.svg" alt="diagram of eq:divide-gather-rewrite" class="svg-diagram"></object></td><td class='eq-no'>(10.6)</td></tr></table>
<!-- l. 202 --><p class='indent'>   Note that in general we will only label the thick wires with the number of
qubits they represent when it is necessary for clarity, and leave it implicit
otherwise. Just being able to represent a qubit register as a single wire is not that
useful, so let’s introduce some things we can do with them. We will use bold
spiders (with a thick border) to represent a product of (unconnected) copies of a
Z or X spider as a bold spider: </p><table class='equation'><tr><td>
<!-- l. 205 --><p class='indent'>
</p><!-- l. 205 --><object id='x12-244004r7' data="svgs/eq-scalable-spiders.svg" alt="diagram of eq:scalable-spiders" class="svg-diagram"></object></td><td class='eq-no'>(10.7)</td></tr></table>
                                                                     

                                                                     
<!-- l. 208 --><p class='indent'>   Note that in this notation each thick wire connected to the same spider needs
to represent the same number of qubits, otherwise it is not a valid diagram.
These bolded spiders can be labelled by a phase, and this phase then gets
applied to each qubit separately. As the bolded Z- and X-spiders represent
non-interacting parallel spiders, all the standard ZX rewrites still apply to them,
and hence we can still do spider fusion, strong complementarity, etc. We can push
spiders through a dividers and this in fact gives us a type of bialgebra
between the Z/X spider and the dividers and gatherers (cf. Section <a href='main_htmlch3.html#strong-complementarity'>3.2.4<!-- tex4ht:ref: sec:bialgebra-hopf  --></a>):
</p><table class='equation'><tr><td>
<!-- l. 212 --><p class='indent'>
</p><!-- l. 212 --><object id='x12-244005r8' data="svgs/eq-divide-spider.svg" alt="diagram of eq:divide-spider" class="svg-diagram"></object></td><td class='eq-no'>(10.8)</td></tr></table>
<!-- l. 215 --><p class='indent'>   Note that this also works when the spider has no additional outputs:
</p><table class='equation'><tr><td>
<!-- l. 216 --><p class='indent'>
</p><!-- l. 216 --><object id='x12-244006r9' data="svgs/eq-divide-spider-disconnect.svg" alt="diagram of eq:divide-spider-disconnect" class="svg-diagram"></object></td><td class='eq-no'>(10.9)</td></tr></table>
<!-- l. 219 --><p class='indent'>   The most important component of the scalable notation, and what makes all
of this worthwhile, is a new piece of notation called the <span class='cmbx-10x-x-109'>matrix arrow</span>, or just
<span class='cmti-10x-x-109'>arrow </span>for short, which allows us to represent arbitrary connectivity from
<!-- l. 219 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>m</mi></math> Z-spiders to
<!-- l. 219 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math> X-spiders using
an <!-- l. 219 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>×</mo> <mi>m</mi></mrow></math> biadjacency
matrix <!-- l. 219 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>A</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <msubsup><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>n</mi><mo class='MathClass-bin' stretchy='false'>×</mo><mi>m</mi></mrow></msubsup></mrow></math>:
</p><table class='equation'><tr><td>
<!-- l. 220 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 220 --><object id='x12-244007r10' data="svgs/eq-arrow-def.svg" alt="diagram of eq:arrow-def" class="svg-diagram"></object></td><td class='eq-no'>(10.10)</td></tr></table>
<!-- l. 223 --><p class='indent'>   Taking the convention that <!-- l. 223 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msubsup><mrow><mi>A</mi></mrow><mrow><mi>i</mi></mrow><mrow><mi>j</mi></mrow></msubsup></math>
represents the entry in the <!-- l. 223 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math>-th
column and <!-- l. 223 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>j</mi></math>-th row of
the matrix <!-- l. 223 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>, we have in
Eq. (<a href='#x12-244007r10'>10.10<!-- tex4ht:ref: eq:arrow-def  --></a>) that <!-- l. 223 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mrow><mi>A</mi></mrow><mrow><mi>i</mi></mrow><mrow><mi>j</mi></mrow></msubsup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math> if and only
if the <!-- l. 223 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math>-th Z-spider on the
left is connected to the <!-- l. 223 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>j</mi></math>-th
X-spider on the right. Just using a single matrix arrow we can hence
write down an arbitrary phase-free ZX-diagram in parity normal
form (Definition <a href='main_htmlch4.html#x6-92004r2'>4.2.2<!-- tex4ht:ref: def:parity-NF  --></a>), by directly writing the biadjacency matrix
<!-- l. 224 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math> on the
matrix arrow. Concretely, Eq. (<a href='#x12-244007r10'>10.10<!-- tex4ht:ref: eq:arrow-def  --></a>) corresponds, up to scalar factors, to a linear map
that acts as <!-- l. 225 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>
on computational basis vectors: </p><table class='equation'><tr><td>
<!-- l. 226 --><p class='indent'>
</p><!-- l. 226 --><object id='x12-244008r11' data="svgs/eq-arrow-as-map.svg" alt="diagram of eq:arrow-as-map" class="svg-diagram"></object></td><td class='eq-no'>(10.11)</td></tr></table>
<!-- l. 229 --><p class='indent'>   Note that we treat the bit string <!-- l. 229 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover></math>
as a column vector for the purposes of matrix multiplication. Let’s consider some
special cases for the matrix arrow, an all zero matrix and the identity:
</p><table class='equation'><tr><td>
<!-- l. 231 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 231 --><object id='x12-244009r12' data="svgs/eq-arrow-zero-id.svg" alt="diagram of eq:arrow-zero-id" class="svg-diagram"></object></td><td class='eq-no'>(10.12)</td></tr></table>
<!-- l. 234 --><p class='indent'>   Using Eq. (<a href='#x12-244008r11'>10.11<!-- tex4ht:ref: eq:arrow-as-map  --></a>), we can see that when we compose matrix arrows, we just
calculate the matrix product: </p><table class='equation'><tr><td>
<!-- l. 235 --><p class='indent'>
</p><!-- l. 235 --><object id='x12-244010r13' data="svgs/eq-arrow-product.svg" alt="diagram of eq:arrow-product" class="svg-diagram"></object></td><td class='eq-no'>(10.13)</td></tr></table>
<!-- l. 238 --><p class='indent'>   We can also prove this diagrammatically by unrolling the definitions and
using strong complementarity on all the internal spiders (this is essentially doing
the reduction to parity normal form from Chapter <a href='main_htmlch4.html#cnot-circuits-and-phasefree-zxdiagrams'>4<!-- tex4ht:ref: ch:phasefree  --></a>). Spiders and arrows
interact in nice ways. First, we have two “copy” laws allowing us to push arrows
through spiders: </p><table class='equation'><tr><td>
<!-- l. 240 --><p class='indent'>
</p><!-- l. 240 --><object id='x12-244011r14' data="svgs/eq-arrow-copy.svg" alt="diagram of eq:arrow-copy" class="svg-diagram"></object></td><td class='eq-no'>(10.14)</td></tr></table>
<!-- l. 243 --><p class='indent'>   These can be proven by unrolling the definitions and using strong
complementarity and spider fusion.
</p>
   <div class='newtheorem'>
<!-- l. 244 --><p class='noindent'><span class='head'>
                                                                     

                                                                     
<a id='x12-244012r1'></a>
<span class='cmbx-10x-x-109'>Example 10.2.1.</span>  </span>Let <!-- l. 245 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>A</mi> <mo class='MathClass-rel' stretchy='false'>=</mo>  <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn></mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                       </mrow><mo fence='true' form='postfix'>)</mo></mrow></mrow></math>.
Then:
</p>
<div class='center'>
<!-- l. 247 --><p class='noindent'>
</p><!-- l. 248 --><p class='noindent'><object data="svgs/arrow-copy-example.svg" alt="diagram of arrow-copy-example" class="svg-diagram"></object> </p></div>
   </div>
<!-- l. 251 --><p class='indent'>    Second, we can express block matrices in terms of spiders: </p><table class='equation'><tr><td>
<!-- l. 253 --><p class='indent'>
</p><!-- l. 253 --><object id='x12-244013r15' data="svgs/eq-arrow-stack.svg" alt="diagram of eq:arrow-stack" class="svg-diagram"></object></td><td class='eq-no'>(10.15)</td></tr></table>
<!-- l. 256 --><p class='indent'>   We can combine these operations to get a decomposition of a matrix into
smaller matrices: </p><table class='equation'><tr><td>
<!-- l. 257 --><p class='indent'>
</p><!-- l. 257 --><object id='x12-244014r16' data="svgs/eq-arrow-block-matrix.svg" alt="diagram of eq:arrow-block-matrix" class="svg-diagram"></object></td><td class='eq-no'>(10.16)</td></tr></table>
<!-- l. 260 --><p class='indent'>   We could view this as the definition of the matrix arrow, because this allows
us to define it inductively, starting from trivial components and combining these
into larger matrices. The block matrix and composition rules also imply a
graphical rule for the sum of two matrices.
                                                                     

                                                                     
</p>
   <div class='newtheorem'>
<!-- l. 262 --><p class='noindent'><span class='head'>
<a id='x12-244015r2'></a>
<span class='cmbx-10x-x-109'>Proposition 10.2.2.</span>  </span> For any <!-- l. 263 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>
matrices <!-- l. 263 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>A</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>B</mi></mrow></math>,
we have:
</p>
<div class='center'>
<!-- l. 265 --><p class='noindent'>
</p><!-- l. 266 --><p class='noindent'><object data="svgs/scalable-addition.svg" alt="diagram of scalable-addition" class="svg-diagram"></object> </p></div>
   </div>
<!-- l. 269 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 271 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>Starting       from       the       LHS,       we       can       decompose
<!-- l. 271 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>A</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi mathvariant='italic'>AI</mi></mrow></math>
and
<!-- l. 271 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>B</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi mathvariant='italic'>BI</mi></mrow></math>
and apply (<a href='#x12-244010r13'>10.13<!-- tex4ht:ref: eq:arrow-product  --></a>) and (<a href='#x12-244013r15'>10.15<!-- tex4ht:ref: eq:arrow-stack  --></a>):
</p>
<div class='center'>
<!-- l. 273 --><p class='noindent'>
</p><!-- l. 274 --><p class='noindent'><object data="svgs/scalable-addition-pf.svg" alt="diagram of scalable-addition-pf" class="svg-diagram"></object> </p></div>
<div class='center'>
<!-- l. 278 --><p class='noindent'>
</p><!-- l. 279 --><p class='noindent'><object data="svgs/scalable-addition-pf1.svg" alt="diagram of scalable-addition-pf1" class="svg-diagram"></object> </p></div>
                                                                   □
                                                                     

                                                                     
   </div>
<!-- l. 283 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='scalable-phase-gadgets'><span class='titlemark'>10.2.1   </span> <a id='x12-24500010.2.1'></a>Scalable phase gadgets</h4>
<!-- l. 284 --><p class='noindent'>Collections of phase gadgets turn out to look quite simple when using scalable
ZX notation. First, let’s see how we can represent a single phase gadget:
</p><table class='equation'><tr><td>
<!-- l. 285 --><p class='indent'>
</p><!-- l. 285 --><object id='x12-245001r17' data="svgs/phase-gadget-to-scalable.svg" alt="diagram of phase-gadget-to-scalable" class="svg-diagram"></object></td><td class='eq-no'>(10.17)</td></tr></table>
<!-- l. 288 --><p class='indent'>   Here <!-- l. 288 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mover accent='true'><mrow><mn>1</mn></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>T</mi> </mrow></msup></math> is the
row vector <!-- l. 288 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mi> </mi><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>,
and hence the matrix arrow represents a collection of Z-spiders
connected to a single X-spider, as needed. If instead the phase gadget
is only connected to a subset of the wires, then we can replace
<!-- l. 288 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mn>1</mn></mrow><mo accent='true'>→</mo></mover></math> by a vector
<!-- l. 288 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>v</mi></mrow><mo accent='true'>→</mo></mover></math> where
<!-- l. 288 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>v</mi></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math> iff the gadget is
connected to the <!-- l. 288 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math>th
qubit. We can then see how we can represent a composition of phase gadgets in
scalable notation: </p><table class='equation'><tr><td>
<!-- l. 289 --><p class='indent'>
</p><!-- l. 289 --><object id='x12-245002r18' data="svgs/scalable-gadget-pair.svg" alt="diagram of scalable-gadget-pair" class="svg-diagram"></object></td><td class='eq-no'>(10.18)</td></tr></table>
                                                                     

                                                                     
<!-- l. 292 --><p class='indent'>   This construction generalises to any number of phase gadgets, for which we
then get: </p><table class='equation'><tr><td>
<!-- l. 293 --><p class='indent'>
</p><!-- l. 293 --><object id='x12-245003r19' data="svgs/eq-phase-gadget-scalable.svg" alt="diagram of eq:phase-gadget-scalable" class="svg-diagram"></object></td><td class='eq-no'>(10.19)</td></tr></table>
<!-- l. 296 --><p class='indent'>   In this <!-- l. 296 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-bin' stretchy='false'>×</mo> <mi>n</mi></mrow></math>
matrix <!-- l. 296 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math>
each of the <!-- l. 296 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
rows describes a phase gadget, and each of the
<!-- l. 296 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math> columns corresponds
to a qubit. Hence, <!-- l. 296 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mrow><mi>M</mi></mrow><mrow><mi>i</mi></mrow><mrow><mi>j</mi></mrow></msubsup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math> iff
the <!-- l. 296 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>j</mi></math>th phase gadget
is connected to the <!-- l. 296 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math>th
qubit. Note that we can prove the gadget fusion rule of Section <a href='main_htmlch7.html#phase-gadgets'>7.1.2<!-- tex4ht:ref: sec:phase-gadgets  --></a> in the
scalable setting using what we have seen. This applies when we have two phase
gadgets with the same connectivity, and hence the same row appears twice in the
matrix: </p><table class='equation'><tr><td>
<!-- l. 298 --><p class='indent'>
</p><!-- l. 298 --><object id='x12-245004r20' data="svgs/eq-scalable-gadget-fusion.svg" alt="diagram of eq:scalable-gadget-fusion" class="svg-diagram"></object></td><td class='eq-no'>(10.20)</td></tr></table>
<!-- l. 301 --><p class='indent'>   Conversely, if we have gadgets with phases that are not
<!-- l. 301 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>, but
multiples of that, we can also represent them like (<a href='#x12-245003r19'>10.19<!-- tex4ht:ref: eq:phase-gadget-scalable  --></a>), by unfusing them into
additional rows of the matrix (doing (<a href='#x12-245004r20'>10.20<!-- tex4ht:ref: eq:scalable-gadget-fusion  --></a>) in reverse).
                                                                     

                                                                     
</p>
   <h3 class='sectionHead' id='rewriting-cliffordt-diagrams'><span class='titlemark'>10.3   </span> <a id='x12-24600010.3'></a>Rewriting Clifford+T diagrams</h3>
<!-- l. 303 --><p class='noindent'>In Chapter <a href='main_htmlch9.html#controlled-gates-and-classical-oracles'>9<!-- tex4ht:ref: ch:midlevel  --></a> in order to construct the Toffoli and CCZ gate using
more low-level gates, in particular T gates, we used a Boolean
Fourier transform to switch from the multilinear phase polynomial
<!-- l. 303 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi mathvariant='italic'>xyz</mi></mrow></msup></math> used
in the CCZ gate to a phase polynomial built out of XOR terms that can be
constructed using phase gadgets. In essence this all boiled down to the equation:
</p><table class='equation'><tr><td>
<!-- l. 305 --><p class='indent'>
</p><!-- l. 305 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
       <mstyle class='label' id='x12-246001r21'></mstyle><!-- endlabel --><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>y</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>z</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>4</mn></mrow></mfrac><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>y</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>z</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>y</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>z</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>y</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>z</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>y</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>z</mi><mo class='MathClass-close' stretchy='false'>)</mo>
</mrow></math></td><td class='eq-no'>(10.21)</td></tr></table>
<!-- l. 308 --><p class='indent'>   We used this equation to argue for the following diagrammatic equality:
</p><table class='equation'><tr><td>
<!-- l. 309 --><p class='indent'>
</p><!-- l. 309 --><object id='x12-246002r22' data="svgs/CCZ.svg" alt="diagram of CCZ" class="svg-diagram"></object></td><td class='eq-no'>(10.22)</td></tr></table>
<!-- l. 312 --><p class='indent'>   But there is nothing special about the phase of the CCZ
gate here, and in fact we can write a similar equation for a
<!-- l. 312 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>CCZ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> gate:
</p><table class='equation'><tr><td>
<!-- l. 313 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 313 --><object id='x12-246003r23' data="svgs/eq-CCZ-alpha-decompose.svg" alt="diagram of eq:CCZ-alpha-decompose" class="svg-diagram"></object></td><td class='eq-no'>(10.23)</td></tr></table>
<!-- l. 316 --><p class='indent'>   Now when <!-- l. 316 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>α</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>
both sides of this equation are obviously equal to the identity (just copy some
spiders and cancel some identity spiders). But this should then also hold for
<!-- l. 316 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>α</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>2</mn><mi>π</mi></mrow></math>, and
then this fact becomes less obvious. On the left-hand side we then have
<!-- l. 316 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mn>2</mn><mi>π</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math> so
that it is still the identity, but on the right-hand side we get a bunch of
<!-- l. 316 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>±</mo><mi>i</mi><mn>2</mn><mi>π</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>4</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>±</mo><mi mathvariant='italic'>iπ</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn></mrow></msup></mrow></math>
phases. In that case we can show this by using the
<!-- l. 316 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Y</mi> </mrow></math>
eigenstate identity of Exercise <a href='main_htmlch3.html#x5-67008r15'>3.15<!-- tex4ht:ref: exer:S-state-equality  --></a>, the Euler decomposition of the Hadamard
and local complementation: </p><table class='equation'><tr><td>
<!-- l. 317 --><p class='indent'>
</p><!-- l. 317 --><object id='x12-246004r24' data="svgs/eq-spider-nest-3-pf.svg" alt="diagram of eq:spider-nest-3-pf" class="svg-diagram"></object></td><td class='eq-no'>(10.24)</td></tr></table>
<!-- l. 320 --><p class='indent'>   In this case we can hence still prove this identity with the tools we have
already seen. But when we generalise Eqs. (<a href='#x12-246001r21'>10.21<!-- tex4ht:ref: eq:Fourier-3-terms  --></a>) and (<a href='#x12-246003r23'>10.23<!-- tex4ht:ref: eq:CCZ-alpha-decompose  --></a>) to work with
more than 3 wires we start getting new and very useful identities. As the number
of XOR terms blows up exponentially it will be helpful to introduce a slightly
more compact way to talk about them. Note that we can represent a parity like
<!-- l. 320 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>4</mn></mrow></msub></mrow></math> with a bit
string <!-- l. 320 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1011</mn></mrow></math>
since <!-- l. 320 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-bin' stretchy='false'>⋅</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>y</mi></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>y</mi></mrow><mrow><mn>2</mn></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>y</mi></mrow><mrow><mn>3</mn></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>y</mi></mrow><mrow><mn>4</mn></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mn>4</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>4</mn></mrow></msub></mrow></math>.
We can hence write Eq. (<a href='#x12-246001r21'>10.21<!-- tex4ht:ref: eq:Fourier-3-terms  --></a>) more compactly as
                                                                     

                                                                     
<!-- tex4ht:inline --></p><!-- l. 321 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
               <msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>4</mn></mrow></mfrac><munder class='msub'><mrow><mo>∑</mo>
   </mrow><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>≠</mo><mover accent='true'><mrow><mn>0</mn></mrow><mo accent='true'>→</mo></mover></mrow></munder><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></msup><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-bin' stretchy='false'>⋅</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math>
<!-- l. 321 --><p class='nopar'> Here <!-- l. 322 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub></mrow></math> and the sum
over the <!-- l. 322 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></math> goes over
all the bit strings <!-- l. 322 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mn>3</mn></mrow></msup></mrow></math>
except for <!-- l. 322 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mn>0</mn></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>000</mn></mrow></math>.
We can then easily write down the generalisation of this equation to
<!-- l. 322 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math> variables
<!-- l. 322 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub></mrow></math> as
follows: </p><table class='equation'><tr><td>
<!-- l. 323 --><p class='indent'>
</p><!-- l. 323 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
              <mstyle class='label' id='x12-246005r25'></mstyle><!-- endlabel --><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⋅</mo><mo>…</mo> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-bin' stretchy='false'>−</mo> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup></mrow></mfrac><munder class='msub'><mrow><mo> ∑</mo>
   </mrow><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>≠</mo><mover accent='true'><mrow><mn>0</mn></mrow><mo accent='true'>→</mo></mover></mrow></munder><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></msup><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-bin' stretchy='false'>⋅</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td><td class='eq-no'>(10.25)</td></tr></table>
<!-- l. 326 --><p class='indent'>   Now if we take <!-- l. 326 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>4</mn></mrow></math>,
and we consider the CCCZ gate, which applies the phase polynomial
<!-- l. 326 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iπ</mi><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mn>4</mn></mrow></msub></mrow></msup></math>, then
applying Eq. (<a href='#x12-246005r25'>10.25<!-- tex4ht:ref: eq:Fourier-general-n  --></a>) would result in a bunch of phase gadgets with a phase of
<!-- l. 326 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>±</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>8</mn></mrow></mfrac> </mrow></math>.
But this is the Clifford+T chapter, so we want
<!-- l. 326 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>±</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>
phases. We can get those by instead considering the trivial phase polynomial
<!-- l. 326 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mn>2</mn><mi mathvariant='italic'>πi</mi><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mn>4</mn></mrow></msub></mrow></msup></math>. This then results
in a constellation of <!-- l. 326 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mn>2</mn></mrow><mrow><mn>4</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>15</mn></mrow></math>
<!-- l. 326 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>±</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>4</mn></mrow></mfrac> </mrow></math> phase
gadgets: </p><table class='equation'><tr><td>
<!-- l. 327 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 327 --><object id='x12-246006r26' data="svgs/eq-spider-nest-4.svg" alt="diagram of eq:spider-nest-4" class="svg-diagram"></object></td><td class='eq-no'>(10.26)</td></tr></table>
<!-- l. 330 --><p class='indent'>   While this might look like some sort of confusing alien spacecraft,
there is some order to the picture above: it contains all the
possible phase gadgets on four qubits: all those with one leg (the
<!-- l. 330 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>
phases directly on the qubit wires), two legs, three legs, and the single
four-legged one. All the gadgets with an odd number of legs have a phase of
<!-- l. 330 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>,
and all the gadgets with an even number of legs have a phase of
<!-- l. 330 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>.
Eq. (<a href='#x12-246006r26'>10.26<!-- tex4ht:ref: eq:spider-nest-4  --></a>) is a genuinely new diagrammatic equation, a type of equation
we call a <span class='cmbx-10x-x-109'>spider-nest identity</span>. As we will see in this chapter and the
next, there are many uses of such equations. As a first application, note
that if we bring the four-legged phase gadget to the other side of the
equation that this says that whenever we have a four-legged gadget with a
<!-- l. 332 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>±</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>4</mn></mrow></mfrac> </mrow></math> phase,
we can replace it by a collection of 14 three-, two- and one-legged phase gadgets
involving all of the four-legged phase gadget’s legs. In fact, we can decompose any
<!-- l. 332 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-legged phase gadget
with a phase of <!-- l. 332 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>±</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>
into a collection of phase gadgets with a most 3 legs. For instance, when
<!-- l. 332 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>5</mn></mrow></math>:
</p><table class='equation'><tr><td>
<!-- l. 333 --><p class='indent'>
</p><!-- l. 333 --><object id='x12-246007r27' data="svgs/spider-nest-5.svg" alt="diagram of spider-nest-5" class="svg-diagram"></object></td><td class='eq-no'>(10.27)</td></tr></table>
                                                                     

                                                                     
<!-- l. 336 --><p class='indent'>   So while we would a priori think that we could need
<!-- l. 336 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
different phase gadgets, one for each possible parity, we see that we actually only
need <!-- l. 336 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>n</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>,
only those with at most three legs. A different use-case for
Eq. (<a href='#x12-246006r26'>10.26<!-- tex4ht:ref: eq:spider-nest-4  --></a>) is that we can use it to optimise the number of
<!-- l. 337 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates
needed for a circuit. When we have a collection of phase gadgets with
<!-- l. 337 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>
phases we can look for any subset of four qubits that has many phase
gadgets and then use a version of Eq. (<a href='#x12-246006r26'>10.26<!-- tex4ht:ref: eq:spider-nest-4  --></a>) where we have those
phase gadgets on the left and all the other parities on the right. Then
by applying this equation we essentially ‘toggle’ which phase gadgets
on these four qubits were present. As long as we started out with at
least half of all the possible phase gadgets present, so at least 8, we end
up with fewer phase gadgets. If we had 8 phase gadgets, then we get
<!-- l. 337 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>15</mn> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>8</mn> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>7</mn></mrow></math> phase gadgets at the end.
If we had <!-- l. 337 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>10</mn></mrow></math>, then we end
up with <!-- l. 337 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>15</mn> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>10</mn> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>5</mn></mrow></math> of them. The
exact phases, whether <!-- l. 337 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>+</mo> <mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>
or <!-- l. 337 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>4</mn></mrow></mfrac> </mrow></math> is
not important for this, since if the signs don’t match, this just introduces a
<!-- l. 337 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>
Clifford phase gadget.
</p>
   <div class='newtheorem'>
<!-- l. 338 --><p class='noindent'><span class='head'>
<a id='x12-246008r4'></a>
<span class='cmbx-10x-x-109'>Exercise 10.4.</span>
</span> In  Eq. (<a href='#x12-246006r26'>10.26<!-- tex4ht:ref: eq:spider-nest-4  --></a>)  the  two-legged  and  four-legged  phase  gadgets  have  a
<!-- l. 339 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>
phase.             Show            that            by            unfusing            a
<!-- l. 339 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>
phase gadget from the four-legged one and applying a set of rewrites similar
to those in Eq. (<a href='#x12-246004r24'>10.24<!-- tex4ht:ref: eq:spider-nest-3-pf  --></a>) that we can rewrite it to a collection of phase gadgets
all                                           having                                           a
<!-- l. 339 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>+</mo> <mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>
phase.
</p>
   </div>
<!-- l. 340 --><p class='indent'>
                                                                     

                                                                     
</p>
   <h4 class='subsectionHead' id='spider-nests-as-strongly-even-matrices'><span class='titlemark'>10.3.1   </span> <a id='x12-24700010.3.1'></a>Spider nests as strongly 3-even matrices</h4>
<!-- l. 342 --><p class='noindent'>Using scalable ZX notation, we can represent a collection of phase gadgets using
a parity matrix to describe the connectivity of the gadgets as in (<a href='#x12-245003r19'>10.19<!-- tex4ht:ref: eq:phase-gadget-scalable  --></a>).
The 4-qubit spider nest identity of Eq. (<a href='#x12-246006r26'>10.26<!-- tex4ht:ref: eq:spider-nest-4  --></a>) with 15 gadgets (more
specifically, the modified version of Exercise <a href='#x12-246008r4'>10.4<!-- tex4ht:ref: exer:spider-nest-all-positive  --></a> where all the phases are
<!-- l. 343 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>+</mo> <mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>4</mn></mrow></mfrac> </mrow></math> so
that we can get rid of the repeated rows) then corresponds to the following
<!-- l. 343 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>15</mn> <mo class='MathClass-bin' stretchy='false'>×</mo> <mn>4</mn></mrow></math>
matrix: </p><table class='equation'><tr><td>
<!-- l. 344 --><p class='indent'>
</p><!-- l. 344 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mstyle class='label' id='x12-247001r28'></mstyle><!-- endlabel --><msup><mrow> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn></mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                      </mrow><mo fence='true' form='postfix'>)</mo></mrow></mrow><mrow><mi>T</mi> </mrow></msup>
</mrow></math></td><td class='eq-no'>(10.28)</td></tr></table>
<!-- l. 352 --><p class='indent'>   Note that we write here the transpose of the matrix to use the space on the
page a bit better. Any spider nest identity will be an identity of the form:
</p><table class='equation'><tr><td>
<!-- l. 354 --><p class='indent'>
</p><!-- l. 354 --><object id='x12-247002r29' data="svgs/phase-gadget-scalable.svg" alt="diagram of phase-gadget-scalable" class="svg-diagram"></object></td><td class='eq-no'>(10.29)</td></tr></table>
<!-- l. 357 --><p class='indent'>   This means that when hunting for such identities, we are really looking for a
particular type of boolean matrix. To find out what kind of matrices we need, we
need to look at the pseudo-Boolean Fourier transform again. This time however,
we want to translate phase gadgets back into controlled phase gates. The
‘inverse’ of the equation (<a href='#x12-246005r25'>10.25<!-- tex4ht:ref: eq:Fourier-general-n  --></a>) which relates an AND to a sum of XORs is
given by: </p><table class='equation'><tr><td>
                                                                     

                                                                     
<!-- l. 358 --><p class='indent'>
</p><!-- l. 358 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
               <mstyle class='label' id='x12-247003r30'></mstyle><!-- endlabel --><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo><mo class='MathClass-rel' stretchy='false'>⋯</mo> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo><munder class='msub'><mrow><mo> ∑</mo>
   </mrow><mrow><mi>S</mi><mo class='MathClass-rel' stretchy='false'>⊆</mo><mo class='MathClass-open' stretchy='false'>[</mo><mi>n</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></munder><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mn>2</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>S</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup><munder class='msub'><mrow><mo> ∏</mo>
  </mrow><mrow><mi>i</mi><mo class='MathClass-rel' stretchy='false'>∈</mo><mi>S</mi></mrow></munder><msub><mrow><mi>x</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td><td class='eq-no'>(10.30)</td></tr></table>
<!-- l. 361 --><p class='indent'>   Here <!-- l. 361 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mi>n</mi><mo class='MathClass-close' stretchy='false'>]</mo> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>{</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><mi>n</mi><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>, and
<!-- l. 361 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>S</mi><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math> is the number of
elements of <!-- l. 361 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>. Hence,
each term <!-- l. 361 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi class='MathClass-op'>∏</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>i</mi><mo class='MathClass-rel' stretchy='false'>∈</mo><mi>S</mi></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>x</mi></mrow><mrow><msub><mrow><mi>i</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></msub> <mo class='MathClass-bin' stretchy='false'>∧</mo><mo class='MathClass-rel' stretchy='false'>⋯</mo> <mo class='MathClass-bin' stretchy='false'>∧</mo> <msub><mrow><mi>x</mi></mrow><mrow><msub><mrow><mi>i</mi></mrow><mrow><mi>k</mi></mrow></msub></mrow></msub></mrow></math> has a weight
that is a power of <!-- l. 361 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>2</mn></math>
in the decomposition. Now, if we are considering this in a
phase polynomial, where our phase gadget has a coefficient of
<!-- l. 361 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>,
then in the decomposition the different terms will have a weight of
<!-- l. 361 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>±</mo> <msup><mrow><mn>2</mn></mrow><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>S</mi><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></msup><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>8</mn></mrow></mfrac> </mrow></math>.
Since these are phases, we are working modulo
<!-- l. 361 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>2</mn><mi>π</mi></mrow></math> so that when
<!-- l. 361 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>S</mi><mo class='MathClass-rel' stretchy='false'>|</mo> <mo class='MathClass-rel' stretchy='false'>&gt;</mo> <mn>3</mn></mrow></math> each term is
a multiple of <!-- l. 361 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>2</mn><mi>π</mi></mrow></math>
and disappears:
</p><!-- tex4ht:inline --><!-- l. 365 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mtable class='align' columnalign='left' displaystyle='true'>
<mtr><mtd class='align-odd' columnalign='right'><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> <msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>⊕</mo><mo class='MathClass-rel' stretchy='false'>⋯</mo><mo class='MathClass-bin' stretchy='false'>⊕</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub>
               </mrow></msup><mspace class='nbsp' width='0.33em'></mspace></mtd><mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mi class='qopname'>exp</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mi>i</mi> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac><munder class='msub'><mrow><mo>∑</mo>
   </mrow><mrow><mi>j</mi></mrow></munder><msub><mrow><mi>x</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>2</mn></mrow></mfrac><munder class='msub'><mrow><mo>∑</mo>
   </mrow><mrow><mi>i</mi><mo class='MathClass-rel' stretchy='false'>&lt;</mo><mi>j</mi></mrow></munder><msub><mrow><mi>x</mi></mrow><mrow><mi>i</mi></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>π</mi><munder class='msub'><mrow><mo>∑</mo>
   </mrow><mrow><mi>i</mi><mo class='MathClass-rel' stretchy='false'>&lt;</mo><mi>j</mi><mo class='MathClass-rel' stretchy='false'>&lt;</mo><mi>k</mi></mrow></munder><msub><mrow><mi>x</mi></mrow><mrow><mi>i</mi></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mi>j</mi></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>2</mn><mi>π</mi><mo class='MathClass-rel' stretchy='false'>⋯</mo><mspace class='thinspace' width='0.17em'></mspace></mrow><mo fence='true' form='postfix'>)</mo></mrow></mrow><mo fence='true' form='postfix'>)</mo></mrow><mspace width='2em'></mspace></mtd><mtd class='align-label' columnalign='right'></mtd><mtd class='align-label'>
<mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>          <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mi class='qopname'>exp</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mi>i</mi> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac><munder class='msub'><mrow><mo>∑</mo>
   </mrow><mrow><mi>j</mi></mrow></munder><msub><mrow><mi>x</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>2</mn></mrow></mfrac><munder class='msub'><mrow><mo>∑</mo>
   </mrow><mrow><mi>i</mi><mo class='MathClass-rel' stretchy='false'>&lt;</mo><mi>j</mi></mrow></munder><msub><mrow><mi>x</mi></mrow><mrow><mi>i</mi></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>π</mi><munder class='msub'><mrow><mo>∑</mo>
   </mrow><mrow><mi>i</mi><mo class='MathClass-rel' stretchy='false'>&lt;</mo><mi>j</mi><mo class='MathClass-rel' stretchy='false'>&lt;</mo><mi>k</mi></mrow></munder><msub><mrow><mi>x</mi></mrow><mrow><mi>i</mi></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mi>j</mi></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub></mrow><mo fence='true' form='postfix'>)</mo></mrow></mrow><mo fence='true' form='postfix'>)</mo></mrow><mspace width='2em'></mspace></mtd>      <mtd class='align-label' columnalign='right'>
<mstyle class='label' id='x12-247004r31'></mstyle><!-- endlabel --><mstyle class='maketag'><mtext>(10.31)</mtext></mstyle><mspace class='nbsp' width='0.33em'></mspace>
   </mtd></mtr></mtable></math>
<!-- l. 366 --><p class='noindent'>Hence, each phase gadget corresponds to a collection of
<!-- l. 366 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates
(the linear terms), CS gates (quadratic terms) and CCZ terms (cubic terms).
                                                                     

                                                                     
</p><table class='equation'><tr><td>
<!-- l. 367 --><p class='indent'>
</p><!-- l. 367 --><object id='x12-247005r32' data="svgs/gadget-as-monomial.svg" alt="diagram of gadget-as-monomial" class="svg-diagram"></object></td><td class='eq-no'>(10.32)</td></tr></table>
<!-- l. 370 --><p class='indent'>   If instead of a single gadget we have a collection of phase gadgets, then we can add together
the respective <!-- l. 370 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>T</mi><mo class='MathClass-punc' stretchy='false'>,</mo></mrow></math>
CS and CCZ gates of their decompositions. It turns out that such
a circuit can only be equal to the identity if all the gates cancel
in the trivial way. That is, each qubit should have a number of
<!-- l. 370 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates that is
multiple of 8 since <!-- l. 370 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>T</mi></mrow><mrow><mn>8</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi></mrow></math>,
each pair of qubits should have a multiple of 4 CS gates and each triple should
have an even number of CCZ gates.
</p>
   <div class='newtheorem'>
<!-- l. 371 --><p class='noindent'><span class='head'>
<a id='x12-247006r5'></a>
<span class='cmbx-10x-x-109'>Exercise 10.5.</span>  </span> Let <!-- l. 372 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>C</mi></math>
be a circuit consisting of <!-- l. 372 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>,
CS and CCZ gates and suppose we have done all trivial cancellations as
described above. Show that if <!-- l. 372 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>C</mi></math>
implements the identity, that then <!-- l. 372 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>C</mi></math>
must be the empty circuit. <span class='cmti-10x-x-109'>Hint: First consider input states </span><!-- l. 373 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
<span class='cmti-10x-x-109'>with Hamming weight 1 to show using </span><!-- l. 373 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>C</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
<span class='cmti-10x-x-109'>that there can’t be any </span><!-- l. 373 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
<span class='cmti-10x-x-109'>gates, then consider inputs with Hamming weight 2 to show there can’t be
CS gates, and finally consider input states with Hamming weight 3 to rule
out CCZ gates.</span>
</p>
   </div>
<!-- l. 374 --><p class='indent'>    From Eq. (<a href='#x12-247004r31'>10.31<!-- tex4ht:ref: eq:XOR-decompose  --></a>) we see that if a phase gadget involves the qubit
<!-- l. 375 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>j</mi></math>, that
                                                                     

                                                                     
then a <!-- l. 375 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gate appears on that qubit. If it connects to both qubits
<!-- l. 375 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>j</mi></mrow><mrow><mn>1</mn></mrow></msub></math> and
<!-- l. 375 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>j</mi></mrow><mrow><mn>2</mn></mrow></msub></math> then there
will be a CS gate on those qubits, and similarly a CCZ appears when the qubits
<!-- l. 375 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>j</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>j</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></math> and
<!-- l. 375 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>j</mi></mrow><mrow><mn>3</mn></mrow></msub></math> are in the phase
gadget. Hence, a collection of phase gadget implements the identity when each qubit is part
of <!-- l. 375 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>0</mn><mspace class='nbsp' width='0.33em'></mspace><mstyle class='text'><mtext>mod </mtext></mstyle><mn>8</mn></mrow></math> gadgets
(<!-- l. 375 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>T</mi></mrow><mrow><mn>8</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi></mrow></math>), each pair of
qubits is part of <!-- l. 375 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>0</mn><mspace class='nbsp' width='0.33em'></mspace><mstyle class='text'><mtext>mod </mtext></mstyle><mn>4</mn></mrow></math>
gadgets (<!-- l. 375 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mstyle class='text'><mtext>CS</mtext></mstyle></mrow><mrow><mn>4</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi></mrow></math>), and each
triple is part of <!-- l. 375 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>0</mn><mspace class='nbsp' width='0.33em'></mspace><mstyle class='text'><mtext>mod </mtext></mstyle><mn>2</mn></mrow></math>
gadgets (<!-- l. 375 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mstyle class='text'><mtext>CCZ</mtext></mstyle></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi></mrow></math>).
We can formalise this cancellation property as follows.
</p>
   <div class='newtheorem'>
<!-- l. 377 --><p class='noindent'><span class='head'>
<a id='x12-247007r1'></a>
<span class='cmbx-10x-x-109'>Definition 10.3.1.</span>  </span>We say a matrix
<!-- l. 378 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math> is
<span class='cmbx-10x-x-109'>strongly 3-even </span>when
</p><!-- tex4ht:inline --><!-- l. 383 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mtable class='align-star' columnalign='left' displaystyle='true'>
                <mtr><mtd class='align-odd' columnalign='right'><mi class='MathClass-op'>∀</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mi>i</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><munder class='msub'><mrow><mo> ∑</mo>
   </mrow><mrow><mi>l</mi></mrow></munder><msubsup><mrow><mi>M</mi></mrow><mrow><mi>i</mi></mrow><mrow><mi>l</mi></mrow></msubsup></mtd>                                <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn><mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='text'><mtext>mod </mtext></mstyle><mn>8</mn><mo class='MathClass-close' stretchy='false'>)</mo><mspace width='2em'></mspace></mtd>                 <mtd class='align-label' columnalign='right'></mtd>                <mtd class='align-label'>
                <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'><mi class='MathClass-op'>∀</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mi>i</mi> <mo class='MathClass-rel' stretchy='false'>&lt;</mo> <mi>j</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><munder class='msub'><mrow><mo> ∑</mo>
   </mrow><mrow><mi>l</mi></mrow></munder><msubsup><mrow><mi>M</mi></mrow><mrow><mi>i</mi></mrow><mrow><mi>l</mi></mrow></msubsup><msubsup><mrow><mi>M</mi></mrow><mrow>
<mi>j</mi></mrow><mrow><mi>l</mi></mrow></msubsup></mtd>                        <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn><mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='text'><mtext>mod </mtext></mstyle><mn>4</mn><mo class='MathClass-close' stretchy='false'>)</mo><mspace width='2em'></mspace></mtd>                 <mtd class='align-label' columnalign='right'></mtd>                <mtd class='align-label'>
                <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'><mi class='MathClass-op'>∀</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mi>i</mi> <mo class='MathClass-rel' stretchy='false'>&lt;</mo> <mi>j</mi> <mo class='MathClass-rel' stretchy='false'>&lt;</mo> <mi>k</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><munder class='msub'><mrow><mo> ∑</mo>
   </mrow><mrow><mi>l</mi></mrow></munder><msubsup><mrow><mi>M</mi></mrow><mrow><mi>i</mi></mrow><mrow><mi>l</mi></mrow></msubsup><msubsup><mrow><mi>M</mi></mrow><mrow>
<mi>j</mi></mrow><mrow><mi>l</mi></mrow></msubsup><msubsup><mrow><mi>M</mi></mrow><mrow>
<mi>k</mi></mrow><mrow><mi>l</mi></mrow></msubsup></mtd>                <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn><mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='text'><mtext>mod </mtext></mstyle><mn>2</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-punc' stretchy='false'>.</mo><mspace width='2em'></mspace></mtd>                <mtd class='align-label' columnalign='right'></mtd>                <mtd class='align-label'>
   <mspace width='2em'></mspace></mtd></mtr></mtable></math>
<!-- l. 384 --><p class='noindent'>That is, when each column, product of pairs of columns and product of triples of
columns has a Hamming weight that is a multiple of respectively 8, 4 and 2. We
say <!-- l. 384 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math> is
<span class='cmbx-10x-x-109'>3-even </span>when all three conditions only hold modulo 2.
                                                                     

                                                                     
</p>
   </div>
<!-- l. 385 --><p class='indent'>    When we represent a collection of
<!-- l. 386 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>π</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>4</mn></mrow></math> phase gadgets as a
set of bit strings <!-- l. 386 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msup><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>m</mi></mrow></msup></mrow></math>,
where <!-- l. 386 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mrow><mi>y</mi></mrow><mrow><mi>i</mi></mrow><mrow><mi>l</mi></mrow></msubsup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math> means the
<!-- l. 386 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>l</mi></math>th phase gadget is
connected to the <!-- l. 386 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math>th
qubit and set the matrix <!-- l. 386 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mrow><mi>M</mi></mrow><mrow><mi>i</mi></mrow><mrow><mi>j</mi></mrow></msubsup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msubsup><mrow><mi>y</mi></mrow><mrow><mi>i</mi></mrow><mrow><mi>j</mi></mrow></msubsup></mrow></math>
we see that <!-- l. 386 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math>
is strongly 3-even precisely when the gadgets make a spider nest.
</p>
   <div class='newtheorem'>
<!-- l. 387 --><p class='noindent'><span class='head'>
<a id='x12-247008r2'></a>
<span class='cmbx-10x-x-109'>Proposition 10.3.2.</span>  </span>Let <!-- l. 388 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math>
be a <!-- l. 388 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-bin' stretchy='false'>×</mo> <mi>n</mi></mrow></math>
boolean matrix. Then </p><table class='equation-star'><tr><td>
<!-- l. 389 --><object data="svgs/phase-gadget-scalable.svg" alt="diagram of phase-gadget-scalable" class="svg-diagram"></object></td></tr></table>
<!-- l. 392 --><p class='indent'>   if                           and                           only                           if
<!-- l. 392 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math>
is strongly 3-even.
</p>
   </div>
<!-- l. 393 --><p class='indent'>    Being just 3-even, as opposed to strongly 3-even, is a weaker
condition that means the collection of gadgets is not exactly equal to the
identity, but instead are equal to some Clifford unitary: instead of the
<!-- l. 394 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates exactly cancelling due to them appearing a multiple of
<!-- l. 394 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>8</mn></math> times, they only
                                                                     

                                                                     
appear a multiple of <!-- l. 394 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>2</mn></math>
times on each qubit and hence combine into
<!-- l. 394 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>T</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>S</mi></mrow></math> gates,
which are Clifford. Similarly, the CS gates appear an even number of times to
create CZ gates, and the CCZ gates still completely cancel. For convenience we
will also call a set of gadgets that is equal to a Clifford (and hence corresponds to
a 3-even matrix) a spider nest identity. We can find which Clifford it implements
by rewriting all the gadgets using Eq. (<a href='#x12-247004r31'>10.31<!-- tex4ht:ref: eq:XOR-decompose  --></a>). However, if we have gadgets with
many legs this can involve exponentially many terms. There is also an efficient
way to do it.
</p>
   <div class='newtheorem'>
<!-- l. 396 --><p class='noindent'><span class='head'>
<a id='x12-247009r6'></a>
<span class='cmbx-10x-x-109'>Exercise 10.6.</span>  </span> Describe an efficient procedure that determines the stabiliser
tableau for a circuit consisting of <!-- l. 397 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>
phase gadgets with the promise that it implements a Clifford unitary. <span class='cmti-10x-x-109'>Hint: It
is diagonal, so all the Pauli </span><!-- l. 398 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math><span class='cmti-10x-x-109'>’s
trivially commute through. Pushing an </span><!-- l. 398 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>
<span class='cmti-10x-x-109'>through the circuit however results in some additional </span><!-- l. 398 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>
<span class='cmti-10x-x-109'>phase gadgets that can be commuted to the end. If the unitary is Clifford
these should all be decomposable into Paulis.</span>
</p>
   </div>
<!-- l. 399 --><p class='indent'>
</p>
   <h4 class='subsectionHead' id='proving-all-spider-nest-identities'><span class='titlemark'>10.3.2   </span> <a id='x12-24800010.3.2'></a>Proving all spider nest identities</h4>
<!-- l. 401 --><p class='noindent'>We can now see when a collection of phase gadgets is a spider nest identity: check
whether its associated parity matrix is strongly 3-even. Diagrammatically this is
not very satisfying however, as it doesn’t tell us how to find strongly 3-even
matrices or what is required to diagrammatically prove all these identities. In this
section we will see that we can build all spider nest identities from one
particular one. To do so, we need to go back to the 4-qubit spider nest
Eq. (<a href='#x12-246006r26'>10.26<!-- tex4ht:ref: eq:spider-nest-4  --></a>) which we arrived at by decomposing the ‘trivial’ phase polynomial
<!-- l. 404 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mn>2</mn><mi mathvariant='italic'>πi</mi><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>4</mn></mrow></msub></mrow></msup></math> into phase
gadgets using Eq. (<a href='#x12-246005r25'>10.25<!-- tex4ht:ref: eq:Fourier-general-n  --></a>). We can similarly get a 5-qubit spider nest by decomposing
<!-- l. 405 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mn>4</mn><mi mathvariant='italic'>πi</mi><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>5</mn></mrow></msub></mrow></msup></math>. This then will have
<!-- l. 405 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mn>2</mn></mrow><mrow><mn>5</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>31</mn></mrow></math> different phase gadgets.
Note the factor of <!-- l. 406 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>4</mn><mi>π</mi></mrow></math> instead
                                                                     

                                                                     
of <!-- l. 406 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>2</mn><mi>π</mi></mrow></math> which is needed
to get a collection of <!-- l. 406 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>±</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>
phases instead of <!-- l. 406 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>±</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>8</mn></mrow></mfrac> </mrow></math>
phases. We can in the same way build an
<!-- l. 407 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit spider nest by
decomposing <!-- l. 407 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>3</mn></mrow></msup><mi mathvariant='italic'>πi</mi><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub>
                 </mrow></msup></math>, which will
result in a spider nest with <!-- l. 407 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math>
phase gadgets with a <!-- l. 407 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>±</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>
phase. Now, let’s take the 5-qubit spider nest, and then ‘subtract’ the 4-qubit
spider nest from it: </p><table class='equation'><tr><td>
<!-- l. 409 --><p class='indent'>
</p><!-- l. 409 --><object id='x12-248001r33' data="svgs/eq-spider-nest-5-4.svg" alt="diagram of eq:spider-nest-5-4" class="svg-diagram"></object></td><td class='eq-no'>(10.33)</td></tr></table>
<!-- l. 412 --><p class='indent'>   Here on the left-hand side we first have all the phase gadgets on five qubits,
but then we subtract from those all the phase gadgets that don’t act on the first
qubit. On the right-hand side we are then left with precisely those phase
gadgets that <span class='cmti-10x-x-109'>do </span>involve the first qubit. These are hence the parities like
<!-- l. 412 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub></math>,
<!-- l. 412 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></math>, …,
<!-- l. 412 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>4</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>5</mn></mrow></msub></mrow></math>.
Since these parities can involve any combination of the other four qubits, there
are <!-- l. 412 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mn>2</mn></mrow><mrow><mn>4</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>16</mn></mrow></math>
such parities (or alternatively you can see that we subtract
<!-- l. 412 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>15</mn></mrow></math> parities from
<!-- l. 412 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>31</mn></mrow></math> parities in Eq. (<a href='#x12-248001r33'>10.33<!-- tex4ht:ref: eq:spider-nest-5-4  --></a>)
to arrive at <!-- l. 412 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>16</mn></mrow></math>
parities).
</p>
   <div class='newtheorem'>
<!-- l. 413 --><p class='noindent'><span class='head'>
<a id='x12-248002r7'></a>
<span class='cmbx-10x-x-109'>Exercise 10.7.</span>  </span>Generalise Exercise <a href='#x12-246008r4'>10.4<!-- tex4ht:ref: exer:spider-nest-all-positive  --></a> by showing that for any <!-- l. 414 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mn>4</mn></mrow></math>,
the collection of all phase gadgets with phase <!-- l. 414 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>+</mo> <mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>
                                                                     

                                                                     
is the identity. Use this to argue that in the identities described above where
we subtract two fully connected spider nests from each other we also get an
identity that only has positive <!-- l. 414 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>+</mo> <mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>
phases.
</p>
   </div>
<!-- l. 415 --><p class='indent'>    It is this 16-gadget identity (<a href='#x12-248001r33'>10.33<!-- tex4ht:ref: eq:spider-nest-5-4  --></a>) that turns out to generate all the
other ones. We need to do some work to see that though. The first step
is to construct such collections of phase gadgets in a more systematic
way.
</p>
   <div class='newtheorem'>
<!-- l. 418 --><p class='noindent'><span class='head'>
<a id='x12-248003r3'></a>
<span class='cmbx-10x-x-109'>Definition 10.3.3.</span>  </span> The <span class='cmti-10x-x-109'>spider-nest maps</span>
<!-- l. 419 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>s</mi></mrow><mrow><mi>n</mi></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo> <mn>1</mn> <mo class='MathClass-rel' stretchy='false'>→</mo> <mi>n</mi></mrow></math> are
constructed inductively as follows: </p><table class='equation'><tr><td>
<!-- l. 420 --><p class='indent'>
</p><!-- l. 420 --><object id='x12-248004r34' data="svgs/eq-sn-def.svg" alt="diagram of eq:sn-def" class="svg-diagram"></object></td><td class='eq-no'>(10.34)</td></tr></table>
   </div>
<!-- l. 423 --><p class='indent'>    Intuitively, this inductive definition results in a phase gadget connecting
the single input wire to every subset of the output wires. For example:
</p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 425 --><object data="svgs/sn-map-s1-sm.svg" alt="diagram of sn-map-s1-sm" class="svg-diagram"></object></td></tr></table>
   <table class='equation-star'><tr><td>
<!-- l. 428 --><object data="svgs/sn-map-s2-sm.svg" alt="diagram of sn-map-s2-sm" class="svg-diagram"></object></td></tr></table>
<!-- l. 431 --><p class='indent'>   where the last step follows from applying strong complementarity
to the marked spider pair, and then applying spider fusion
<!-- l. 431 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='label' xlink:href='main_htmlch3.html#x5-580020' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'><mstyle mathvariant='bold'><mi>sp</mi></mstyle></mstyle><!-- endlabel --><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
as much as possible. Let’s formalise this intuitive explanation of
<!-- l. 432 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>s</mi></mrow><mrow><mi>n</mi></mrow></msub></math> using scalable
notation. Let <!-- l. 432 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>B</mi></mrow><mrow><mi>n</mi></mrow></msub></math>
be the <!-- l. 432 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>×</mo> <msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></math> matrix
whose <!-- l. 432 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></math> rows
consist of all <!-- l. 432 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-bit
strings. That is, the matrix defined inductively as follows: </p><table class='equation-star'><tr><td>
<!-- l. 433 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow>
<mi>B</mi></mrow><mrow><mn>0</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-close' stretchy='false'>)</mo><mspace class='qquad' width='2em'></mspace><mspace class='qquad' width='2em'></mspace><msub><mrow><mi>B</mi></mrow><mrow><mi>n</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo>  <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <msub><mrow><mi>B</mi></mrow><mrow><mi>n</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msub>  </mtd><mtd class='array-td' columnalign='center'>  <mover accent='true'><mrow><mn>0</mn></mrow><mo accent='true'>→</mo></mover> </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <msub><mrow><mi>B</mi></mrow><mrow><mi>n</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msub>  </mtd><mtd class='array-td' columnalign='center'>  <mover accent='true'><mrow><mn>1</mn></mrow><mo accent='true'>→</mo></mover> </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                    </mrow><mo fence='true' form='postfix'>)</mo></mrow>
</mrow></math></td></tr></table>
<!-- l. 441 --><p class='indent'>   where <!-- l. 441 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mn>0</mn></mrow><mo accent='true'>→</mo></mover></math> and
<!-- l. 441 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mn>1</mn></mrow><mo accent='true'>→</mo></mover></math> are respectively the
                                                                     

                                                                     
column vectors of all <!-- l. 441 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math>’s
and all <!-- l. 441 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>’s.
For example, we have: </p><table class='equation'><tr><td>
<!-- l. 442 --><p class='indent'>
</p><!-- l. 442 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mstyle class='label' id='x12-248005r35'></mstyle><!-- endlabel --><msub><mrow><mi>B</mi></mrow><mrow><mn>1</mn></mrow></msub><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn></mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                           </mrow><mo fence='true' form='postfix'>)</mo></mrow><mspace class='qquad' width='2em'></mspace><mspace class='quad' width='1em'></mspace><msub><mrow><mi>B</mi></mrow><mrow><mn>2</mn></mrow></msub><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn></mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                       </mrow><mo fence='true' form='postfix'>)</mo></mrow>
</mrow></math></td><td class='eq-no'>(10.35)</td></tr></table>
   <div class='newtheorem'>
<!-- l. 452 --><p class='noindent'><span class='head'>
<a id='x12-248006r4'></a>
<span class='cmbx-10x-x-109'>Lemma 10.3.4.</span>  </span> For all <!-- l. 453 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>,
we have: </p><table class='equation'><tr><td>
<!-- l. 454 --><p class='indent'>
</p><!-- l. 454 --><object id='x12-248007r36' data="svgs/eq-sn-char.svg" alt="diagram of eq:sn-char" class="svg-diagram"></object></td><td class='eq-no'>(10.36)</td></tr></table>
   </div>
<!-- l. 457 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 459 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>First, note that: </p><table class='equation'><tr><td>
<!-- l. 460 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 460 --><object id='x12-248008r37' data="svgs/eq-bitstring-rep-pf.svg" alt="diagram of eq:bitstring-rep-pf" class="svg-diagram"></object></td><td class='eq-no'>(10.37)</td></tr></table>
   <table class='equation-star'><tr><td>
<!-- l. 463 --><object data="svgs/bitstring-rep-pf2.svg" alt="diagram of bitstring-rep-pf2" class="svg-diagram"></object></td></tr></table>
<!-- l. 466 --><p class='indent'>   Using this equation and the scalable rules, we can prove (<a href='#x12-248007r36'>10.36<!-- tex4ht:ref: eq:sn-char  --></a>) from (<a href='#x12-248004r34'>10.34<!-- tex4ht:ref: eq:sn-def  --></a>) by
induction on <!-- l. 466 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>:
</p><table class='equation-star'><tr><td>
<!-- l. 467 --><object data="svgs/sn-char-induc-pf1.svg" alt="diagram of sn-char-induc-pf1" class="svg-diagram"></object></td></tr></table>
   <table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 470 --><object data="svgs/sn-char-induc-pf2.svg" alt="diagram of sn-char-induc-pf2" class="svg-diagram"></object></td></tr></table>
   <table class='equation-star'><tr><td>
<!-- l. 473 --><object data="svgs/sn-char-induc-pf3.svg" alt="diagram of sn-char-induc-pf3" class="svg-diagram"></object></td></tr></table>
                                                                   □
   </div>
<!-- l. 477 --><p class='indent'>   Now, we can put <!-- l. 477 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>s</mi></mrow><mrow><mn>4</mn></mrow></msub></math>
in a circuit and it can represent exactly the 16-gadget 5-qubit identity (<a href='#x12-248001r33'>10.33<!-- tex4ht:ref: eq:spider-nest-5-4  --></a>):
</p><table class='equation'><tr><td>
<!-- l. 478 --><p class='indent'>
</p><!-- l. 478 --><object id='x12-248009r38' data="svgs/eq-s4-as-gadgets.svg" alt="diagram of eq:s4-as-gadgets" class="svg-diagram"></object></td><td class='eq-no'>(10.38)</td></tr></table>
<!-- l. 481 --><p class='indent'>   By plugging <img src="svgs/ketplus-1.svg" alt="diagram of ketplus-1" class="inline-diagram" /> into all the inputs and yanking the
first output to be an input we can present this in a slightly simpler way:
</p><table class='equation'><tr><td>
<!-- l. 484 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 484 --><object id='x12-248010r39' data="svgs/eq-s4-rule.svg" alt="diagram of eq:s4-rule" class="svg-diagram"></object></td><td class='eq-no'>(10.39)</td></tr></table>
<!-- l. 487 --><p class='indent'>   We call this the <span class='cmbx-10x-x-109'>(S4) rule</span>, and it is enough to prove
all the spider nest identities. First, let’s note that because
<!-- l. 488 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>s</mi></mrow><mrow><mn>4</mn></mrow></msub></math> disconnects,
all the <!-- l. 488 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>s</mi></mrow><mrow><mi>n</mi></mrow></msub></math>
for <!-- l. 488 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mn>4</mn></mrow></math>
also disconnect.
</p>
   <div class='newtheorem'>
<!-- l. 489 --><p class='noindent'><span class='head'>
<a id='x12-248011r5'></a>
<span class='cmbx-10x-x-109'>Lemma 10.3.5.</span>  </span> For <!-- l. 490 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mn>4</mn></mrow></math>,
the Clifford ZX-calculus augmented with the S4 rule implies: </p><table class='equation'><tr><td>
<!-- l. 491 --><p class='indent'>
</p><!-- l. 491 --><object id='x12-248012r40' data="svgs/eq-sn-sep.svg" alt="diagram of eq:sn-sep" class="svg-diagram"></object></td><td class='eq-no'>(10.40)</td></tr></table>
   </div>
<!-- l. 494 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 495 --><p class='noindent'><span class='head'>
<a id='x12-248013r8'></a>
                                                                     

                                                                     
<span class='cmbx-10x-x-109'>Exercise 10.8.</span>  </span>Prove        Lemma <a href='#x12-248011r5'>10.3.5<!-- tex4ht:ref: lem:sn-sep  --></a>        by        induction        on
<!-- l. 496 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
with                          the                          base                          case
<!-- l. 496 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>4</mn></mrow></math>
being (<a href='#x12-248010r39'>10.39<!-- tex4ht:ref: eq:s4-rule  --></a>).
</p>
   </div>
<!-- l. 497 --><p class='indent'>     In Eq. (<a href='#x12-248009r38'>10.38<!-- tex4ht:ref: eq:s4-as-gadgets  --></a>) we used <!-- l. 506 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>s</mi></mrow><mrow><mn>4</mn></mrow></msub></math>
to represent the spider nest consisting of all gadgets connected to the first qubit. By
using <!-- l. 506 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>s</mi></mrow><mrow><mi>n</mi></mrow></msub></math>
for <!-- l. 506 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mn>4</mn></mrow></math>
and using Lemma <a href='#x12-248011r5'>10.3.5<!-- tex4ht:ref: lem:sn-sep  --></a> we see then that the collection of all gadgets on
<!-- l. 506 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn></mrow></math>
qubits that are connected to the first qubit is also an identity. We
can generalise this to the set of all gadgets connected to the first
<!-- l. 507 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> qubits. To do this,
note that if we connect <!-- l. 508 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>s</mi></mrow><mrow><mi>n</mi></mrow></msub></math>
to an X-spider on the left that we obtain the following: </p><table class='equation'><tr><td>
<!-- l. 509 --><p class='indent'>
</p><!-- l. 509 --><object id='x12-248014r41' data="svgs/eq-sn-char-2.svg" alt="diagram of eq:sn-char-2" class="svg-diagram"></object></td><td class='eq-no'>(10.41)</td></tr></table>
<!-- l. 512 --><p class='indent'>   where <!-- l. 512 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='bold'><mn>1</mn></mstyle></math>
is the <!-- l. 512 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-bin' stretchy='false'>×</mo> <msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></math>
matrix where every entry is 1. Hence, to represent a connection to the first
<!-- l. 512 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> qubits, we can
just compose <!-- l. 512 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>s</mi></mrow><mrow><mi>n</mi></mrow></msub></math>
with an X-spider on its inputs. This then also leads to an identity: </p><table class='equation'><tr><td>
<!-- l. 513 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 513 --><object id='x12-248015r42' data="svgs/eq-sn-x-spiders.svg" alt="diagram of eq:sn-x-spiders" class="svg-diagram"></object></td><td class='eq-no'>(10.42)</td></tr></table>
<!-- l. 516 --><p class='indent'>   Note that the special case of <!-- l. 516 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>
gives us the set of <span class='cmti-10x-x-109'>all </span>phase gadgets on a set of wires, like the 15-gadget identity (<a href='#x12-246006r26'>10.26<!-- tex4ht:ref: eq:spider-nest-4  --></a>) (in that
case <!-- l. 516 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>B</mi></mrow><mrow><mi>n</mi></mrow></msub></math> has 16 rows, but
the all-zero row of <!-- l. 516 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>B</mi></mrow><mrow><mi>n</mi></mrow></msub></math>
corresponds to an unconnected phase that can be removed as a scalar).
As it turns out, every spider nest identity can be decomposed into a
composition of the identities of the form (<a href='#x12-248015r42'>10.42<!-- tex4ht:ref: eq:sn-x-spiders  --></a>), and so (S4) indeed suffice
to prove all of them. To show this we will need some more machinery
however.
</p>
   <h4 class='subsectionHead' id='spider-nests-as-boolean-polynomials'><span class='titlemark'>10.3.3   </span> <a id='x12-24900010.3.3'></a>Spider nests as Boolean polynomials</h4>
<!-- l. 519 --><p class='noindent'>In the previous sections we saw that we can reduce a collection of phase
gadgets to a series of bit strings denoting the connectivity of the gadgets:
</p><table class='equation-star'><tr><td>
<!-- l. 520 --><object data="svgs/example-gadget-circuit.svg" alt="diagram of example-gadget-circuit" class="svg-diagram"></object></td></tr></table>
<!-- l. 523 --><p class='indent'>   Here we are ignoring the phase gadget with a
<!-- l. 523 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> </mrow></math> phase,
as it is Clifford. We saw in Eq (<a href='#x12-245003r19'>10.19<!-- tex4ht:ref: eq:phase-gadget-scalable  --></a>) that these bit strings can be stored in one
big matrix and in this way we can efficiently write down a collection of gadgets in
scalable notation. Storing them all in a matrix is however not the only way in
which we could capture the information of a set of bit strings. We could instead
represent them using its Boolean indicator function. That is, to a set of bit strings
<!-- l. 526 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>S</mi> <mo class='MathClass-rel' stretchy='false'>⊆</mo> <mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></math> we associate
the function <!-- l. 526 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>f</mi></mrow><mrow><mi>S</mi></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo> <mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>→</mo> <mi>𝔽</mi><mn>2</mn></mrow></math>
defined by <!-- l. 526 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>f</mi></mrow><mrow><mi>S</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>
                                                                     

                                                                     
iff <!-- l. 526 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>S</mi></mrow></math>. We
should note two important details about representing a collection of gadgets by its
indicator function. First, this representation cannot deal with repeated gadgets /
bit strings, and so this does not capture the exact phase of the gadgets (whether
it is <!-- l. 528 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>+</mo> <mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>
or <!-- l. 528 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>4</mn></mrow></mfrac> </mrow></math> for
instance). This means that when representing a collection of gadgets by its indicator
function that we only represent it up to some Clifford information. Second, because
<!-- l. 529 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mn>0</mn></mrow><mo accent='true'>→</mo></mover></math> corresponds
to a phase gadget not interacting with any qubit, we don’t care about the value of
the function at this value. It would hence be more accurate to write the functions
as <!-- l. 529 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi> <mo class='MathClass-punc' stretchy='false'>:</mo> <mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>∖</mo><mo class='MathClass-open' stretchy='false'>{</mo><mover accent='true'><mrow><mn>0</mn></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>}</mo><mo class='MathClass-rel' stretchy='false'>→</mo> <mi>𝔽</mi><mn>2</mn></mrow></math>,
but we will ignore this detail for now. Any Boolean indicator function
<!-- l. 530 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi> <mo class='MathClass-punc' stretchy='false'>:</mo> <mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>→</mo> <mi>𝔽</mi><mn>2</mn></mrow></math>
corresponds to a collection of phase gadgets: a gadget with connectivity
<!-- l. 530 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></math> is in the
collection if <!-- l. 530 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>.
Some collections of gadgets are spider nests, so let’s call
<!-- l. 531 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math> a
<span class='cmbx-10x-x-109'>spider-nest function </span>when its corresponding collection of gadgets forms a
spider nest (up to a possible Clifford unitary). I.e. if a collection of bit strings
<!-- l. 531 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math> forms the rows of a
3-even matrix, then <!-- l. 531 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>f</mi></mrow><mrow><mi>S</mi></mrow></msub></math>
is a spider-nest function. The indicator function of the
4-qubit spider nest of Eq. (<a href='#x12-246006r26'>10.26<!-- tex4ht:ref: eq:spider-nest-4  --></a>) is the constant function
<!-- l. 532 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mn>1</mn></mrow><mrow><mn>4</mn></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo> <mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mn>4</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>→</mo> <mi>𝔽</mi><mn>2</mn></mrow></math> that always
returns 1, since every phase gadget is part of the spider nest. The 5-qubit spider nest of
Eq. (<a href='#x12-248009r38'>10.38<!-- tex4ht:ref: eq:s4-as-gadgets  --></a>) that contains all the gadgets using the first qubit has as indicator function
<!-- l. 532 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>X</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo> <mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mn>5</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>→</mo> <mi>𝔽</mi><mn>2</mn></mrow></math> that maps
<!-- l. 532 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>X</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>y</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></math>, since any bit
string <!-- l. 532 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></math> is part of the
set of gadgets if <!-- l. 532 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>y</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>.
The spider nest of Eq. (<a href='#x12-248015r42'>10.42<!-- tex4ht:ref: eq:sn-x-spiders  --></a>) that uses all gadgets touching the first
<!-- l. 533 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> qubits has
indicator function <!-- l. 533 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>X</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>X</mi></mrow><mrow><mi>k</mi></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo> <mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>k</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mi>n</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>→</mo> <mi>𝔽</mi><mn>2</mn></mrow></math>,
which acts as <!-- l. 533 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>X</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>X</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>y</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>∧</mo><mo class='MathClass-rel' stretchy='false'>⋯</mo> <mo class='MathClass-bin' stretchy='false'>∧</mo> <msub><mrow><mi>y</mi></mrow><mrow><mi>k</mi></mrow></msub></mrow></math>.
These spider-nest functions are examples of Boolean <span class='cmbx-10x-x-109'>monomials</span>. A monomial
is a function constructed by multiplying simple bit-indicator functions
<!-- l. 534 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>X</mi></mrow><mrow><mi>j</mi></mrow></msub></math> together. For
instance <!-- l. 534 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>X</mi></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mi>X</mi></mrow><mrow><mn>3</mn></mrow></msub><msub><mrow><mi>X</mi></mrow><mrow><mn>4</mn></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>X</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <msub><mrow><mi>X</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <msub><mrow><mi>X</mi></mrow><mrow><mn>4</mn></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>y</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>∧</mo> <msub><mrow><mi>y</mi></mrow><mrow><mn>3</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>∧</mo> <msub><mrow><mi>y</mi></mrow><mrow><mn>4</mn></mrow></msub></mrow></math>.
We call the number of bit-indicator functions in such an expression
the <span class='cmbx-10x-x-109'>degree </span>of the monomial. For instance the spider-nest function
<!-- l. 535 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>X</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>X</mi></mrow><mrow><mi>k</mi></mrow></msub></mrow></math> has
degree <!-- l. 535 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>.
                                                                     

                                                                     
It turns out that in general, any monomial of degree at most
<!-- l. 536 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>4</mn></mrow></math> corresponds to a
spider-nest identity. Indeed, <!-- l. 536 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>X</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>X</mi></mrow><mrow><mi>k</mi></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo> <mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>k</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mi>n</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>→</mo> <mi>𝔽</mi><mn>2</mn></mrow></math>
for <!-- l. 536 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mn>4</mn></mrow></math> is a
spider-nest function. By permuting the qubits these give us all monomials of degree at
most <!-- l. 536 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>4</mn></mrow></math>. The
number 4 in <!-- l. 537 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>4</mn></mrow></math>
comes from the fact that the smallest spider-nest identity, corresponding to the Boolean
function <!-- l. 537 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mn>1</mn></mrow><mrow><mn>4</mn></mrow></msub></math>
acts on four qubits. Note that the spider-nest functions form a linear space: suppose
that both <!-- l. 538 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>f</mi></mrow><mrow><msub><mrow><mi>S</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>f</mi></mrow><mrow><msub><mrow><mi>S</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo> <mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>→</mo> <mi>𝔽</mi><mn>2</mn></mrow></math>
correspond to spider nests. Then if we take the composition of all the phase gadgets with
parities in <!-- l. 538 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>S</mi></mrow><mrow><mn>1</mn></mrow></msub></math>
and that of <!-- l. 538 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>S</mi></mrow><mrow><mn>2</mn></mrow></msub></math>
we end up with a new set of phase gadgets covering all the parities in
<!-- l. 538 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>S</mi></mrow><mrow><mn>1</mn></mrow></msub></math> and of
<!-- l. 538 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>S</mi></mrow><mrow><mn>2</mn></mrow></msub></math>. However, the gadgets
that are in both <!-- l. 538 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>S</mi></mrow><mrow><mn>1</mn></mrow></msub></math>
and <!-- l. 538 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>S</mi></mrow><mrow><mn>2</mn></mrow></msub></math> will fuse
and hence get a Clifford phase. We are ignoring the Clifford unitaries, so we see then
that the collection of <span class='cmti-10x-x-109'>non-Clifford </span>phase gadgets corresponds to the symmetric difference
<!-- l. 538 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>S</mi></mrow><mrow><mn>1</mn></mrow></msub><mi mathvariant='normal'>Δ</mi><msub><mrow><mi>S</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></math>. The indicator
function is then <!-- l. 538 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>f</mi></mrow><mrow><msub><mrow><mi>S</mi></mrow><mrow><mn>1</mn></mrow></msub><mi mathvariant='normal'>Δ</mi><msub><mrow><mi>S</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>f</mi></mrow><mrow><msub><mrow><mi>S</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>f</mi></mrow><mrow><msub><mrow><mi>S</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></msub></mrow></math>.
As this XOR of functions is just the sum in
<!-- l. 538 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔽</mi><mn>2</mn></mrow></math>, we
see that any sum of spider-nest functions is again a spider-nest function, so that
the spider-nests form a linear subspace of all Boolean functions. In particular, we
can take a sum of monomials that are all spider-nest functions and create a
<span class='cmbx-10x-x-109'>Boolean polynomial </span>that is a spider-nest function. Any Boolean function
<!-- l. 540 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi> <mo class='MathClass-punc' stretchy='false'>:</mo> <mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>→</mo> <mi>𝔽</mi><mn>2</mn></mrow></math>
can be written in a unique way as a polynomial
<!-- l. 540 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi> <mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow> <mi class='MathClass-op'>⊕</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mover accent='true'><mrow><mi>a</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub><msub><mrow><mi>λ</mi></mrow><mrow><mover accent='true'><mrow><mi>a</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub><msubsup><mrow><mi>X</mi></mrow><mrow><mn>1</mn></mrow><mrow><msub><mrow><mi>a</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></msubsup><mo class='MathClass-rel' stretchy='false'>⋯</mo><msubsup><mrow><mi>X</mi></mrow><mrow><mi>n</mi></mrow><mrow><msub><mrow><mi>a</mi></mrow><mrow><mi>n</mi></mrow></msub></mrow></msubsup></mrow></math> where
<!-- l. 540 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>λ</mi></mrow><mrow><mover accent='true'><mrow><mi>a</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>𝔽</mi><mn>2</mn></mrow></math> are
the coefficients that determine which monomials are in the decomposition of
<!-- l. 540 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math>.
The degree of a polynomial is then the maximum degree of its
monomials. As a sum of spider-nest functions is still a spider-nest
function, we then see that any Boolean polynomial of degree at most
<!-- l. 541 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>4</mn></mrow></math> is a spider-nest
function. What about the converse? Does any spider-nest function correspond to a degree
at most <!-- l. 541 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>4</mn></mrow></math>
polynomial?
</p>
   <div class='newtheorem'>
                                                                     

                                                                     
<!-- l. 542 --><p class='noindent'><span class='head'>
<a id='x12-249001r6'></a>
<span class='cmbx-10x-x-109'>Lemma 10.3.6.</span>  </span>A matrix <!-- l. 543 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math>
with <!-- l. 543 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
columns is 3-even if and only if its indicator polynomial <!-- l. 543 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>f</mi></mrow><mrow><mi>M</mi></mrow></msub></math>
is of degree at most <!-- l. 543 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>4</mn></mrow></math>.
</p>
   </div>
<!-- l. 544 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 546 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>Let <!-- l. 546 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>M</mi></mrow><mrow><mi>′</mi></mrow></msup></math> be a matrix
obtained from <!-- l. 546 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math> by removing
all repeated pairs of rows. <!-- l. 546 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math>
is 3-even if and only if <!-- l. 546 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>M</mi></mrow><mrow><mi>′</mi></mrow></msup></math>
is, and both matrices have the same indicator polynomial.
Hence, we can assume without loss of generality that
<!-- l. 546 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math> has no repeated
rows. Write <!-- l. 546 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>f</mi></mrow><mrow><mi>M</mi></mrow></msub></mrow></math> for the
indicator function of <!-- l. 546 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math>.
Let <!-- l. 547 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>r</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>n</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> denote the set
of <!-- l. 547 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-bit polynomials of
degree at most <!-- l. 547 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>r</mi></math>. We
need to show that <!-- l. 547 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>4</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mi>n</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
Define an inner product on Boolean functions by
<!-- l. 548 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>⟨</mo><msub><mrow><mi>g</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>g</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow> <mi class='MathClass-op'>⊕</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub><msub><mrow><mi>g</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>∧</mo> <msub><mrow><mi>g</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow><mo> ∑</mo>
  <!-- nolimits --></mrow><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub><msub><mrow><mi>g</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo><msub><mrow><mi>g</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo><mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='text'><mtext>mod </mtext></mstyle><mn>2</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>. We call
<!-- l. 548 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>g</mi></mrow><mrow><mn>1</mn></mrow></msub></math> and
<!-- l. 548 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>g</mi></mrow><mrow><mn>2</mn></mrow></msub></math> <span class='cmti-10x-x-109'>orthogonal</span>
when <!-- l. 548 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>⟨</mo><msub><mrow><mi>g</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>g</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math> and
we define <!-- l. 548 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>P</mi><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>r</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>n</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mo class='MathClass-rel' stretchy='false'>⊥</mo></mrow></msup></mrow></math>
as the space of functions that are orthogonal to all functions in
<!-- l. 548 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>r</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>n</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>. We claim
that <!-- l. 548 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>P</mi><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>r</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>n</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mo class='MathClass-rel' stretchy='false'>⊥</mo></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>r</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mi>n</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
With this claim it then remains for us to show that
<!-- l. 548 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>P</mi><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mn>3</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mi>n</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mo class='MathClass-rel' stretchy='false'>⊥</mo></mrow></msup></mrow></math>. Let’s do that first.
Let <!-- l. 549 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>g</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>X</mi></mrow><mrow><mi>j</mi></mrow></msub><mi>f</mi></mrow></math>. This is then a
polynomial with <!-- l. 549 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>g</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>
iff <!-- l. 549 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>b</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math> and
                                                                     

                                                                     
<!-- l. 549 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>. Hence
<!-- l. 549 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
   <!-- nolimits --></mrow><mrow><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub><mi>g</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> is equal to the Hamming
weight of the <!-- l. 549 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>j</mi></math>th column
of <!-- l. 549 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math>. This also works for
products of columns: for <!-- l. 549 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>h</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>X</mi></mrow><mrow><mi>i</mi></mrow></msub><msub><mrow><mi>X</mi></mrow><mrow><mi>j</mi></mrow></msub><msub><mrow><mi>X</mi></mrow><mrow><mi>k</mi></mrow></msub><mi>f</mi></mrow></math>,
we have <!-- l. 549 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub><mi>h</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
equal to the Hamming weight of the element-wise product of the
<!-- l. 549 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>i</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>j</mi></mrow></math> and
<!-- l. 549 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>th
rows, which is hence zero mod 2 because of 3-eveness. Now
<!-- l. 551 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
   <!-- nolimits --></mrow><mrow><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub><mi>h</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo><mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='text'><mtext>mod </mtext></mstyle><mn>2</mn><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>⟨</mo><msub><mrow><mi>X</mi></mrow><mrow><mi>i</mi></mrow></msub><msub><mrow><mi>X</mi></mrow><mrow><mi>j</mi></mrow></msub><msub><mrow><mi>X</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mi>f</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> so that
<!-- l. 551 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math> is orthogonal to all
degree-3 monomials <!-- l. 551 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>X</mi></mrow><mrow><mi>i</mi></mrow></msub><msub><mrow><mi>X</mi></mrow><mrow><mi>j</mi></mrow></msub><msub><mrow><mi>X</mi></mrow><mrow><mi>k</mi></mrow></msub></mrow></math>.
These span <!-- l. 551 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><mn>3</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mi>n</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>, and hence
<!-- l. 551 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>P</mi><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mn>3</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mi>n</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mo class='MathClass-rel' stretchy='false'>⊥</mo></mrow></msup></mrow></math> as desired. Now to prove
the claim <!-- l. 552 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>P</mi><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>r</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>n</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mo class='MathClass-rel' stretchy='false'>⊥</mo></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>r</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mi>n</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> first note
that if a polynomial <!-- l. 552 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math>
of <!-- l. 552 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math> variables has
degree less than <!-- l. 552 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>,
then <!-- l. 552 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn><mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='text'><mtext>mod </mtext></mstyle><mn>2</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
This is easy to check for monomials, as any monomial of degree
<!-- l. 552 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-rel' stretchy='false'>&lt;</mo> <mi>n</mi></mrow></math> must omit
some variable <!-- l. 552 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mi>j</mi></mrow></msub></math>,
so that </p><table class='equation-star'><tr><td>
<!-- l. 553 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
       <munder class='msub'><mrow><mo>∑</mo>
  </mrow><mrow><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover></mrow></munder><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><munder class='msub'><mrow><mo>∑</mo>
   </mrow><mrow><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>b</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>=</mo><mn>0</mn></mrow></munder><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mspace class='negthinspace' width='-0.17em'></mspace><mspace class='negthinspace' width='-0.17em'></mspace><munder class='msub'><mrow><mo>∑</mo>
   </mrow><mrow><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>b</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>=</mo><mn>1</mn></mrow></munder><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mn>0</mn><mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='text'><mtext>mod </mtext></mstyle><mn>2</mn><mo class='MathClass-close' stretchy='false'>)</mo>
</mrow></math></td></tr></table>
<!-- l. 554 --><p class='indent'>   By <!-- l. 554 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔽</mi><mn>2</mn></mrow></math>-linearity
of the map <!-- l. 554 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi><mo class='MathClass-rel' stretchy='false'>↦</mo><msub><mrow><mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo><mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='text'><mtext>mod </mtext></mstyle><mn>2</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
this then holds for all polynomials. Now, for any polynomial
<!-- l. 554 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math> of degree at
most <!-- l. 554 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>r</mi></math> and
<!-- l. 554 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>g</mi></math> of degree
at most <!-- l. 554 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>r</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math>,
<!-- l. 554 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>g</mi></mrow></math> has degree
                                                                     

                                                                     
at most <!-- l. 554 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math>.
Hence <!-- l. 554 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>⟨</mo><mi>f</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>g</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow> <mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mi>f</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>g</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn><mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='text'><mtext>mod </mtext></mstyle><mn>2</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>. This
implies <!-- l. 554 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>r</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mi>n</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>⊆</mo> <mi>P</mi><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>r</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>n</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mo class='MathClass-rel' stretchy='false'>⊥</mo></mrow></msup></mrow></math>.
To show this is actually an equality, we will do dimension counting. Note that for
a <!-- l. 554 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔽</mi><mn>2</mn></mrow></math>-vector
space <!-- l. 554 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> </mrow></math> and
<!-- l. 554 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>A</mi> <mo class='MathClass-rel' stretchy='false'>⊆</mo> <mi>V</mi> </mrow></math> we have
<!-- l. 554 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi class='qopname'>dim</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>A</mi></mrow><mrow><mo class='MathClass-rel' stretchy='false'>⊥</mo></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo><mi class='qopname'> dim</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><mi>V</mi> <mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>−</mo><mi class='qopname'> dim</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><mi>A</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> because the
dimension of <!-- l. 554 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>A</mi></mrow><mrow><mo class='MathClass-rel' stretchy='false'>⊥</mo></mrow></msup></math>
is restricted by independent linear equations specified by a basis of
<!-- l. 554 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>. Since
<!-- l. 555 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>r</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>n</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> has the monomials
of degree <!-- l. 555 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-rel' stretchy='false'>≤</mo> <mi>r</mi></mrow></math> as
its basis, <!-- l. 555 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi class='qopname'>dim</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>r</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>n</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo><msubsup><mrow><mi class='qopname'> ∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo>
  <!-- nolimits --></mrow><mrow><mi>d</mi><mo class='MathClass-rel' stretchy='false'>=</mo><mn>0</mn></mrow><mrow><mi>r</mi></mrow></msubsup><mrow><mo fence='true' form='prefix'>(</mo><mfrac linethickness='0.0pt'><mrow><mi>n</mi></mrow>
<mrow><mi>d</mi></mrow></mfrac><mo fence='true' form='postfix'>)</mo></mrow></mrow></math>.
By manipulating binomial coefficients, we can then see that: </p><table class='equation-star'><tr><td>
<!-- l. 556 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                  <mi class='qopname'>dim</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>r</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>n</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo><mi class='qopname'> dim</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>r</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mi>n</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo>
</mrow></math></td></tr></table>
   <table class='equation-star'><tr><td>
<!-- l. 558 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><munderover accent='false' accentunder='false'><mrow><mo>∑</mo>
  </mrow><mrow><mi>d</mi><mo class='MathClass-rel' stretchy='false'>=</mo><mn>0</mn></mrow><mrow><mi>r</mi></mrow></munderover><mrow><mo fence='true' form='prefix'>(</mo><mfrac linethickness='0.0pt'><mrow><mi>n</mi></mrow>
<mrow><mi>d</mi></mrow></mfrac><mo fence='true' form='postfix'>)</mo></mrow><mo class='MathClass-bin' stretchy='false'>+</mo><munderover accent='false' accentunder='false'><mrow><mo>∑</mo>
  </mrow><mrow><mi>d</mi><mo class='MathClass-rel' stretchy='false'>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mi>r</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></munderover><mrow><mo fence='true' form='prefix'>(</mo><mfrac linethickness='0.0pt'><mrow><mi>n</mi></mrow>
<mrow><mi>d</mi></mrow></mfrac><mo fence='true' form='postfix'>)</mo></mrow><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><munderover accent='false' accentunder='false'><mrow><mo>∑</mo>
  </mrow><mrow><mi>d</mi><mo class='MathClass-rel' stretchy='false'>=</mo><mn>0</mn></mrow><mrow><mi>r</mi></mrow></munderover><mrow><mo fence='true' form='prefix'>(</mo><mfrac linethickness='0.0pt'><mrow><mi>n</mi></mrow>
<mrow><mi>d</mi></mrow></mfrac><mo fence='true' form='postfix'>)</mo></mrow><mo class='MathClass-bin' stretchy='false'>+</mo><munderover accent='false' accentunder='false'><mrow><mo>∑</mo>
  </mrow><mrow><mi>d</mi><mo class='MathClass-rel' stretchy='false'>=</mo><mi>r</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mn>1</mn></mrow><mrow><mi>n</mi></mrow></munderover><mrow><mo fence='true' form='prefix'>(</mo><mfrac linethickness='0.0pt'><mrow><mi>n</mi></mrow>
<mrow><mi>d</mi></mrow></mfrac><mo fence='true' form='postfix'>)</mo></mrow><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mi class='qopname'>dim</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><mi>𝔽</mi><msup><mrow>
<mn>2</mn></mrow><mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup>
   </mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-punc' stretchy='false'>,</mo>
</mrow></math></td></tr></table>
<!-- l. 564 --><p class='indent'>   so                                                                                      that
<!-- l. 564 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi class='qopname'>dim</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>r</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mi>m</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo><mi class='qopname'> dim</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><mi>P</mi><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>r</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>n</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mo class='MathClass-rel' stretchy='false'>⊥</mo></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
and these spaces must be equal.                                                       □
                                                                     

                                                                     
</p>
   </div>
<!-- l. 566 --><p class='indent'>   We then see that we have proven the following.
</p>
   <div class='newtheorem'>
<!-- l. 567 --><p class='noindent'><span class='head'>
<a id='x12-249002r7'></a>
<span class='cmbx-10x-x-109'>Theorem 10.3.7.</span>  </span>Let <!-- l. 568 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msup><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>k</mi></mrow></msup></mrow></math>
describe the connectivities of <!-- l. 568 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
gadgets with a <!-- l. 568 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>
phase acting on <!-- l. 568 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
qubits. Then the following are equivalent. </p>
     <ul class='itemize1'>
     <li class='itemize'>The gadgets form a spider-nest identity (i.e. the circuit is equal to a
     Clifford).
     </li>
     <li class='itemize'>The matrix with entries <!-- l. 571 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mrow><mi>M</mi></mrow><mrow><mi>i</mi></mrow><mrow><mi>j</mi></mrow></msubsup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msubsup><mrow><mi>y</mi></mrow><mrow><mi>i</mi></mrow><mrow><mi>j</mi></mrow></msubsup></mrow></math>
     is 3-even.
     </li>
     <li class='itemize'>The indicator polynomial of the set <!-- l. 572 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>{</mo><msup><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msup><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>k</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>
     is of degree at most <!-- l. 572 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>4</mn></mrow></math>.
     </li></ul>
   </div>
<!-- l. 574 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 575 --><p class='noindent'><span class='head'>
<a id='x12-249003r8'></a>
<span class='cmbx-10x-x-109'>Theorem 10.3.8.</span>  </span>  The  Clifford  ZX  rules  plus  the  (S4)  rule  suffice
to  prove  all  spider-nest  identities.  That  is,  given  any  collection  of
<!-- l. 576 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>
gadgets that implements a Clifford unitary, we can rewrite this into this
Clifford unitary using just the regular Clifford ZX rewrite rules together
with (S4).
                                                                     

                                                                     
</p>
   </div>
<!-- l. 577 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 579 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>Let <!-- l. 579 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math>
be the <!-- l. 579 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>×</mo> <mi>k</mi></mrow></math>
3-even matrix describing a spider-nest identity. Then its corresponding indicator
polynomial <!-- l. 579 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>f</mi></mrow><mrow><mi>M</mi></mrow></msub></math>
is a sum of monomials <!-- l. 579 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>f</mi></mrow><mrow><mi>M</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo><msubsup><mrow> <mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>j</mi></mrow><mrow><mi>l</mi></mrow></msubsup><msub><mrow><mi>m</mi></mrow><mrow><mi>j</mi></mrow></msub></mrow></math>
of degree at most <!-- l. 579 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>4</mn></mrow></math>.
Let the corresponding matrices of these monomials be <!-- l. 579 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>M</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>M</mi></mrow><mrow><mi>l</mi></mrow></msub></mrow></math>.
We have already shown how to prove the spider-nest identities corresponding
to the <!-- l. 579 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>M</mi></mrow><mrow><mi>j</mi></mrow></msub></math>
in Eq. (<a href='#x12-248015r42'>10.42<!-- tex4ht:ref: eq:sn-x-spiders  --></a>), hence we can freely introduce them into the circuit of gadgets
described by <!-- l. 579 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math>:
</p>
<div class='center'>
<!-- l. 581 --><p class='noindent'>
</p><!-- l. 582 --><p class='noindent'><object data="svgs/s4-completeness-pf.svg" alt="diagram of s4-completeness-pf" class="svg-diagram"></object> </p></div>
<!-- l. 585 --><p class='indent'>   Then, the indicator polynomial of
<!-- l. 585 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>L</mi></math> is
<!-- l. 585 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>f</mi></mrow><mrow><mi>M</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo><msub><mrow> <mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>j</mi></mrow></msub><msub><mrow><mi>m</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>. Hence, every
row in <!-- l. 585 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>L</mi></math> appears
an even number of times. Using gadget-fusion, we can therefore reduce all angles to integer
multiples of <!-- l. 585 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>π</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn></mrow></math>.
Hence, the entire diagram is then Clifford and can be rewritten into a Clifford
circuit.                                                                                        □
</p>
   </div>
<!-- l. 587 --><p class='indent'>   We see then that when we restrict to just thinking about what we can do
with diagrams, all the complexity of strongly 3-even matrices and degree
<!-- l. 587 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>4</mn></mrow></math>
Boolean polynomials reduces to just adding (S4) to the Clifford rules. Do
note though that in the proof above we needed to know about Boolean
polynomials and its decomposition into low-degree monomials in order
to find which rewrites we should be applying to prove the spider-nest
                                                                     

                                                                     
identity. In addition, the matrices corresponding to the monomials
<!-- l. 588 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>M</mi></mrow><mrow><mi>j</mi></mrow></msub></math>
might contain exponentially many rows, and hence this rewriting is not efficient.
In fact, it seems very likely that an efficient rewrite strategy for spider nests
should not exist (see Exercise <a href='#x12-251001r9'>10.9<!-- tex4ht:ref: exer:T-count-hardness  --></a>). Forgetting about all these details again,
we can see that we can rephrase this result into a completeness result,
which very neatly ties in some of the earlier completeness results we have
seen.
</p>
   <div class='newtheorem'>
<!-- l. 590 --><p class='noindent'><span class='head'>
<a id='x12-249004r9'></a>
<span class='cmbx-10x-x-109'>Theorem 10.3.9.</span>  </span> The Clifford rules plus (S4) are complete for CNOT+<!-- l. 591 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
circuits. That is, given two CNOT+<!-- l. 591 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
circuits <!-- l. 591 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
and <!-- l. 591 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> </mrow></math>
written as ZX-diagrams, we can rewrite <!-- l. 591 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
into <!-- l. 591 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> </mrow></math>
using just the Clifford rules and (S4).
</p>
   </div>
<!-- l. 592 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 594 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>Note that we can trivially rewrite <!-- l. 594 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
to <!-- l. 594 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>U</mi><msup><mrow><mi>V</mi> </mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mi>V</mi> </mrow></math>
by consecutively introducing pairs of cancelling gates from <!-- l. 594 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>V</mi> </mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup></math>
and <!-- l. 594 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> </mrow></math>.
Hence, if we can show that <!-- l. 594 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mi>V</mi> </mrow></math>
can be rewritten to the identity we are done. In Section <a href='main_htmlch7.html#path-sums'>7.1<!-- tex4ht:ref: sec:path-sums  --></a> we saw how we
can write any CNOT+Phases circuit into a layer of phase gadgets followed by
a CNOT circuit. Now since <!-- l. 594 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mi>V</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi></mrow></math>,
it must be the case that both the phase gadget part and the CNOT circuit
implement the identity. Hence, we can use the completeness of phase-free
ZX  (Theorem <a href='main_htmlch4.html#x6-96006r6'>4.3.6<!-- tex4ht:ref: thm:completeness-pp-zx  --></a>)  to  rewrite  the  CNOT  circuit  into  the  identity  and
Theorem <a href='#x12-249003r8'>10.3.8<!-- tex4ht:ref: thm:s4-completeness  --></a> to rewrite the collection of phase gadgets, which necessarily
forms a spider-nest identity, into a Clifford. This Clifford still must be equal
to the identity, and hence by Clifford completeness (Theorem <a href='main_htmlch5.html#x7-124008r7'>5.5.7<!-- tex4ht:ref: thm:Clifford-completeness  --></a>) it can
                                                                     

                                                                     
be rewritten into the identity.                                                          □
</p>
   </div>
<!-- l. 596 --><p class='noindent'>
</p>
   <h3 class='sectionHead' id='advanced-tcount-optimisation'><span class='titlemark'>10.4   </span> <a id='x12-25000010.4'></a>Advanced T-count optimisation</h3>
<!-- l. 597 --><p class='noindent'>We have now seen that there is a large number of configurations of
<!-- l. 597 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates that actually correspond to Clifford circuits. Getting rid of
non-Clifford parts of a circuit is usually a good thing, as we’ve seen
that we can do a lot of rewriting and simplification with the Clifford
parts of a circuit. In addition, as we will see in Chapter <a href='main_htmlch11.html#quantum-error-correction'>11<!-- tex4ht:ref: ch:qec  --></a>, the
<!-- l. 597 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gate
in particular is quite costly to implement in many fault-tolerant architectures,
and so we want to include as few of them as possible. The spider-nest
identities suggest a simple rewrite strategy to optimise the number of
<!-- l. 598 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates in a
Clifford+<!-- l. 598 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
circuit. First, since spider nest identities apply to a collection of phase gadgets, and hence to
CNOT+<!-- l. 598 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> circuits, we need to
split up our Clifford+<!-- l. 598 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> circuit
into CNOT+<!-- l. 598 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> subcircuits.
We can view the Clifford+<!-- l. 598 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gate set as consisting of CNOT, Hadamard,
<!-- l. 598 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math> and
<!-- l. 598 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>. Of these, only the Hadamard
is not in the CNOT+<!-- l. 598 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
set, and so we need to ‘split our circuit on Hadamards’. Then, pick a
number of identities, preferably not containing too many gadgets
and not acting on too many qubits. We want to see where in the
CNOT+<!-- l. 599 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
circuit we can apply an identity so that it reduces the
<!-- l. 599 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>-count.
This is done as described in the beginning of Section <a href='#rewriting-cliffordt-diagrams'>10.3<!-- tex4ht:ref: sec:spider-nest-id  --></a>: for each identity in
our list, we check whether more than half of the gadgets are present in the
circuit. If this is the case, then we add all the gadgets from the identity to the
circuit, which by gadget fusion makes the matching gadgets already present in
the circuit into Cliffords, and adds the other gadgets as non-Cliffords. This
is repeated greedily until none of the identities has an overlap of more
than half with the gadgets present in the circuit. Note that if we have
<!-- l. 600 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math> qubits in our circuit, then to
                                                                     

                                                                     
match an <!-- l. 600 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>m</mi></math>-qubit spider-nest
identity, we need to check <!-- l. 600 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo fence='true' form='prefix'>(</mo><mfrac linethickness='0.0pt'><mrow> <mi>n</mi></mrow>
<mrow><mi>m</mi></mrow></mfrac><mo fence='true' form='postfix'>)</mo></mrow></math>
different groupings of <!-- l. 600 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>m</mi></math>
qubits to see whether the identity ‘matches’ there. Hence, as long as
<!-- l. 600 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>m</mi></math>
is bounded, the complexity of this algorithm is polynomial:
<!-- l. 600 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>n</mi></mrow><mrow><mi>m</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
In practice, only checking spider nests with up to
<!-- l. 600 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>5</mn></math>
qubits, and using a simple heuristic based on the ‘density’ of the number of
gadgets on a set of qubits, the run-time can be made quite reasonable.  Of course
such an algorithm is only a heuristic, and is heavily dependent on the type of
identities we include in our search, and since we are applying the identities
greedily, you might get stuck in a local optimum. The problem of optimisation of
CNOT+<!-- l. 602 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
circuits using spider nests is actually related to two well-known problems in
computer science, which offer interesting and useful perspectives on this
problem.
</p>
   <h4 class='subsectionHead' id='reedmuller-decoding'><span class='titlemark'>10.4.1   </span> <a id='x12-25100010.4.1'></a>Reed-Muller decoding</h4>
<!-- l. 604 --><p class='noindent'>We have seen that <!-- l. 604 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit
spider nests correspond to Boolean polynomials of degree at most
<!-- l. 604 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>4</mn></mrow></math>.
In addition, we have a correspondence between Boolean functions
<!-- l. 604 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math>
and collections of spider nests specified by their parities as
<!-- l. 604 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>{</mo><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover><mspace class='thinspace' width='0.17em'></mspace><mo class='MathClass-rel' stretchy='false'>|</mo><mspace class='thinspace' width='0.17em'></mspace><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>. Let’s call the set
of all <!-- l. 604 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-bit Boolean
functions <!-- l. 604 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>B</mi></mrow><mrow><mi>n</mi></mrow></msub></math>, and
the set of <!-- l. 604 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-bit
spider-nest functions <!-- l. 604 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>S</mi></mrow><mrow><mi>n</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>⊆</mo> <msub><mrow><mi>B</mi></mrow><mrow><mi>n</mi></mrow></msub></mrow></math>.
Now, if we naively implement the set of gadgets corresponding to
<!-- l. 605 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math> by
just implementing each of the gadgets in turn, then this will require
<!-- l. 605 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>f</mi><mo class='MathClass-rel' stretchy='false'>|</mo> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow> <mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>≠</mo><mover accent='true'><mrow><mn>0</mn></mrow><mo accent='true'>→</mo></mover></mrow></msub><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> number of
<!-- l. 605 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates. We call
<!-- l. 605 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>f</mi><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math> the <span class='cmbx-10x-x-109'>Hamming
weight </span>of <!-- l. 605 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math>. It is
the number of <!-- l. 605 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>s in
<!-- l. 605 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math>’s truth table. Note
that we do not include <!-- l. 605 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mn>0</mn></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
                                                                     

                                                                     
in this sum, as this corresponds to the trivial phase gadget not
connected to any qubit. However, we don’t have to naively implement
<!-- l. 606 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math>, because we
know that all <!-- l. 606 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>g</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <msub><mrow><mi>S</mi></mrow><mrow><mi>n</mi></mrow></msub></mrow></math>
are actually <span class='cmti-10x-x-109'>free </span>to implement: these correspond to Cliffords and hence do not require any
<!-- l. 606 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates. Instead of
directly implementing <!-- l. 606 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math>,
we can implement <!-- l. 606 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>g</mi></mrow></math>,
which corresponds to applying the spider nest identity of
<!-- l. 606 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>g</mi></math> to the collection
of gadgets of <!-- l. 606 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math>.
The cost of this implementation will then be
<!-- l. 606 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>f</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>g</mi><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>. To implement
<!-- l. 606 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math> with as few
<!-- l. 606 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates as possible we
are hence looking for a <!-- l. 606 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>g</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <msub><mrow><mi>S</mi></mrow><mrow><mi>n</mi></mrow></msub></mrow></math>
such that <!-- l. 606 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>f</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>g</mi><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>
is minimal. Let’s state this problem again in a slightly different
way, and a bit more abstractly. We have a vector space
<!-- l. 607 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> </mrow></math> with a specified
subspace <!-- l. 607 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>S</mi> <mo class='MathClass-rel' stretchy='false'>⊆</mo> <mi>V</mi> </mrow></math>. Given a
vector <!-- l. 607 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>v</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>V</mi> </mrow></math>, we want
to find the <span class='cmti-10x-x-109'>closest </span><!-- l. 607 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>s</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>S</mi></mrow></math>
to <!-- l. 607 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>v</mi></math>, i.e. such
that <!-- l. 607 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>v</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>s</mi></mrow></math> is as small
a vector as possible (in some norm). This is known as a <span class='cmbx-10x-x-109'>linear decoding problem</span>, where
<!-- l. 607 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math> is our code space
consisting of code words <!-- l. 607 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>s</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>S</mi></mrow></math>,
and <!-- l. 607 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>v</mi></math>
is our ‘noisy message’ we are trying to decode. We will spare you the details for now,
as we will have a lot more to say about linear codes in Chapter <a href='main_htmlch11.html#quantum-error-correction'>11<!-- tex4ht:ref: ch:qec  --></a>. In our case the
subspace <!-- l. 608 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>S</mi></mrow><mrow><mi>n</mi></mrow></msub></math>
consists of the spider-nest functions, which we know to be all the degree
<!-- l. 608 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>4</mn></mrow></math>
Boolean polynomials. This code space actually has a name: it is the degree
<!-- l. 608 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>4</mn></mrow></math>
<span class='cmbx-10x-x-109'>Reed-Muller code</span>, and hence optimising the
<!-- l. 608 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>-count of a
CNOT+<!-- l. 608 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
circuit corresponds to decoding the Reed-Muller code. To summarise this
optimisation approach now a bit more concretely: We start with a unitary
<!-- l. 610 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
that is built out of phase gadgets with phases that are multiples of
<!-- l. 610 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>.
                                                                     

                                                                     
We take its corresponding Boolean function
<!-- l. 610 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <msub><mrow><mi>B</mi></mrow><mrow><mi>n</mi></mrow></msub></mrow></math>. We then find the
‘closest’ degree <!-- l. 610 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>4</mn></mrow></math>
polynomial <!-- l. 610 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>g</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <msub><mrow><mi>S</mi></mrow><mrow><mi>n</mi></mrow></msub></mrow></math>
such that <!-- l. 610 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>f</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>g</mi><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math> is
as low as possible (corresponding to decoding the Reed-Muller code). We then implement
the circuit <!-- l. 610 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>U</mi></mrow><mrow><mi>′</mi></mrow></msup></math>
corresponding to <!-- l. 610 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>g</mi></mrow></math>
by composing its phase gadgets. We know that
<!-- l. 610 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math> is equal to
<!-- l. 610 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>U</mi></mrow><mrow><mi>′</mi></mrow></msup></math> up to some Clifford. We
find the Clifford <!-- l. 610 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>C</mi></math> such
that <!-- l. 610 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>U</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>U</mi></mrow><mrow><mi>′</mi></mrow></msup><mi>C</mi></mrow></math> (see Exercise <a href='#x12-247009r6'>10.6<!-- tex4ht:ref: exer:spider-nest-clifford  --></a>).
Then <!-- l. 610 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>U</mi></mrow><mrow><mi>′</mi></mrow></msup><mi>C</mi></mrow></math> is our new circuit,
and this has <!-- l. 610 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>-count
<!-- l. 610 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>f</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>g</mi><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>.
Reed-Muller codes are used a lot in practice and their decoding problem has been
extensively studied. So in principle we could use such a decoder to optimise
the T-count of a circuit. However, the codes that are used in practice
mostly have a size, corresponding in our case to the number of qubits
<!-- l. 611 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>,
that is not too large. However, we don’t want to restrict to just small
<!-- l. 611 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>,
so that is a problem. Decoding Reed-Muller codes for large
<!-- l. 612 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
is believed to be a hard problem, so we don’t expect there to be
an efficient algorithm to optimally minimise the T-count of a
CNOT+<!-- l. 612 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
circuit. For optimising the T-count of general
Clifford+<!-- l. 613 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
circuits (that are allowed to contain Hadamards), there is a simple argument to
see that T-count optimisation is NP-hard.
</p>
   <div class='newtheorem'>
<!-- l. 614 --><p class='noindent'><span class='head'>
<a id='x12-251001r9'></a>
<span class='cmbx-10x-x-109'>Exercise* 10.9.</span>  </span> In this exercise we will work towards a simple proof
that determining whether a Boolean function is satisfiable reduces to
<!-- l. 615 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>-count optimisation of
general Clifford+<!-- l. 615 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> circuits,
and hence is <!-- l. 615 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>-count
optimisation is NP-hard. Let <!-- l. 616 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi> <mo class='MathClass-punc' stretchy='false'>:</mo> <mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>→</mo> <mi>𝔽</mi><mn>2</mn></mrow></math>
                                                                     

                                                                     
be some Boolean function, which is described as some poly-size Boolean expression
consisting of AND, XOR and NOT terms. We we want to determine whether there
is a <!-- l. 616 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></math> such
that <!-- l. 616 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>.
We have seen in Chapter <a href='main_htmlch9.html#controlled-gates-and-classical-oracles'>9<!-- tex4ht:ref: ch:midlevel  --></a> how we can construct
<!-- l. 616 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>U</mi></mrow><mrow><mi>f</mi></mrow></msub></math>, the
<!-- l. 616 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>-qubit unitary
acting as <!-- l. 616 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>U</mi></mrow><mrow><mi>f</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>,
using Clifford+<!-- l. 616 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates.
     </p><dl class='enumerate'><dt class='enumerate'>
  1.. </dt><dd class='enumerate'>
     <!-- l. 618 --><p class='noindent'>Let the circuit <!-- l. 618 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>C</mi></mrow><mrow><mi>f</mi></mrow></msub></math>
     be defined as follows: </p><table class='equation'><tr><td>
     <!-- l. 619 --><p class='noindent'>
     </p><!-- l. 619 --><object id='x12-251003r43' data="svgs/eq-SAT-oracle.svg" alt="diagram of eq:SAT-oracle" class="svg-diagram"></object></td><td class='eq-no'>(10.43)</td></tr></table>
     <!-- l. 622 --><p class='noindent'>Show that <!-- l. 622 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>C</mi></mrow><mrow><mi>f</mi></mrow></msub></math>
     is a diagonal unitary which can be described by the following path-sum
     expression: </p><table class='equation'><tr><td>
     <!-- l. 623 --><p class='noindent'>
     </p><!-- l. 623 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                   <mstyle class='label' id='x12-251004r44'></mstyle><!-- endlabel --><msub><mrow><mi>C</mi></mrow><mrow><mi>f</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> <mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-bin' stretchy='false'>−</mo><mn>2</mn><mi>y</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td><td class='eq-no'>(10.44)</td></tr></table>
                                                                     

                                                                     
     </dd><dt class='enumerate'>
  2.. </dt><dd class='enumerate'>
     <!-- l. 626 --><p class='noindent'>Show that if <!-- l. 626 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math>
     is not satisfiable or <span class='cmbx-10x-x-109'>everywhere </span>satisfiable (meaning
     <!-- l. 626 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math> for all
     <!-- l. 626 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></math>) that
     then <!-- l. 626 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>C</mi></mrow><mrow><mi>f</mi></mrow></msub></math>
     is a Clifford unitary (up to global phase) and hence can be implemented with
     <!-- l. 626 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>-count
     zero.
     </p></dd><dt class='enumerate'>
  3.. </dt><dd class='enumerate'>
     <!-- l. 627 --><p class='noindent'>If <!-- l. 627 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math>
     is satisfiable but not everywhere satisfiable, then by definition there exist
     <!-- l. 627 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>z</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub></math> and
     <!-- l. 627 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>z</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>2</mn></mrow></msub></math> such
     that <!-- l. 627 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mover accent='true'><mrow><mi>z</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>
     and <!-- l. 627 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mover accent='true'><mrow><mi>z</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>.
     Then it is easy to see from Eq. (<a href='#x12-251004r44'>10.44<!-- tex4ht:ref: eq:SAT-oracle-path  --></a>) that
     <!-- tex4ht:inline --></p><!-- l. 628 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                  <msub><mrow><mi>C</mi></mrow><mrow><mi>f</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mover accent='true'><mrow><mi>z</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mover accent='true'><mrow><mi>z</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='qquad' width='2em'></mspace><mstyle class='text'><mtext>and</mtext></mstyle><mspace class='qquad' width='2em'></mspace><msub><mrow><mi>C</mi></mrow><mrow><mi>f</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mover accent='true'><mrow><mi>z</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mover accent='true'><mrow><mi>z</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math>
     <!-- l. 628 --><p class='nopar'> Show that in this case <!-- l. 629 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>C</mi></mrow><mrow><mi>f</mi></mrow></msub></math> is not
     Clifford and hence it’s <!-- l. 629 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>-count
     non-zero, by finding a Pauli string
     <!-- l. 629 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></math> such
     that <!-- l. 629 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mrow><mi>C</mi></mrow><mrow><mi>f</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msubsup><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><msub><mrow><mi>C</mi></mrow><mrow><mi>f</mi></mrow></msub></mrow></math>
     is not in the Pauli group. <span class='cmti-10x-x-109'>Hint: You don’t have to calculate the full operator</span>
     <!-- l. 630 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mrow><mi>C</mi></mrow><mrow><mi>f</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msubsup><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><msub><mrow><mi>C</mi></mrow><mrow><mi>f</mi></mrow></msub></mrow></math><span class='cmti-10x-x-109'>. For the right choice
     of </span><!-- l. 630 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></math> <span class='cmti-10x-x-109'>it is enough
     to observe that </span><!-- l. 630 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mrow><mi>C</mi></mrow><mrow><mi>f</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msubsup><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><msub><mrow><mi>C</mi></mrow><mrow><mi>f</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mover accent='true'><mrow><mi>z</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
     <span class='cmti-10x-x-109'>maps </span><!-- l. 630 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mover accent='true'><mrow><mi>z</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
     <span class='cmti-10x-x-109'>to something that a member of the Pauli group could not.</span> </p></dd></dl>
                                                                     

                                                                     
<!-- l. 632 --><p class='noindent'>Now, note that if we could efficiently determine the optimal
<!-- l. 632 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>-count of any circuit,
then for a given <!-- l. 632 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math> we
could construct <!-- l. 632 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>C</mi></mrow><mrow><mi>f</mi></mrow></msub></math> and
ask whether it’s <!-- l. 632 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>-count
is zero: if it is not then we know it has to be satisfiable. If it is zero, then either
the circuit is not satisfiable or everywhere satisfiable. We then just check the
value <!-- l. 632 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
to see which is the case. We can hence in either case efficiently determine whether
<!-- l. 632 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math> is
satisfiable, an NP-complete task.
</p>
   </div>
<!-- l. 643 --><p class='indent'>
</p>
   <h4 class='subsectionHead' id='symmetric-tensor-factorisation'><span class='titlemark'>10.4.2   </span> <a id='x12-25200010.4.2'></a>Symmetric 3-tensor factorisation</h4>
<!-- l. 645 --><p class='noindent'>There is another way we can formalise the optimisation of the number of
<!-- l. 645 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates in a
diagonal CNOT+<!-- l. 645 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
circuit. To do this, we again need to consider the multilinear decomposition of a
phase gadget as in Eq. (<a href='#x12-247004r31'>10.31<!-- tex4ht:ref: eq:XOR-decompose  --></a>): </p><table class='equation'><tr><td>
<!-- l. 647 --><p class='indent'>
</p><!-- l. 647 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
    <mstyle class='label' id='x12-252001r45'></mstyle><!-- endlabel --><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> <msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>⊕</mo><mo class='MathClass-rel' stretchy='false'>⋯</mo><mo class='MathClass-bin' stretchy='false'>⊕</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub>
               </mrow></msup><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mi class='qopname'>exp</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mi>i</mi> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac><munder class='msub'><mrow><mo>∑</mo>
   </mrow><mrow><mi>j</mi></mrow></munder><msub><mrow><mi>x</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>2</mn></mrow></mfrac><munder class='msub'><mrow><mo>∑</mo>
   </mrow><mrow><mi>i</mi><mo class='MathClass-rel' stretchy='false'>&lt;</mo><mi>j</mi></mrow></munder><msub><mrow><mi>x</mi></mrow><mrow><mi>i</mi></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>π</mi><munder class='msub'><mrow><mo>∑</mo>
   </mrow><mrow><mi>i</mi><mo class='MathClass-rel' stretchy='false'>&lt;</mo><mi>j</mi><mo class='MathClass-rel' stretchy='false'>&lt;</mo><mi>k</mi></mrow></munder><msub><mrow><mi>x</mi></mrow><mrow><mi>i</mi></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mi>j</mi></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub></mrow><mo fence='true' form='postfix'>)</mo></mrow></mrow><mo fence='true' form='postfix'>)</mo></mrow>
</mrow></math></td><td class='eq-no'>(10.45)</td></tr></table>
<!-- l. 650 --><p class='indent'>   In particular, the action of an arbitrary collection of
<!-- l. 650 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></math> phase
gadgets can be represented by some degree-3 multilinear polynomial
</p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 651 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
          <mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac><munder class='msub'><mrow><mo>∑</mo>
    </mrow><mrow><mi>j</mi></mrow></munder><msub><mrow><mi>a</mi></mrow><mrow><mi>j</mi></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>2</mn></mrow></mfrac><munder class='msub'><mrow><mo>∑</mo>
   </mrow><mrow><mi>i</mi><mo class='MathClass-rel' stretchy='false'>&lt;</mo><mi>j</mi></mrow></munder><msub><mrow><mi>b</mi></mrow><mrow><mi mathvariant='italic'>ij</mi></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mi>i</mi></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>π</mi><munder class='msub'><mrow><mo>∑</mo>
   </mrow><mrow><mi>i</mi><mo class='MathClass-rel' stretchy='false'>&lt;</mo><mi>j</mi><mo class='MathClass-rel' stretchy='false'>&lt;</mo><mi>k</mi></mrow></munder><msub><mrow><mi>c</mi></mrow><mrow><mi mathvariant='italic'>ijk</mi></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mi>i</mi></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mi>j</mi></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td></tr></table>
<!-- l. 652 --><p class='indent'>   Here the coefficients <!-- l. 652 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>a</mi></mrow><mrow><mi>j</mi></mrow></msub></math>
can be taken modulo 8, <!-- l. 652 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>b</mi></mrow><mrow><mi mathvariant='italic'>ij</mi></mrow></msub></math>
modulo 4 and <!-- l. 652 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>c</mi></mrow><mrow><mi mathvariant='italic'>ijk</mi></mrow></msub></math>
modulo <!-- l. 652 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>2</mn></math>.
By Exercise <a href='#x12-247006r5'>10.5<!-- tex4ht:ref: exer:multilinear-unique  --></a> two collections of phase gadgets correspond to
the same polynomial if and only if they implement the same linear
map. Similarly, two phase gadget circuits are equal up to a <span class='cmti-10x-x-109'>Clifford</span>
when the coefficients of their polynomials have the same parities
<!-- l. 653 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>a</mi></mrow><mrow><mi>j</mi></mrow></msub><mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='text'><mtext>mod </mtext></mstyle><mn>2</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>b</mi></mrow><mrow><mi mathvariant='italic'>ij</mi></mrow></msub><mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='text'><mtext>mod </mtext></mstyle><mn>2</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>c</mi></mrow><mrow><mi mathvariant='italic'>ijk</mi></mrow></msub><mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='text'><mtext>mod </mtext></mstyle><mn>2</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>. Hence,
if we don’t care about the Clifford part of a computation, we can forget that the
coefficient <!-- l. 654 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>a</mi></mrow><mrow><mi>j</mi></mrow></msub></math>
should be taken modulo 8, and instead take it modulo 2. Similarly we can take
<!-- l. 654 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>b</mi></mrow><mrow><mi mathvariant='italic'>ij</mi></mrow></msub></math>
modulo 2 instead of 4. This is nice, because this information about the
coefficients modulo 2 can be captured in a single object.
</p>
   <div class='newtheorem'>
<!-- l. 656 --><p class='noindent'><span class='head'>
<a id='x12-252002r1'></a>
<span class='cmbx-10x-x-109'>Definition 10.4.1.</span>  </span>An <!-- l. 657 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-dimensional
binary 3-tensor is an element <!-- l. 657 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>S</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><msup><mrow><mi>n</mi></mrow><mrow><mn>3</mn></mrow></msup>
    </mrow></msup></mrow></math>
where we label the components of the vector by <!-- l. 657 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>S</mi></mrow><mrow><mi mathvariant='italic'>ijk</mi></mrow></msub></math>
for indices <!-- l. 657 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>1</mn> <mo class='MathClass-rel' stretchy='false'>≤</mo> <mi>i</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>j</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>≤</mo> <mi>n</mi></mrow></math>.
We say <!-- l. 657 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
is <span class='cmbx-10x-x-109'>symmetric </span>when <!-- l. 657 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>S</mi></mrow><mrow><mi mathvariant='italic'>ijk</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>S</mi></mrow><mrow><mi mathvariant='italic'>jik</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>S</mi></mrow><mrow><mi mathvariant='italic'>ikj</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>S</mi></mrow><mrow><mi mathvariant='italic'>kji</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>S</mi></mrow><mrow><mi mathvariant='italic'>kij</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>S</mi></mrow><mrow><mi mathvariant='italic'>jki</mi></mrow></msub></mrow></math>
for all indices <!-- l. 657 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>i</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>j</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>k</mi></mrow></math>,
i.e. when <!-- l. 657 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
is invariant under permuting its indices.
</p>
   </div>
<!-- l. 658 --><p class='indent'>    We define the symmetric 3-tensor
                                                                     

                                                                     
<!-- l. 659 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>S</mi></mrow><mrow><mi mathvariant='italic'>ijk</mi></mrow></msub></math>
corresponding to a degree-3 multilinear polynomial by setting
</p><!-- tex4ht:inline --><!-- l. 664 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mtable class='align-star' columnalign='left' displaystyle='true'>
                             <mtr><mtd class='align-odd' columnalign='right'><msub><mrow><mi>S</mi></mrow><mrow><mi mathvariant='italic'>iii</mi></mrow></msub><mspace class='nbsp' width='0.33em'></mspace></mtd>                             <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><msub><mrow><mi>a</mi></mrow><mrow><mi>i</mi></mrow></msub><mspace width='2em'></mspace></mtd>                              <mtd class='align-label' columnalign='right'></mtd>                             <mtd class='align-label'>
                             <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'><msub><mrow><mi>S</mi></mrow><mrow><mi mathvariant='italic'>ijj</mi></mrow></msub><mspace class='nbsp' width='0.33em'></mspace></mtd>                             <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><msub><mrow><mi>b</mi></mrow><mrow><mi mathvariant='italic'>ij</mi></mrow></msub><mspace width='2em'></mspace></mtd>                              <mtd class='align-label' columnalign='right'></mtd>                             <mtd class='align-label'>
                             <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'><msub><mrow><mi>S</mi></mrow><mrow><mi mathvariant='italic'>ijk</mi></mrow></msub><mspace class='nbsp' width='0.33em'></mspace></mtd>                             <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><msub><mrow><mi>c</mi></mrow><mrow><mi mathvariant='italic'>ijk</mi></mrow></msub><mspace width='2em'></mspace></mtd>                             <mtd class='align-label' columnalign='right'></mtd>                             <mtd class='align-label'>
   <mspace width='2em'></mspace></mtd></mtr></mtable></math>
<!-- l. 665 --><p class='noindent'>for <!-- l. 665 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>i</mi> <mo class='MathClass-rel' stretchy='false'>&lt;</mo> <mi>j</mi> <mo class='MathClass-rel' stretchy='false'>&lt;</mo> <mi>k</mi></mrow></math>. All other
coefficients of <!-- l. 665 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
are then completely determined by symmetry. It is clear that from any symmetric
3-tensor we can also read of the coefficients of a degree-3 multilinear polynomial,
which then corresponds to a phase gadget circuit. Note though that if we start
with a phase gadget circuit, find its 3-tensor, and then translate it back into a
phase gadget circuit, that we do lose some Clifford information in the process,
and the resulting circuit is only equal to the original one up to some Clifford.
Let’s look at what the 3-tensor of a single phase gadget looks like. Let
<!-- l. 666 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></math>
describe the connectivity of the phase gadget. Then by Eq. (<a href='#x12-252001r45'>10.45<!-- tex4ht:ref: eq:XOR-decompose2  --></a>)
the corresponding multilinear polynomial has coefficients
<!-- l. 666 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>a</mi></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>y</mi></mrow><mrow><mi>i</mi></mrow></msub></mrow></math>,
<!-- l. 666 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>b</mi></mrow><mrow><mi mathvariant='italic'>ij</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-bin' stretchy='false'>−</mo><msub><mrow><mi>y</mi></mrow><mrow><mi>i</mi></mrow></msub><msub><mrow><mi>y</mi></mrow><mrow><mi>j</mi></mrow></msub></mrow></math> and
<!-- l. 666 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>c</mi></mrow><mrow><mi mathvariant='italic'>ijk</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>y</mi></mrow><mrow><mi>i</mi></mrow></msub><msub><mrow><mi>y</mi></mrow><mrow><mi>j</mi></mrow></msub><msub><mrow><mi>y</mi></mrow><mrow><mi>k</mi></mrow></msub></mrow></math>. That is:
there is a <!-- l. 666 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gate on all the qubits the gadget is connected to, a
<!-- l. 666 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mstyle class='text'><mtext>CS</mtext></mstyle></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup></math> on all
pairs of qubits it is connected to, and a CCZ on all triples of qubits it
is connected to. This means the 3-tensor corresponding to the gadget
<!-- l. 666 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>S</mi></mrow><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow></msup></math> has a particularly
simple form: <!-- l. 666 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mrow><mi>S</mi></mrow><mrow><mi mathvariant='italic'>ijk</mi></mrow><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow></msubsup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>y</mi></mrow><mrow><mi>i</mi></mrow></msub><msub><mrow><mi>y</mi></mrow><mrow><mi>j</mi></mrow></msub><msub><mrow><mi>y</mi></mrow><mrow><mi>k</mi></mrow></msub></mrow></math>.
3-tensors that have this form are said to have <span class='cmti-10x-x-109'>rank 1</span>. When we have a set of gadgets
<!-- l. 666 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msup><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>k</mi></mrow></msup></mrow></math>, the circuit has the
corresponding tensor <!-- l. 666 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>S</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>S</mi></mrow><mrow><msup><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msup>
      </mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-rel' stretchy='false'>⋯</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>S</mi></mrow><mrow><msup><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>k</mi></mrow></msup>
     </mrow></msup></mrow></math>,
and hence it is a sum of rank 1 tensors. Conversely, any way to write
<!-- l. 666 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math> as a
                                                                     

                                                                     
sum of rank 1 tensors corresponds to a way to implement it as a series of phase
gadgets.
</p>
   <div class='newtheorem'>
<!-- l. 667 --><p class='noindent'><span class='head'>
<a id='x12-252003r2'></a>
<span class='cmbx-10x-x-109'>Definition 10.4.2.</span>  </span>A symmetric 3-tensor is <span class='cmbx-10x-x-109'>rank 1 </span>when it is of the form
<!-- l. 668 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>S</mi></mrow><mrow><mi mathvariant='italic'>ijk</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>y</mi></mrow><mrow><mi>i</mi></mrow></msub><msub><mrow><mi>y</mi></mrow><mrow><mi>j</mi></mrow></msub><msub><mrow><mi>y</mi></mrow><mrow><mi>k</mi></mrow></msub></mrow></math>
for some vector <!-- l. 668 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></math>.
For a general symmetric 3-tensor <!-- l. 668 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
its <span class='cmbx-10x-x-109'>rank </span>is the minimal number of terms needed to write <!-- l. 668 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
as a sum of rank 1 tensors, and we call such a sum a <span class='cmbx-10x-x-109'>decomposition </span>of
<!-- l. 668 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>.
</p>
   </div>
<!-- l. 669 --><p class='indent'>    We see then that we have the following strategy for optimising the
<!-- l. 670 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>-count
of a phase gadget circuit: first find its corresponding 3-tensor. Then find a
decomposition of this tensor into as few rank 1 tensors as possible. These rank 1
tensors directly correspond to an optimised set of phase gadgets which
implements the same linear map as the original circuit up to a Clifford. Find
what Clifford this is using the procedure of Exercise <a href='#x12-247009r6'>10.6<!-- tex4ht:ref: exer:spider-nest-clifford  --></a>. The resulting
<!-- l. 670 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>-count of the
circuit is exactly equal to the rank of the decomposition we found. In particular, determining
the optimal <!-- l. 671 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>-count
of a given phase gadget circuit is equivalent to determining the rank of a
symmetric 3-tensor. Unfortunately, determining the rank of a (symmetric)
3-tensor is believed to be a hard problem. Fortunately, there are some good
heuristics that try to find low rank decompositions that work well in
practice. We will say a bit more about these in the References of this
chapter.
</p>
   <h3 class='sectionHead' id='catalysis'><span class='titlemark'>10.5   </span> <a id='x12-25300010.5'></a>Catalysis</h3>
<!-- l. 673 --><p class='noindent'>We saw way back in Section <a href='main_htmlch3.html#magic-state-injection'>3.3.1<!-- tex4ht:ref: sec:magic-state-injection  --></a> that we can implement a
<!-- l. 673 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gate by
injecting the <!-- l. 673 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>T</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-bin' stretchy='false'>+</mo><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
magic state into the circuit: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 674 --><object data="svgs/magic-state-injection-zx.svg" alt="diagram of magic-state-injection-zx" class="svg-diagram"></object></td></tr></table>
<!-- l. 677 --><p class='indent'>   This is useful, because it is sometimes difficult to directly implement the
<!-- l. 677 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gate
(as we will see in the next chapter), and instead having the ability to
prepare magic states ‘offline’ and inject them when needed is preferable.
However, in this circuit we <span class='cmti-10x-x-109'>consume </span>the magic state when we inject the
<!-- l. 678 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gate.
Wouldn’t it be nice if we could preserve this state instead? This does turn
out to be possible, if we use a different injection circuit that contains
some other non-Clifford gates. In particular, using a CS gate and a single
<!-- l. 679 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> state, we can
apply a <!-- l. 679 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gate and
get the starting <!-- l. 679 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
state back: </p><table class='equation'><tr><td>
<!-- l. 680 --><p class='indent'>
</p><!-- l. 680 --><object id='x12-253001r46' data="svgs/eq-cat-CS-T.svg" alt="diagram of eq:cat-CS-T" class="svg-diagram"></object></td><td class='eq-no'>(10.46)</td></tr></table>
<!-- l. 683 --><p class='indent'>   Here we used the decomposition of the CS gate written using an H-box
(Section <a href='main_htmlch9.html#hboxes'>9.2<!-- tex4ht:ref: sec:h-boxes  --></a>) into elementary gates: </p><table class='equation'><tr><td>
<!-- l. 684 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 684 --><object id='x12-253002r47' data="svgs/CS-decompose.svg" alt="diagram of CS-decompose" class="svg-diagram"></object></td><td class='eq-no'>(10.47)</td></tr></table>
<!-- l. 687 --><p class='indent'>   Just using Clifford operations and CS gates, it is not possible to construct a
<!-- l. 687 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gate. We can see this, because the matrices produced by the
Clifford+CS gate set have entries in a ring that does not include
<!-- l. 687 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></msup></math>.
However, with Eq. (<a href='#x12-253001r46'>10.46<!-- tex4ht:ref: eq:cat-CS-T  --></a>) we see that as soon as we have just <span class='cmti-10x-x-109'>one</span>
<!-- l. 688 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> state available to
us, we can use <!-- l. 688 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>CS</mi></mrow></math> gates
to apply as many <!-- l. 688 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates as we want:
</p>
<div class='center'>
<!-- l. 690 --><p class='noindent'>
</p><!-- l. 691 --><p class='noindent'><object data="svgs/cat-CS-T-example.svg" alt="diagram of cat-CS-T-example" class="svg-diagram"></object> </p></div>
<!-- l. 694 --><p class='indent'>   This is an example of what we call <span class='cmbx-10x-x-109'>catalysis</span>: a process that needs some resource
to be present, but doesn’t consume that resource. In this case the resource is
<!-- l. 694 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> and the process is the
implementation of a <!-- l. 694 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gate using a CS gate. Another example of catalysis is using a
<!-- l. 695 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mstyle class='text'><mtext>CCZ</mtext></mstyle><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mstyle class='text'><mtext>CCZ</mtext></mstyle><mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-bin' stretchy='false'>+</mo><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> magic state, Clifford
operations and a single <!-- l. 695 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gate in order to get 3 <!-- l. 695 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
states out: </p><table class='equation'><tr><td>
<!-- l. 696 --><p class='indent'>
</p><!-- l. 696 --><object id='x12-253003r48' data="svgs/cat-ccz-t-ak.svg" alt="diagram of cat-ccz-t-ak" class="svg-diagram"></object></td><td class='eq-no'>(10.48)</td></tr></table>
                                                                     

                                                                     
<!-- l. 700 --><p class='indent'>   So again, if we can perform CCZ and Clifford gates and have just a single
<!-- l. 700 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> available, then we
can inject as many <!-- l. 700 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates as we want. There are three things we can do with catalysis of
<!-- l. 701 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
magic states that we will explore in this section. First, in some cases it
turns out to be easier or cheaper to perform a CS or CCZ gate than a
<!-- l. 701 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gate,
and then these methods allow us to save resources. Second, they allow us to
prove that some gate sets are already <span class='cmti-10x-x-109'>computationally universal</span>, even if they are
not (obviously) approximately universal for unitary synthesis. And third,
catalysis gives us a nice way to extend complete graphical calculi to larger
domains.
</p>
   <h4 class='subsectionHead' id='catalysis-as-a-resource-for-compilation'><span class='titlemark'>10.5.1   </span> <a id='x12-25400010.5.1'></a>Catalysis as a resource for compilation</h4>
<!-- l. 703 --><p class='noindent'>In this section we will see how catalysis can be used to derive an efficient way to
implement small angle rotations. To do that we first need to generalise
Eq. (<a href='#x12-253001r46'>10.46<!-- tex4ht:ref: eq:cat-CS-T  --></a>) to allow us to implement controlled-phase gates. To see how this
works it will be helpful to first write Eq. (<a href='#x12-253001r46'>10.46<!-- tex4ht:ref: eq:cat-CS-T  --></a>) in circuit notation:
</p><table class='equation'><tr><td>
<!-- l. 705 --><p class='indent'>
</p><!-- l. 705 --><object id='x12-254001r49' data="svgs/eq-cat-CS-T-circ.svg" alt="diagram of eq:cat-CS-T-circ" class="svg-diagram"></object></td><td class='eq-no'>(10.49)</td></tr></table>
<!-- l. 708 --><p class='indent'>   Here we wrote a slightly more general circuit where we replace the
<!-- l. 708 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> and
controlled-<!-- l. 708 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
gates with <!-- l. 708 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> and
controlled-<!-- l. 708 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mn>2</mn><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> gates. As
a shorthand we write <!-- l. 708 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-bin' stretchy='false'>+</mo><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
as a generalisation of <!-- l. 708 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>T</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-bin' stretchy='false'>+</mo><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
Since this is a circuit equality that holds on the nose (with a correct global
phase), it should continue to hold when we add additional control wires:
</p><table class='equation'><tr><td>
                                                                     

                                                                     
<!-- l. 710 --><p class='indent'>
</p><!-- l. 710 --><object id='x12-254002r50' data="svgs/eq-cat-controlled-phase.svg" alt="diagram of eq:cat-controlled-phase" class="svg-diagram"></object></td><td class='eq-no'>(10.50)</td></tr></table>
<!-- l. 713 --><p class='indent'>   We can prove this is correct using some H-box rules (see Figure <a href='main_htmlch9.html#the-basic-rules-for-hboxes-'>9.0<!-- tex4ht:ref: fig:zh-rules  --></a>):
</p><table class='equation-star'><tr><td>
<!-- l. 714 --><object data="svgs/cat-controlled-phase-pf.svg" alt="diagram of cat-controlled-phase-pf" class="svg-diagram"></object></td></tr></table>
   <div class='newtheorem'>
<!-- l. 717 --><p class='noindent'><span class='head'>
<a id='x12-254003r10'></a>
<span class='cmbx-10x-x-109'>Exercise 10.10.</span>  </span>Applying Eq. (<a href='#x12-254002r50'>10.50<!-- tex4ht:ref: eq:cat-controlled-phase  --></a>) to implement a CS gate requires
using both a Toffoli and a CCZ. It turns out there is a different construction
that only requires a single CCZ and some <span class='cmti-10x-x-109'>real </span>Clifford operations (those that
do not contain numbers with an imaginary part like CNOT, Hadamard, CZ,
<!-- l. 718 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>).
Prove the following identity:
</p>
<div class='center'>
<!-- l. 720 --><p class='noindent'>
</p><!-- l. 721 --><p class='noindent'><object data="svgs/cat-CCZ-CS.svg" alt="diagram of cat-CCZ-CS" class="svg-diagram"></object> </p></div>
                                                                     

                                                                     
<!-- l. 724 --><p class='noindent'><span class='cmti-10x-x-109'>Hint: First prove the identity for </span><!-- l. 724 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math><span class='cmti-10x-x-109'>,
and then show for </span><!-- l. 724 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>
<span class='cmti-10x-x-109'>how the </span><!-- l. 724 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>aπ</mi></mrow></math>
<span class='cmti-10x-x-109'>phase can be pushed through the circuit to cancel</span>
</p>
   </div>
<!-- l. 725 --><p class='indent'>     Because we can apply catalysis equally well to controlled phases, we can start
iterating the procedure producing bigger and bigger controlled-phase gates, where the
phase being controlled is also increasingly large. For instance, if we want to implement
a <!-- l. 734 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gate, we can do the following: </p><table class='equation'><tr><td>
<!-- l. 735 --><p class='indent'>
</p><!-- l. 735 --><object id='x12-254004r51' data="svgs/eq-cat-T-repeated-circ.svg" alt="diagram of eq:cat-T-repeated-circ" class="svg-diagram"></object></td><td class='eq-no'>(10.51)</td></tr></table>
<!-- l. 738 --><p class='indent'>   Here in the last step we are left with a controlled
<!-- l. 738 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>Z</mi></mrow><mrow><mn>2</mn></mrow></msup></math> operation.
But since <!-- l. 738 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>Z</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mstyle class='text'><mtext>id</mtext></mstyle></mrow></math>
this does not do anything and we can remove it. So at this point we can
stop the iteration of the catalysis. We see then that we can implement a
<!-- l. 738 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gate just using multiple-controlled Toffoli gates, if we have the right
catalysis states lying around. This procedure works to implement any
<!-- l. 738 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mn>2</mn><mi>π</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><msup><mrow><mn>2</mn></mrow><mrow><mi>k</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> gate: we then
get a ladder of <!-- l. 738 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
Toffoli gates. We have actually seen such a Toffoli ladder before: in Exercise <a href='main_htmlch9.html#x11-228005r15'>9.15<!-- tex4ht:ref: exer:adder-construction  --></a> we
saw that this is actually a controlled-decrementer circuit that decreases the value
of an <!-- l. 739 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-bit
number by <!-- l. 739 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>,
controlled on the top wire. In that same exercise we saw that we can build a
subtraction circuit if we make a ladder of these controlled-decrementers. For this
reason, when we apply a subtraction circuit to a collection of catalysis states, this
implements phase gates on on the top qubits: </p><table class='equation'><tr><td>
<!-- l. 740 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 740 --><object id='x12-254005r52' data="svgs/eq-cat-sub-circ.svg" alt="diagram of eq:cat-sub-circ" class="svg-diagram"></object></td><td class='eq-no'>(10.52)</td></tr></table>
<!-- l. 743 --><p class='indent'>   The reason this is nice, is because in Section <a href='main_htmlch9.html#adders'>9.5<!-- tex4ht:ref: sec:adders  --></a> we found a very efficient
construction of the adjoint of the subtraction circuit: the adder. So if we can
transform Eq. (<a href='#x12-254005r52'>10.52<!-- tex4ht:ref: eq:cat-sub-circ  --></a>) slightly, so that it uses an adder instead of a subtracter, this
gives us a way to efficiently implement a whole collection of phase gates at once. The
way we do this is by taking Eq. (<a href='#x12-254005r52'>10.52<!-- tex4ht:ref: eq:cat-sub-circ  --></a>) and composing both sides on the right by
<!-- l. 743 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext>Add</mtext></mstyle> <mo class='MathClass-rel' stretchy='false'>=</mo><msup><mrow> <mstyle class='text'><mtext>Sub</mtext></mstyle></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup></mrow></math>, and on the
left by <!-- l. 743 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>T</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>S</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>Z</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup></math>.
After cancelling with the adjoints we are then left with the following equation:
</p><table class='equation'><tr><td>
<!-- l. 744 --><p class='indent'>
</p><!-- l. 744 --><object id='x12-254006r53' data="svgs/eq-cat-addition-circ.svg" alt="diagram of eq:cat-addition-circ" class="svg-diagram"></object></td><td class='eq-no'>(10.53)</td></tr></table>
<!-- l. 747 --><p class='indent'>   We showed the construction here for 3 bits, but this works for any number of
bits <!-- l. 747 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>,
in which case the smallest phase we implement is
<!-- l. 747 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mn>2</mn><mi>π</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
While this is nice and all, this might not seem immediately useful: we have this
pattern of phase gates appearing in parallel, where we have a small-angle phase
gate, a slightly-large-angle one, and so on. You might wonder, surely it will not
happen often that we can use this exact pattern of phases in a real quantum
circuit, and you would be wondering right. However, with the magic of ancillae
we can pick and choose exactly which phases we want to appear and
where. We can transfer the application of a phase gate to a zeroed ancilla:
</p><table class='equation'><tr><td>
<!-- l. 750 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 750 --><object id='x12-254007r54' data="svgs/phase-gate-on-ancilla.svg" alt="diagram of phase-gate-on-ancilla" class="svg-diagram"></object></td><td class='eq-no'>(10.54)</td></tr></table>
<!-- l. 753 --><p class='indent'>   Now when we have a complicated phase, we can decompose
it into simple components, and put each of these onto its own
ancilla. Suppose for instance we want to implement the phase
<!-- l. 753 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mfrac><mrow><mn>11</mn></mrow>
 <mrow><mn>8</mn></mrow></mfrac> <mi>π</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>. We can
then write <!-- l. 753 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>11</mn></mrow></math>
bitwise as <!-- l. 753 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>1011</mn></mrow></math>
so that <!-- l. 753 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mfrac><mrow><mn>11</mn></mrow>
 <mrow><mn>8</mn></mrow></mfrac> <mi>π</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mn>2</mn><mi>π</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><msup><mrow><mn>2</mn></mrow><mrow><mn>4</mn></mrow></msup><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mn>2</mn></mrow><mrow><mn>3</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mn>2</mn></mrow><mrow><mn>1</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mn>2</mn></mrow><mrow><mn>0</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
We can then put each of these component phases onto their own ancilla to get:
</p><table class='equation'><tr><td>
<!-- l. 754 --><p class='indent'>
</p><!-- l. 754 --><object id='x12-254008r55' data="svgs/eq-phase-gate-on-ancillae.svg" alt="diagram of eq:phase-gate-on-ancillae" class="svg-diagram"></object></td><td class='eq-no'>(10.55)</td></tr></table>
<!-- l. 757 --><p class='indent'>   We have here also sneakily added a zeroed ancilla that gets a
<!-- l. 757 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> <mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
applied that does nothing. We need this qubit though to complete the
pattern: we see then that we get the right shape needed to use Eq. (<a href='#x12-254006r53'>10.53<!-- tex4ht:ref: eq:cat-addition-circ  --></a>).
However, note that Eq. (<a href='#x12-254006r53'>10.53<!-- tex4ht:ref: eq:cat-addition-circ  --></a>) has adjoint phases, instead of the actual
phases we need. There are multiple ways we can deal with this. One
way is to realise that for phase gates, the adjoint is the conjugate:
<!-- l. 757 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>T</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='false' class='mml-overline'><mrow><mi>T</mi></mrow><mo accent='true'>¯</mo></mover></mrow></math>. Hence, if
we take the conjugate of both sides of Eq. (<a href='#x12-254006r53'>10.53<!-- tex4ht:ref: eq:cat-addition-circ  --></a>) we do get the right phases. Since
the Adder is a real matrix, this stays the same, but the states needed for the catalysis
also flip: <!-- l. 757 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='false' class='mml-overline'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow><mo accent='true'>¯</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><msup><mrow><mi>T</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
We then have everything we need to produce the circuit we are after:
</p><table class='equation'><tr><td>
<!-- l. 758 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 758 --><object id='x12-254009r56' data="svgs/eq-phase-gate-via-catalysis.svg" alt="diagram of eq:phase-gate-via-catalysis" class="svg-diagram"></object></td><td class='eq-no'>(10.56)</td></tr></table>
<!-- l. 761 --><p class='indent'>   Well, that certainly seems like overkill. Why would we go through all this
trouble just to prepare a single phase rotation. Well, it turns out that in a
fault-tolerant setting we can’t just go and do whatever gate we want to do. We
are restricted to just a small set of gates we can (cheaply) implement. So if our
computation requires us to do some phase rotation on a weird angle, we have
to find a way to this with the gates that we have access too. One way
to do this would be to approximate the phase rotation by combining
together unitary Clifford+T gates like in Section <a href='#approximating-arbitrary-singlequbit-gates'>10.1.2<!-- tex4ht:ref: sec:approx-main  --></a>. But as we have
now seen, another way to do it is to prepare just a single copy of each
<!-- l. 762 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mn>2</mn><mi>π</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><msup><mrow><mn>2</mn></mrow><mrow><mi>k</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> state
to serve as a catalyst which can be reused, and then apply some CNOTs and an
adder. Because the catalysts can be reused, the asymptotic cost of this procedure
is just the cost of the adder and the CNOTs. Let’s calculate more accurately
what the cost then is. Suppose we want to implement a phase gate with angle
<!-- l. 763 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>α</mi></math> up to a precision
<!-- l. 763 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>𝜀</mi></math>. We then find the
smallest <!-- l. 763 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math> such that
<!-- l. 763 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mn>2</mn></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi>n</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>&lt;</mo> <mi>𝜀</mi></mrow></math>. We can then
approximate <!-- l. 763 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>α</mi></math> by
a phase <!-- l. 763 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>α</mi></mrow><mo accent='true'>^</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>a</mi><mn>2</mn><mi>π</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></math> where
<!-- l. 763 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-rel' stretchy='false'>&lt;</mo> <msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></math> is an integer such
that <!-- l. 763 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>α</mi> <mo class='MathClass-bin' stretchy='false'>−</mo><mover accent='true'><mrow><mi>α</mi></mrow><mo accent='true'>^</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo> <mo class='MathClass-rel' stretchy='false'>&lt;</mo> <msup><mrow><mn>2</mn></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi>n</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>&lt;</mo> <mi>𝜀</mi></mrow></math>. It hence
suffices to implement <!-- l. 763 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>α</mi></mrow><mo accent='true'>^</mo></mover></math>
instead. Since <!-- l. 763 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>a</mi></math> is
an <!-- l. 763 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-bit number, we
can implement the <!-- l. 763 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>α</mi></mrow><mo accent='true'>^</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
gate using a generalisation of Eq. (<a href='#x12-254009r56'>10.56<!-- tex4ht:ref: eq:phase-gate-via-catalysis  --></a>) to
<!-- l. 763 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
bits. We saw in Section <a href='main_htmlch9.html#adders'>9.5<!-- tex4ht:ref: sec:adders  --></a> that we can implement an
<!-- l. 764 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit quantum
adder using <!-- l. 764 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
Toffoli gates. In a fault-tolerant architecture the implementation
of these Toffoli gates is what dominates the cost. As
<!-- l. 764 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mn>2</mn></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi>n</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>&lt;</mo> <mi>𝜀</mi></mrow></math> we have
<!-- l. 764 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --></mrow><mrow><mn>2</mn></mrow></msub><mn>1</mn><mo class='MathClass-bin' stretchy='false'>∕</mo><mi>𝜖</mi> <mo class='MathClass-rel' stretchy='false'>&lt;</mo> <mi>n</mi></mrow></math>, and hence
                                                                     

                                                                     
we can express the cost also in terms of the error budget, and say that we require
<!-- l. 764 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --></mrow><mrow><mn>2</mn></mrow></msub><mn>1</mn><mo class='MathClass-bin' stretchy='false'>∕</mo><mi>𝜖</mi></mrow></math> Toffoli gates. Decomposing
each Toffoli with <!-- l. 764 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>4</mn></math>
<!-- l. 764 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates we see that we can equivalently say that the cost is
<!-- l. 764 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>4</mn><msub><mrow><mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --></mrow><mrow><mn>2</mn></mrow></msub><mn>1</mn><mo class='MathClass-bin' stretchy='false'>∕</mo><mi>𝜖</mi></mrow></math>
<!-- l. 764 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates.
</p>
   <h4 class='subsectionHead' id='computational-universality-via-catalysis'><span class='titlemark'>10.5.2   </span> <a id='x12-25500010.5.2'></a>Computational universality via catalysis</h4>
<!-- l. 766 --><p class='noindent'>Using catalysis we can replace any occurrence of some gate
(like<!-- l. 766 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>)
with some other gate (like CS), as long as we have access to some special catalyst
ancilla state. We can use this idea to prove that certain gate sets are also
universal for quantum computing. In this section we will demonstrate this idea
by showing the Clifford+CS gate set is universal. This notion of universality
we will use is however not the approximate universality like that of the
Clifford+<!-- l. 768 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gate set we demonstrated in Section <a href='#approximating-arbitrary-singlequbit-gates'>10.1.2<!-- tex4ht:ref: sec:approx-main  --></a>. Instead it is what we will call
<span class='cmbx-10x-x-109'>computational universality</span>. Approximate universality requires that we can
approximate <span class='cmti-10x-x-109'>any </span>unitary and hence quantum circuit arbitrarily well. But such a
strong condition is actually not needed for a gate set to be useful. It is sufficient
if we can just <span class='cmti-10x-x-109'>simulate </span>the run of an arbitrary quantum circuit using some runs
of a quantum computer using the restricted gate set. Let’s work through an
example to make this more clear. For this section we will say that the purpose of
a quantum computer is to estimate the expectation value of some observable
<!-- l. 771 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>O</mi></mstyle></math>. We start with
some state <!-- l. 771 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>, apply
some unitary <!-- l. 771 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
to it, and then do measurements and post-process these measurements to get an
estimate of <!-- l. 771 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>O</mi></mstyle></math>.
After many such runs we will get a close approximation of
<!-- l. 771 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>O</mi></mstyle></math>.
Mathematically we can represent the exact expectation value as: </p><table class='equation'><tr><td>
<!-- l. 772 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 772 --><object id='x12-255001r57' data="svgs/eq-expectation-value.svg" alt="diagram of eq:expectation-value" class="svg-diagram"></object></td><td class='eq-no'>(10.57)</td></tr></table>
<!-- l. 775 --><p class='indent'>   However, when we are trying to estimate this observable, we don’t
have to do this with just a single quantum circuit we run over and over
again. Instead we could have a collection of different quantum circuits
<!-- l. 775 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>V</mi> </mrow><mrow><mi>j</mi></mrow></msub></math>
(potentially acting on a different number of qubits), input states
<!-- l. 775 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>ψ</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>, and
observables <!-- l. 775 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mstyle mathvariant='script'><mi>O</mi></mstyle></mrow><mrow><mi>j</mi></mrow></msub></math>,
such that taking a particular weighted average gets us the outcome we are after:
</p><table class='equation'><tr><td>
<!-- l. 776 --><p class='indent'>
</p><!-- l. 776 --><object id='x12-255002r58' data="svgs/eq-expectation-value-sum.svg" alt="diagram of eq:expectation-value-sum" class="svg-diagram"></object></td><td class='eq-no'>(10.58)</td></tr></table>
<!-- l. 779 --><p class='indent'>   where here we define <!-- l. 779 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mo class='MathClass-open' stretchy='false'>⟨</mo><mstyle mathvariant='script'><mi>O</mi></mstyle><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow><mrow><mi>j</mi></mrow></msub></math> to
be the expectation value of <!-- l. 779 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mstyle mathvariant='script'><mi>O</mi></mstyle></mrow><mrow><mi>j</mi></mrow></msub></math>
with respect to <!-- l. 779 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>V</mi> </mrow><mrow><mi>j</mi></mrow></msub></math>
and <!-- l. 779 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>ψ</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
We see then that if we can estimate each of the
<!-- l. 780 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mo class='MathClass-open' stretchy='false'>⟨</mo><mstyle mathvariant='script'><mi>O</mi></mstyle><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow><mrow><mi>j</mi></mrow></msub></math>, that we can also estimate
<!-- l. 780 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>⟨</mo><mstyle mathvariant='script'><mi>O</mi></mstyle><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> itself, by just summing
our estimates like <!-- l. 780 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>⟨</mo><mstyle mathvariant='script'><mi>O</mi></mstyle><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow> <mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>j</mi></mrow></msub><msub><mrow><mi>λ</mi></mrow><mrow><mi>j</mi></mrow></msub><msub><mrow><mo class='MathClass-open' stretchy='false'>⟨</mo><mstyle mathvariant='script'><mi>O</mi></mstyle><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow><mrow><mi>j</mi></mrow></msub></mrow></math>.
This might seem like quite a hypothetical situation, so let’s
give a concrete example. Suppose we have a Clifford+T circuit
<!-- l. 782 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>C</mi></math> applied to the
input state <!-- l. 782 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>. Then
we can transform <!-- l. 782 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>C</mi></math>
into a circuit <!-- l. 782 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>C</mi></mrow><mrow><mi>′</mi></mrow></msup></math>
containing just Clifford gates and CS gates using catalysis, so that
<!-- l. 782 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>C</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>C</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>. If we were trying to
estimate the observable <!-- l. 783 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>O</mi></mstyle></math>
                                                                     

                                                                     
we can then check that: </p><table class='equation'><tr><td>
<!-- l. 784 --><p class='indent'>
</p><!-- l. 784 --><object id='x12-255003r59' data="svgs/eq-expectation-value-T-cat.svg" alt="diagram of eq:expectation-value-T-cat" class="svg-diagram"></object></td><td class='eq-no'>(10.59)</td></tr></table>
<!-- l. 787 --><p class='indent'>   So instead of just running the circuit
<!-- l. 787 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>C</mi></math>, we can run
<!-- l. 787 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>C</mi></mrow><mrow><mi>′</mi></mrow></msup></math>, which doesn’t
contain any <!-- l. 787 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates. This is then an example of Eq. (<a href='#x12-255002r58'>10.58<!-- tex4ht:ref: eq:expectation-value-sum  --></a>) where the sum is over just one term and
we have <!-- l. 787 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>λ</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>,
<!-- l. 787 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>U</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>C</mi></mrow><mrow><mi>′</mi></mrow></msup></mrow></math>,
<!-- l. 787 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>ψ</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> and
<!-- l. 787 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mstyle mathvariant='script'><mi>O</mi></mstyle></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mstyle mathvariant='script'><mi>O</mi></mstyle> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>I</mi></mrow></math>.
But now suppose we don’t even want to use that single
<!-- l. 788 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> we
need for the catalysis. What we can do then is decompose this magic state into a
sum of Clifford states. Because each term in the sum needs to retain
the form of an expectation value like (<a href='#x12-255001r57'>10.57<!-- tex4ht:ref: eq:expectation-value  --></a>), we can’t just decompose
<!-- l. 788 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> into pure states
<!-- l. 788 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>ϕ</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>, instead we need
to decompose <!-- l. 788 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mi>T</mi><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>
into a sum of <!-- l. 788 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>ϕ</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><msub><mrow><mi>ϕ</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>
density matrices. One way to do this is the following:
                                                                     

                                                                     
</p><!-- tex4ht:inline --><!-- l. 792 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mtable class='align' columnalign='left' displaystyle='true'>
   <mtr><mtd class='align-odd' columnalign='right'><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mi>T</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mspace class='nbsp' width='0.33em'></mspace></mtd>   <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'>     <mn>1</mn>     </mtd><mtd class='array-td' columnalign='center'> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iπ</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>4</mn></mrow></msup>  </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>iπ</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>4</mn></mrow></msup>  </mtd><mtd class='array-td' columnalign='center'>     <mn>1</mn>    </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                            </mrow><mo fence='true' form='postfix'>)</mo></mrow><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'>   <mn>1</mn>   </mtd><mtd class='array-td' columnalign='center'>  <mfrac><mrow><mn>1</mn><mo class='MathClass-bin' stretchy='false'>+</mo><mi>i</mi></mrow> 
<mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac>   </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <mfrac><mrow><mn>1</mn><mo class='MathClass-bin' stretchy='false'>−</mo><mi>i</mi></mrow> 
<mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac>   </mtd><mtd class='array-td' columnalign='center'>    <mn>1</mn>   </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                 </mrow><mo fence='true' form='postfix'>)</mo></mrow><mspace class='nbsp' width='0.33em'></mspace><mspace width='2em'></mspace></mtd>   <mtd class='align-label' columnalign='right'></mtd>   <mtd class='align-label'>
   <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>        <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace>  <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac><mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-bin' stretchy='false'>+</mo><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mo class='MathClass-bin' stretchy='false'>+</mo><mo class='MathClass-rel' stretchy='false'>|</mo> <mo class='MathClass-bin' stretchy='false'>+</mo>  <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac><mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mi>i</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mi>i</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><msqrt><mrow><mn>2</mn></mrow></msqrt> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow> 
    <mrow><mn>2</mn></mrow></mfrac>     <mrow><mo fence='true' form='prefix'>(</mo><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>|</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mn>1</mn><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mo fence='true' form='postfix'>)</mo></mrow><mo class='MathClass-punc' stretchy='false'>.</mo><mspace width='2em'></mspace></mtd>                                                                                                     <mtd class='align-label' columnalign='right'><mstyle class='label' id='x12-255004r60'></mstyle><!-- endlabel --><mstyle class='maketag'><mtext>(10.60)</mtext></mstyle><mspace class='nbsp' width='0.33em'></mspace>
   </mtd></mtr></mtable></math>
<!-- l. 793 --><p class='noindent'>Hence, we can decompose <!-- l. 793 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mi>T</mi><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>
into four Clifford states <!-- l. 793 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>ϕ</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-bin' stretchy='false'>+</mo><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>,
<!-- l. 793 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>ϕ</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mi>i</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>,
<!-- l. 793 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>ϕ</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> and
<!-- l. 793 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>ϕ</mi></mrow><mrow><mn>4</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> with
weights <!-- l. 793 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>λ</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>λ</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo>  <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac></mrow></math>
and <!-- l. 793 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>λ</mi></mrow><mrow><mn>3</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>λ</mi></mrow><mrow><mn>4</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><msqrt><mrow><mn>2</mn></mrow></msqrt><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow>
   <mrow><mn>2</mn></mrow></mfrac>    </mrow></math>.
Starting with the left-hand side of Eq. (<a href='#x12-255003r59'>10.59<!-- tex4ht:ref: eq:expectation-value-T-cat  --></a>) we then have: </p><table class='equation'><tr><td>
<!-- l. 795 --><p class='indent'>
</p><!-- l. 795 --><object id='x12-255005r61' data="svgs/expectation-value-T-decompose.svg" alt="diagram of expectation-value-T-decompose" class="svg-diagram"></object></td><td class='eq-no'>(10.61)</td></tr></table>
<!-- l. 798 --><p class='indent'>   We see then that this is a case of Eq. (<a href='#x12-255002r58'>10.58<!-- tex4ht:ref: eq:expectation-value-sum  --></a>) with
<!-- l. 798 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>ψ</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>ϕ</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> and
<!-- l. 798 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mstyle mathvariant='script'><mi>O</mi></mstyle></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mstyle mathvariant='script'><mi>O</mi></mstyle> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>I</mi></mrow></math> and
<!-- l. 798 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>U</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>C</mi></mrow><mrow><mi>′</mi></mrow></msup></mrow></math> for
all <!-- l. 798 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>j</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo><mo class='MathClass-open' stretchy='false'>{</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>2</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>3</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>4</mn><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>.
While we can reduce the calculation of an expectation value to the calculation of
a sum of (potentially simpler to calculate) expection values in this way,
there is an important issue here that we have however glossed over. We
can only ever <span class='cmti-10x-x-109'>estimate </span>the expectation value, not get an exact value.
Generally, we want to determine an error budget for how close we want the
estimate to be, and then that determines how many times we need to
sample from the quantum computation. Since we are summing together
different expectation values, we need to be careful that we aren’t
blowing up the error in the estimates. Suppose for instance that some
<!-- l. 799 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>λ</mi></mrow><mrow><mi>k</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>100</mn></mrow></math>. Then a small error
in our estimate of <!-- l. 799 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mo class='MathClass-open' stretchy='false'>⟨</mo><mstyle mathvariant='script'><mi>O</mi></mstyle><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow><mrow><mi>j</mi></mrow></msub></math>
                                                                     

                                                                     
will blow up by a factor of a 100. On the other hand, if
<!-- l. 799 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>λ</mi></mrow><mrow><mi>k</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>100</mn></mrow></math>,
then any error will also be decreased by a factor of a 100, so that
even a large error is not that important. In you want to be efficient
and not over-sample a given expectation value, so that we get its
estimate at just the right target precision we then need to sample
<!-- l. 799 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mo class='MathClass-open' stretchy='false'>⟨</mo><mstyle mathvariant='script'><mi>O</mi></mstyle><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow><mrow><mi>j</mi></mrow></msub></math> a number of times
proportional to <!-- l. 799 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>λ</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>.
We can calculate that this summing approach gives a total overhead in the number of
samples of <!-- l. 799 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>λ</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>
compared to just determining the desired expectation value
<!-- l. 799 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>⟨</mo><mstyle mathvariant='script'><mi>O</mi></mstyle><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> with
the original circuit. For instance, in the above example where we decomposed
<!-- l. 800 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mi>T</mi><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math> into four terms,
we have <!-- l. 800 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>λ</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>2</mn><msqrt><mrow><mn>2</mn></mrow></msqrt> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn> <mo class='MathClass-rel' stretchy='false'>≈</mo> <mn>1.83</mn></mrow></math>.
Hence, if we decompose the magic state in this way we need to collect
<!-- l. 801 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>1.83</mn></mrow></math>
samples more than we would have needed to if we did use the magic
<!-- l. 801 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> state
directly. Summarising the full procedure we see then that we need to do the
following:
     </p><dl class='enumerate'><dt class='enumerate'>
  1.. </dt><dd class='enumerate'>
     <!-- l. 804 --><p class='noindent'>Start with the Clifford+T computation you want to calculate.
     </p></dd><dt class='enumerate'>
  2.. </dt><dd class='enumerate'>
     <!-- l. 805 --><p class='noindent'>Replace all <!-- l. 805 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
     gates by a CS gate catalysis circuit using a <!-- l. 805 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
     </p></dd><dt class='enumerate'>
  3.. </dt><dd class='enumerate'>
     <!-- l. 806 --><p class='noindent'>Replace the <!-- l. 806 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
     state needed for all the catalysis by the Clifford states <!-- l. 806 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>ψ</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
     </p></dd><dt class='enumerate'>
  4.. </dt><dd class='enumerate'>
     <!-- l. 807 --><p class='noindent'>Run each of the resulting four circuits a number of times proportional
     to <!-- l. 807 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>λ</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>.
     </p></dd><dt class='enumerate'>
  5.. </dt><dd class='enumerate'>
     <!-- l. 808 --><p class='noindent'>Combine the resulting estimates of the observable by scaling by <!-- l. 808 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>λ</mi></mrow><mrow><mi>j</mi></mrow></msub></math>
     to get the final outcome. </p></dd></dl>
                                                                     

                                                                     
<!-- l. 810 --><p class='noindent'>When we have Clifford gates and CS gates, the gate set is generated by CNOT, Hadamard,
<!-- l. 810 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math> and CS. Of
course, CNOT can be constructed using CS and Hadamard, and if we allow states to be
prepared into <!-- l. 810 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
and <!-- l. 810 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>, then we can
also prepare an <!-- l. 810 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
using a CS. Hence, this gate set is equivalent to just the CS and Hadamard gate.
We see then that we have proven the following.
</p>
   <div class='newtheorem'>
<!-- l. 812 --><p class='noindent'><span class='head'>
<a id='x12-255011r1'></a>
<span class='cmbx-10x-x-109'>Theorem 10.5.1.</span>  </span>  The   CS+Hadamard   gate   set   is   computationally
universal.  In  particular,  a  Clifford+T  computation  can  be  simulated  by
a  CS+Hadamard  computation  with  a  linear  overhead  in  the  number  of
samples, qubits and gates needed.
</p>
   </div>
<!-- l. 814 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 815 --><p class='noindent'><span class='head'>
<a id='x12-255012r2'></a>
<span class='cmbx-10x-x-109'>Remark 10.5.2.</span>  </span>Our decomposition (<a href='#x12-255004r60'>10.60<!-- tex4ht:ref: eq:ketbra-T-decomp  --></a>) of <!-- l. 816 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mi>T</mi><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>
is a <span class='cmbx-10x-x-109'>stabiliser decomposition</span>, a concept we also looked at in Section* <a href='main_htmlch7.html#simulating-universal-circuits'>7.8.1<!-- tex4ht:ref: sec:stab-decomp  --></a>.
But as we saw here, the simulation overhead was not based on the number of
terms in the decomposition, but rather on the weight <!-- l. 816 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>λ</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1.83</mn></mrow></math>.
This value is known as the <span class='cmbx-10x-x-109'>stabiliser extent</span>, or equivalently, the <span class='cmbx-10x-x-109'>robustness
of magic </span>of the decomposition. Without using any catalysis, we could have
chosen to write each of the <!-- l. 817 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates as a magic state injection, and then replace each of the <!-- l. 817 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mi>T</mi><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>
states by its stabiliser decomposition. When we do this however, the stabiliser
extent scales as <!-- l. 817 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>1.8</mn><msup><mrow><mn>3</mn></mrow><mrow><mi>t</mi></mrow></msup></mrow></math>
where <!-- l. 817 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>t</mi></math>
is the number of <!-- l. 817 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates, so that the simulation overhead becomes exponential in the number
of  non-Clifford  gates.  We  expect  such  an  exponential  dependence,  since
replacing all the <!-- l. 817 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates gives us a Clifford circuit, and we don’t expect this gate set to be
                                                                     

                                                                     
computationally universal. Note that this however does give us a classical
simulation technique: write a Clifford+<!-- l. 817 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
circuit as a Clifford circuit where each <!-- l. 817 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gate is replaced by a magic state injection using the <!-- l. 817 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>ϕ</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
Clifford states, and then efficiently classically simulate each of these Clifford
circuits. The cost of this method is then roughly <!-- l. 817 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>k</mi><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mn>3</mn></mrow></msup><mn>1.8</mn><msup><mrow><mn>3</mn></mrow><mrow><mi>t</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
where <!-- l. 817 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
is the number of qubits, and <!-- l. 817 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
is the total number of gates in the circuit.
</p>
   </div>
<!-- l. 818 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 819 --><p class='noindent'><span class='head'>
<a id='x12-255013r3'></a>
<span class='cmbx-10x-x-109'>Remark* 10.5.3.</span>  </span>We haven’t actually given a formal definition of what
‘computational  universality’  really  is.  There  are  multiple  ways  we  could
define it that all differ in the details. One particular way we could define it,
which we could also call ‘<span class='cmbx-10x-x-109'>BQP</span>-completeness’ is as follows: for a given gate
set <!-- l. 821 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>G</mi></math>
define the complexity class <!-- l. 821 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mstyle class='text'><mtext class='textbf' mathvariant='bold'>BQP</mtext></mstyle></mrow><mrow><mi>G</mi></mrow></msub></math>
as the types of decision problems that can be solved with high probability by
a quantum computer just using gates from <!-- l. 821 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>G</mi></math>.
Then <!-- l. 821 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>G</mi></math>
is <span class='cmbx-10x-x-109'>BQP</span>-complete if <!-- l. 821 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mstyle class='text'><mtext class='textbf' mathvariant='bold'>P</mtext></mstyle></mrow><mrow><msub><mrow><mstyle class='text'><mtext class='textbf' mathvariant='bold'>BQP</mtext></mstyle></mrow><mrow><mi>G</mi></mrow></msub></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mstyle class='text'><mtext class='textbf' mathvariant='bold'>BQP</mtext></mstyle></mrow></math>.
That is, if a classical computer that can query a quantum computer using
gates from <!-- l. 821 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>G</mi></math>
can solve the same problems in polynomial time as a universal quantum
computer.
</p>
   </div>
<!-- l. 822 --><p class='indent'>    Because we can also catalyse <!-- l. 823 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates using a CCZ gate, we can also prove a version of Proposition <a href='#x12-255011r1'>10.5.1<!-- tex4ht:ref: prop:CS-Had-universal  --></a> for the
Clifford+CCZ gate set, showing that Clifford+CCZ is also computationally
universal. In fact, we can restrict the gate set a bit more, as Toffoli+Hadamard is
itself already computationally universal. This however requires a different
argument then we have been using here, and hence we leave this for the advanced
section <a href='#computational-universality-of-toffolihadamard'>10.7.4<!-- tex4ht:ref: sec:real-qc  --></a>.
                                                                     

                                                                     
</p>
   <h4 class='subsectionHead' id='catalysing-completeness'><span class='titlemark'>10.5.3   </span> <a id='x12-25600010.5.3'></a>Catalysing completeness</h4>
<!-- l. 825 --><p class='noindent'>We saw in Theorem <a href='#x12-249004r9'>10.3.9<!-- tex4ht:ref: thm:CNOT+T  --></a> that the (S4) spider nest rule combined with the standard ZX
rules we have been using throughout the book is enough to get a complete set of rules for
CNOT+<!-- l. 825 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> circuits.
However, this extended rule set is <span class='cmti-10x-x-109'>not </span>enough to prove all identities of ZX-diagrams in the
<!-- l. 825 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>-fragment.
For instance, a simple identity that cannot be proven is the following rule known
as <span class='cmbx-10x-x-109'>supplementarity</span>: </p><table class='equation'><tr><td>
<!-- l. 826 --><p class='indent'>
</p><!-- l. 826 --><object id='x12-256001r62' data="svgs/eq-supplementarity.svg" alt="diagram of eq:supplementarity" class="svg-diagram"></object></td><td class='eq-no'>(10.62)</td></tr></table>
<!-- l. 829 --><p class='indent'>   Formally showing that this cannot be proven using the ZX+(S4) rules is difficult,
but intuitively we can see this because none of the standard ZX rules have any special
behaviour for <!-- l. 829 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>
phases, while all the spider nest identities only deal with at least 15
<!-- l. 829 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>
phases, so there is nothing that says anything about the pair of
<!-- l. 829 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>
phases here. Finding a rule set and then proving it is complete is usually
a difficult challenge. However, using catalysis it turns out we can
make our lives much simpler, and simply extend an existing complete
calculus. Recall that in Chapter <a href='main_htmlch9.html#controlled-gates-and-classical-oracles'>9<!-- tex4ht:ref: ch:midlevel  --></a> we introduced a new type of generator
for ZX-diagrams we called H-boxes. In particular we found a number
of rewrite rules for phase-free H-boxes in Section <a href='main_htmlch9.html#rules-for-the-hbox'>9.2.2<!-- tex4ht:ref: sec:zh  --></a>, summarised in
Figure <a href='main_htmlch9.html#the-basic-rules-for-hboxes-'>9.0<!-- tex4ht:ref: fig:zh-rules  --></a>. We remarked there that when we restrict to spiders with
<!-- l. 832 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math> and
<!-- l. 832 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>
phases, together with phase-free H-boxes, that these rules give us a complete
calculus for postselected Toffoli-Hadamard circuits. Such diagrams correspond to
a specific type of matrices. Namely, all such matrices are of the form
<!-- l. 832 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo> <mfrac><mrow><mn>1</mn></mrow>
<mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi>k</mi></mrow></msup><mi>M</mi></mrow></math> where
<!-- l. 832 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math> is an
integer matrix. Hence, the matrix entries are from a subset of the ring
                                                                     

                                                                     
<!-- l. 832 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mn>1</mn><mo class='MathClass-bin' stretchy='false'>∕</mo><msqrt><mrow><mn>2</mn></mrow></msqrt><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>.
As these matrices are just integer matrices up to a global scalar of
<!-- l. 832 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msqrt><mrow>
<mn>2</mn></mrow></msqrt></math> we will call
this the <!-- l. 832 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ℤ</mi></math>
<span class='cmbx-10x-x-109'>fragment</span>. Note that in particular there are no complex numbers in this calculus.
Using catalysis we can make the set of matrices this calculus can represent larger
in a ‘controlled way’ where we can also see which rules we need to add to
preserve completeness. To see how this works, we want to first generalise the
<!-- l. 833 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gate
catalysis of Eq. (<a href='#x12-253001r46'>10.46<!-- tex4ht:ref: eq:cat-CS-T  --></a>). First, as our goal will just be to produce states, we can
plug <!-- l. 833 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext class='MathClass-rel' stretchy='false'>|+⟩</mtext></mrow></math>
into the top wire of Eq. (<a href='#x12-253001r46'>10.46<!-- tex4ht:ref: eq:cat-CS-T  --></a>). We can then simplify the expression to a more
symmetric form: </p><table class='equation'><tr><td>
<!-- l. 834 --><p class='indent'>
</p><!-- l. 834 --><object id='x12-256002r63' data="svgs/eq-cat-CS-T-ZH.svg" alt="diagram of eq:cat-CS-T-ZH" class="svg-diagram"></object></td><td class='eq-no'>(10.63)</td></tr></table>
<!-- l. 837 --><p class='indent'>   We can then identify the underlying reason this catalysis works. It is because:
</p><table class='equation'><tr><td>
<!-- l. 838 --><p class='indent'>
</p><!-- l. 838 --><object id='x12-256003r64' data="svgs/H-box-i-Fourier.svg" alt="diagram of H-box-i-Fourier" class="svg-diagram"></object></td><td class='eq-no'>(10.64)</td></tr></table>
<!-- l. 841 --><p class='indent'>   Here we suggestively used Eq. (<a href='main_htmlch9.html#x11-220010r15'>9.15<!-- tex4ht:ref: Hboxes-as-spiders  --></a>) to write the phases as H-boxes. We do this
because such a rule doesn’t just hold for an H-box with a label that is a complex phase like
<!-- l. 841 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iα</mi></mrow></msup></math>, it in fact holds
for any complex <!-- l. 841 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi><mo class='MathClass-rel' stretchy='false'>≠</mo><mn>0</mn></mrow></math>:
</p><table class='equation'><tr><td>
                                                                     

                                                                     
<!-- l. 842 --><p class='indent'>
</p><!-- l. 842 --><object id='x12-256004r65' data="svgs/eq-H-box-a-Fourier.svg" alt="diagram of eq:H-box-a-Fourier" class="svg-diagram"></object></td><td class='eq-no'>(10.65)</td></tr></table>
<!-- l. 845 --><p class='indent'>   This then allows us to write down a generalisation of Eq. (<a href='#x12-256002r63'>10.63<!-- tex4ht:ref: eq:cat-CS-T-ZH  --></a>) to arbitrary
H-boxes: </p><table class='equation'><tr><td>
<!-- l. 846 --><p class='indent'>
</p><!-- l. 846 --><object id='x12-256005r66' data="svgs/eq-H-box-catalysis.svg" alt="diagram of eq:H-box-catalysis" class="svg-diagram"></object></td><td class='eq-no'>(10.66)</td></tr></table>
<!-- l. 849 --><p class='indent'>   Here we wrote <!-- l. 849 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>a</mi></mrow><mrow><mn>2</mn></mrow></msup></math> in the
2-ary H-box instead of <!-- l. 849 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>a</mi></math>
so that we don’t have to work with square roots. When we take
<!-- l. 849 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></msup></mrow></math> we get
Eq. (<a href='#x12-256002r63'>10.63<!-- tex4ht:ref: eq:cat-CS-T-ZH  --></a>), but this works for any value. A particularly simple, but still interesting case
is when <!-- l. 849 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> </mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>i</mi></mrow></math>.
Translating this back into circuit form gives us a catalysis of
<!-- l. 849 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>i</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>i</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
states using a CZ. While this might seem trivial (it is after all provable using
Clifford rewrite rules) in the context of the phase-free H-boxes it allows us to add
complex numbers to the fragment. Namely, we can just add as a generator
<!-- l. 850 --><img src="svgs/H-box-i.svg" alt="diagram of H-box-i" class="inline-diagram" />, a single-ary
H-box with label <!-- l. 852 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>i</mi></mrow></math>
to the calculus, and this in fact turns out to be sufficient to then represent any matrix
<!-- l. 852 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mfrac><mrow><mn>1</mn></mrow>
<mrow><msup><mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow><mrow><mi>k</mi></mrow></msup></mrow></mfrac><mi>M</mi></mrow></math> where
<!-- l. 852 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math> now has entries
in <!-- l. 852 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>i</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>. We will
call this the <!-- l. 852 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>i</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
                                                                     

                                                                     
fragment. However, just getting this <span class='cmti-10x-x-109'>universality </span>was the easy part. How do we
know what new equations to add to this calculus to make it complete again?
Generally, proving completeness is very difficult, as you first need to search for
new equations, and then show that those equations are sufficient to prove all
true equalities. However, as it turns out, adding the rule Eq. (<a href='#x12-256005r66'>10.66<!-- tex4ht:ref: eq:H-box-catalysis  --></a>) for
<!-- l. 852 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>i</mi></mrow></math>
to the already existing rules for the label-free fragment is already
<span class='cmti-10x-x-109'>almost </span>enough to get a complete calculus for this bigger fragment
<!-- l. 852 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>i</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math> which
includes <!-- l. 852 --><img src="svgs/H-box-i.svg" alt="diagram of H-box-i" class="inline-diagram" />.
To see this, let’s first consider what a generic diagram in the
<!-- l. 855 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>i</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math> fragment looks like. We
added the generator <!-- l. 855 --><img src="svgs/H-box-i.svg" alt="diagram of H-box-i" class="inline-diagram" />,
so now a diagram consists of generators from the old phase-free fragment
plus this new generator. These generators could all combine to give us
really complicated rewrites, so we want to prevent them from combining.
Using Eq. (<a href='#x12-256005r66'>10.66<!-- tex4ht:ref: eq:H-box-catalysis  --></a>) we can reduce all these separate instances of
<!-- l. 857 --><img src="svgs/H-box-i.svg" alt="diagram of H-box-i" class="inline-diagram" /> into just
one of them, reducing the complexity of the diagram. That is, given some diagram
<!-- l. 859 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>D</mi></math> in the
<!-- l. 859 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>i</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math> fragment, we can rewrite
it to a diagram <!-- l. 859 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>D</mi></mrow><mrow><mi>′</mi></mrow></msup></math> containing
just generators from the <!-- l. 859 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ℤ</mi></math>
fragment such that: </p><table class='equation'><tr><td>
<!-- l. 860 --><p class='indent'>
</p><!-- l. 860 --><object id='x12-256006r67' data="svgs/eq-diagram-catalysis-i.svg" alt="diagram of eq:diagram-catalysis-i" class="svg-diagram"></object></td><td class='eq-no'>(10.67)</td></tr></table>
<!-- l. 863 --><p class='indent'>   Or, as it turns out, this is possible for <span class='cmti-10x-x-109'>most </span>diagrams in the
<!-- l. 863 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>i</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
fragment (Can you see for which ones it doesn’t work? If not, don’t worry, the
authors of this book also originally forgot about this case. As we said:
completeness is hard). We will talk about the failing case later, but for now let’s
assume that our diagram satisfies Eq. (<a href='#x12-256006r67'>10.67<!-- tex4ht:ref: eq:diagram-catalysis-i  --></a>). As a shorthand, we will write
<!-- l. 864 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>D</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math> for the diagram we
get when we plug <!-- l. 864 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
                                                                     

                                                                     
into the bottom input in Eq. (<a href='#x12-256006r67'>10.67<!-- tex4ht:ref: eq:diagram-catalysis-i  --></a>). So here we have
<!-- l. 864 --><img src="svgs/H-box-i-1.svg" alt="diagram of H-box-i-1" class="inline-diagram" />. Note
that <!-- l. 867 --><img src="svgs/H-box-i-2.svg" alt="diagram of H-box-i-2" class="inline-diagram" />.
Hence, if we expand it like this we see that
<!-- l. 869 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>D</mi></math> is equal to a sum of
two diagrams: <!-- l. 869 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>D</mi></mrow><mrow><mi>′</mi></mrow></msup></math> where
we plugged in <!-- l. 869 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> into the
bottom wire, and <!-- l. 869 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>i</mi><msup><mrow><mi>D</mi></mrow><mrow><mi>′</mi></mrow></msup></mrow></math> where we
plugged <!-- l. 869 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> into the bottom
wire: <!-- l. 869 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>D</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>D</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>]</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>i</mi><msup><mrow><mi>D</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>. Now suppose
we have two diagrams <!-- l. 870 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>D</mi></mrow><mrow><mn>1</mn></mrow></msub></math>
and <!-- l. 870 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>D</mi></mrow><mrow><mn>2</mn></mrow></msub></math> in
the <!-- l. 870 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>i</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
fragment and that they implement the same linear map:
<!-- l. 870 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>D</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>D</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></math>.
We can both decompose them as described above to get
<!-- l. 870 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mrow><mi>D</mi></mrow><mrow><mn>1</mn></mrow><mrow><mi>′</mi></mrow></msubsup><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>]</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>i</mi><msubsup><mrow><mi>D</mi></mrow><mrow><mn>1</mn></mrow><mrow><mi>′</mi></mrow></msubsup><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>]</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msubsup><mrow><mi>D</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>′</mi></mrow></msubsup><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>]</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>i</mi><msubsup><mrow><mi>D</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>′</mi></mrow></msubsup><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>. Each of
these <!-- l. 870 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mrow><mi>D</mi></mrow><mrow><mi>j</mi></mrow><mrow><mi>′</mi></mrow></msubsup><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
diagrams represents a matrix that is entirely real, so the only way for this
equation of complex matrices to hold, is if it holds for the real part and for the
complex part separately: </p><table class='equation'><tr><td>
<!-- l. 871 --><p class='indent'>
</p><!-- l. 871 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                  <mstyle class='label' id='x12-256007r68'></mstyle><!-- endlabel --><msubsup><mrow><mi>D</mi></mrow><mrow><mn>1</mn></mrow><mrow><mi>′</mi></mrow></msubsup><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>]</mo><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><msubsup><mrow><mi>D</mi></mrow><mrow>
<mn>2</mn></mrow><mrow><mi>′</mi></mrow></msubsup><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>]</mo><mspace class='qquad' width='2em'></mspace><mspace class='quad' width='1em'></mspace><msubsup><mrow><mi>D</mi></mrow><mrow>
<mn>1</mn></mrow><mrow><mi>′</mi></mrow></msubsup><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>]</mo><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><msubsup><mrow><mi>D</mi></mrow><mrow>
<mn>2</mn></mrow><mrow><mi>′</mi></mrow></msubsup><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>]</mo>
</mrow></math></td><td class='eq-no'>(10.68)</td></tr></table>
<!-- l. 874 --><p class='indent'>   We then conclude that <!-- l. 874 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msubsup><mrow><mi>D</mi></mrow><mrow><mn>1</mn></mrow><mrow><mi>′</mi></mrow></msubsup></math>
and <!-- l. 874 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msubsup><mrow><mi>D</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>′</mi></mrow></msubsup></math> are equal when
we input either <!-- l. 874 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
or <!-- l. 874 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
into the bottom wire. As these states form a basis, this must then hold for
any input. We can then leave this wire open and still have an equality:
</p><table class='equation'><tr><td>
<!-- l. 875 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 875 --><object id='x12-256008r69' data="svgs/eq-diagram-catalysis-equality.svg" alt="diagram of eq:diagram-catalysis-equality" class="svg-diagram"></object></td><td class='eq-no'>(10.69)</td></tr></table>
<!-- l. 878 --><p class='indent'>   Now we are in business! We have this equality as linear maps, but both diagrams
are in the <!-- l. 878 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ℤ</mi></math>
fragment for which we have completeness. We hence know how to rewrite
one into the other. This gives us then a path to rewrite the original
<!-- l. 878 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>D</mi></mrow><mrow><mn>1</mn></mrow></msub></math> into
<!-- l. 878 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>D</mi></mrow><mrow><mn>2</mn></mrow></msub></math>:
</p><table class='equation'><tr><td>
<!-- l. 879 --><p class='indent'>
</p><!-- l. 879 --><object id='x12-256009r70' data="svgs/eq-diagram-catalysis-completeness.svg" alt="diagram of eq:diagram-catalysis-completeness" class="svg-diagram"></object></td><td class='eq-no'>(10.70)</td></tr></table>
<!-- l. 882 --><p class='indent'>   Here each equality is now a diagrammatic equality, and with (*) we
denote we are using rewrites from the original complete calculus for the
<!-- l. 882 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ℤ</mi></math>
fragment. We have then very easily proven completeness for this larger fragment,
all made possible using a single rule about catalysis. Well..., we would have
proven completeness, <span class='cmti-10x-x-109'>if  </span>it were true we could always rewrite a diagram in the
<!-- l. 883 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>i</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
fragment as in Eq. (<a href='#x12-256006r67'>10.67<!-- tex4ht:ref: eq:diagram-catalysis-i  --></a>). We however made a hidden assumption: that there is
at least one generator <img src="svgs/H-box-i-3.svg" alt="diagram of H-box-i-3" class="inline-diagram" /> present in the diagram. When that is
the case we can use Eq. (<a href='#x12-256005r66'>10.66<!-- tex4ht:ref: eq:H-box-catalysis  --></a>) to reduce all these instances of the generator to
just a single copy. But if the diagram didn’t contain any <img src="svgs/H-box-i-3.svg" alt="diagram of H-box-i-3" class="inline-diagram" />
to start with, then this rule does not apply. In fact, we currently have
no rewrite rules that relate a diagram containing a <img src="svgs/H-box-i-3.svg" alt="diagram of H-box-i-3" class="inline-diagram" />
to one that does not contain any <img src="svgs/H-box-i-3.svg" alt="diagram of H-box-i-3" class="inline-diagram" /> . This means in
particular that our current rule set cannot prove the following true equation:
</p><table class='equation'><tr><td>
                                                                     

                                                                     
<!-- l. 892 --><p class='indent'>
</p><!-- l. 892 --><object id='x12-256010r71' data="svgs/eq-X-H-i-empty.svg" alt="diagram of eq:X-H-i-empty" class="svg-diagram"></object></td><td class='eq-no'>(10.71)</td></tr></table>
<!-- l. 895 --><p class='indent'>   However, when we also add Eq. (<a href='#x12-256010r71'>10.71<!-- tex4ht:ref: eq:X-H-i-empty  --></a>) as an additional rule, then this
problem is solved and it <span class='cmti-10x-x-109'>is </span>true that we can then always rewrite a diagram in the
<!-- l. 895 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>i</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
fragment as in Eq. (<a href='#x12-256006r67'>10.67<!-- tex4ht:ref: eq:diagram-catalysis-i  --></a>): if the diagram contains at least one <img src="svgs/H-box-i-3.svg" alt="diagram of H-box-i-3" class="inline-diagram" />
we can already use Eq. (<a href='#x12-256005r66'>10.66<!-- tex4ht:ref: eq:H-box-catalysis  --></a>) to transform to the form of Eq. (<a href='#x12-256006r67'>10.67<!-- tex4ht:ref: eq:diagram-catalysis-i  --></a>), and if it
doesn’t we use Eq. (<a href='#x12-256010r71'>10.71<!-- tex4ht:ref: eq:X-H-i-empty  --></a>) once to introduce one <img src="svgs/H-box-i-3.svg" alt="diagram of H-box-i-3" class="inline-diagram" /> , in which
case it is also in the form of Eq. (<a href='#x12-256006r67'>10.67<!-- tex4ht:ref: eq:diagram-catalysis-i  --></a>).
</p>
   <div class='newtheorem'>
<!-- l. 900 --><p class='noindent'><span class='head'>
<a id='x12-256011r4'></a>
<span class='cmbx-10x-x-109'>Proposition 10.5.4.</span>  </span>The <!-- l. 901 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ℤ</mi></math>
fragment of Z- and X-spiders with <!-- l. 901 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math>
and <!-- l. 901 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>
phases and phase-free H-boxes, augmented with the <!-- l. 901 --><img src="svgs/H-box-i.svg" alt="diagram of H-box-i" class="inline-diagram" />
generator, the catalysis rule Eq. (<a href='#x12-256005r66'>10.66<!-- tex4ht:ref: eq:H-box-catalysis  --></a>) for <!-- l. 903 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>i</mi></mrow></math>,
and the rule <img src="svgs/X-H-i-empty.svg" alt="diagram of X-H-i-empty" class="inline-diagram" /> is complete for matrices of the form
<!-- l. 905 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mfrac><mrow><mn>1</mn></mrow>
<mrow><msup><mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow><mrow><mi>k</mi></mrow></msup></mrow></mfrac><mi>M</mi></mrow></math>
where <!-- l. 905 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math>
has entries in <!-- l. 905 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>i</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>.
</p>
   </div>
<!-- l. 906 --><p class='indent'>    This trick for extending the calculus doesn’t just work for
<!-- l. 907 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math>: it works for any
complex number <!-- l. 907 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi><mo class='MathClass-rel' stretchy='false'>≠</mo><mn>0</mn></mrow></math>
such that <!-- l. 907 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>a</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi></mrow></math>. Let’s
for example take <!-- l. 907 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msqrt><mrow><mn>3</mn></mrow></msqrt></mrow></math>.
We can then do all the steps as before, translating a diagram
<!-- l. 907 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>D</mi></math>
                                                                     

                                                                     
containing an arbitrary number of the H-box with label
<!-- l. 907 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msqrt><mrow>
<mn>3</mn></mrow></msqrt></math> into a
diagram <!-- l. 907 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>D</mi></mrow><mrow><mi>′</mi></mrow></msup></math>
in the <!-- l. 907 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ℤ</mi></math>
fragment which just requires a single input of the
<!-- l. 907 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msqrt><mrow>
<mn>3</mn></mrow></msqrt></math> H-box:
<!-- l. 907 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>D</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>D</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <msqrt><mrow><mn>3</mn></mrow></msqrt><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>]</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>D</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>]</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <msqrt><mrow><mn>3</mn></mrow></msqrt><msup><mrow><mi>D</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>.
If we then have an equality between two diagrams
<!-- l. 907 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>D</mi></mrow><mrow><mn>1</mn></mrow></msub></math> and
<!-- l. 907 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>D</mi></mrow><mrow><mn>2</mn></mrow></msub></math> in the
<!-- l. 907 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><msqrt><mrow><mn>3</mn></mrow></msqrt><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math> fragment,
we get <!-- l. 907 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mrow><mi>D</mi></mrow><mrow><mn>1</mn></mrow><mrow><mi>′</mi></mrow></msubsup><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>]</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <msqrt><mrow><mn>3</mn></mrow></msqrt><msubsup><mrow><mi>D</mi></mrow><mrow><mn>1</mn></mrow><mrow><mi>′</mi></mrow></msubsup><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>]</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msubsup><mrow><mi>D</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>′</mi></mrow></msubsup><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>]</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <msqrt><mrow><mn>3</mn></mrow></msqrt><msubsup><mrow><mi>D</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>′</mi></mrow></msubsup><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>.
Because each of the component diagrams only contains
integers, this equation can only hold if the integer part and the
<!-- l. 907 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msqrt><mrow>
<mn>3</mn></mrow></msqrt></math>
part hold separately. We hence again get two equalities
<!-- l. 907 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mrow><mi>D</mi></mrow><mrow><mn>1</mn></mrow><mrow><mi>′</mi></mrow></msubsup><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>]</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msubsup><mrow><mi>D</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>′</mi></mrow></msubsup><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math> and
<!-- l. 907 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mrow><mi>D</mi></mrow><mrow><mn>1</mn></mrow><mrow><mi>′</mi></mrow></msubsup><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>]</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msubsup><mrow><mi>D</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>′</mi></mrow></msubsup><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>, which allows us
to conclude that <!-- l. 907 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mrow><mi>D</mi></mrow><mrow><mn>1</mn></mrow><mrow><mi>′</mi></mrow></msubsup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msubsup><mrow><mi>D</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>′</mi></mrow></msubsup></mrow></math>
with the wire left open. We can then use a modified version of Eq. (<a href='#x12-256009r70'>10.70<!-- tex4ht:ref: eq:diagram-catalysis-completeness  --></a>) to
conclude that we have completeness. We also have a modified version of
Eq. (<a href='#x12-256010r71'>10.71<!-- tex4ht:ref: eq:X-H-i-empty  --></a>) that continues to be true: <img src="svgs/X-H-sqrt3-empty.svg" alt="diagram of X-H-sqrt3-empty" class="inline-diagram" /> . Adding the
catalysis rule and this scalar rule then gives us a complete calculus for the ring
<!-- l. 909 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><msqrt><mrow><mn>3</mn></mrow></msqrt><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>. Although this
covers many possible extensions, it does not cover one we care about: extending it with a
<!-- l. 910 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gate. This is
because taking <!-- l. 910 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></msup></mrow></math>
we see that <!-- l. 910 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>a</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>i</mi><mo class='MathClass-rel' stretchy='false'>∉</mo><mi>ℤ</mi></mrow></math>.
However, it turns out we can just iterate the catalysis procedure to
get larger and larger calculi. Starting now with the calculus for the
<!-- l. 910 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>i</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
fragment, we can add the H-box with the label
<!-- l. 910 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></msup></math>
and add its catalysis rule. When we then go through the motions
of the completeness proof again we will end up at the equation
<!-- l. 910 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mrow><mi>D</mi></mrow><mrow><mn>1</mn></mrow><mrow><mi>′</mi></mrow></msubsup><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>]</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></msup><msubsup><mrow><mi>D</mi></mrow><mrow><mn>1</mn></mrow><mrow><mi>′</mi></mrow></msubsup><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>]</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msubsup><mrow><mi>D</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>′</mi></mrow></msubsup><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>]</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></msup><msubsup><mrow><mi>D</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>′</mi></mrow></msubsup><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>, where now each of
the diagrams <!-- l. 910 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mrow><mi>D</mi></mrow><mrow><mi>j</mi></mrow><mrow><mi>′</mi></mrow></msubsup><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math> has
entries in <!-- l. 910 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>i</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math> instead
of <!-- l. 910 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ℤ</mi></math>. Luckily for us,
<!-- l. 910 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></msup></math> is still ‘independent’
of the entries of <!-- l. 910 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>i</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
so that again the only way for this equation to hold is if it holds for each
component separately, so that the proof goes through without change. Since
<!-- l. 911 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>i</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>∕</mo><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></math>,
                                                                     

                                                                     
this calculus can represent arbitrary matrices with entries in the ring
<!-- l. 911 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>i</mi><mo class='MathClass-punc' stretchy='false'>,</mo>  <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>.
</p>
   <div class='newtheorem'>
<!-- l. 912 --><p class='noindent'><span class='head'>
<a id='x12-256012r5'></a>
<span class='cmbx-10x-x-109'>Theorem 10.5.5.</span>  </span>The <!-- l. 913 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ℤ</mi></math>
fragment of Z- and X-spiders with <!-- l. 913 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math>
and <!-- l. 913 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>
phases and phase-free H-boxes, augmented with H-boxes with a label of
<!-- l. 913 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math>
and <!-- l. 913 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></msup></math>
and the catalysis rule Eq. (<a href='#x12-256005r66'>10.66<!-- tex4ht:ref: eq:H-box-catalysis  --></a>) and scalar rule <img src="svgs/X-H-a-empty.svg" alt="diagram of X-H-a-empty" class="inline-diagram" /> for
<!-- l. 915 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>i</mi></mrow></math>
and <!-- l. 915 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></msup></mrow></math>
is complete for matrices with entries in the ring <!-- l. 915 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>i</mi><mo class='MathClass-punc' stretchy='false'>,</mo>  <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>.
</p>
   </div>
<!-- l. 916 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 917 --><p class='noindent'><span class='head'>
<a id='x12-256013r11'></a>
<span class='cmbx-10x-x-109'>Exercise* 10.11.</span>  </span>Two                   copies                   of                   a
<!-- l. 918 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></msup></math>
H-box     can     be     used     to     represent     an     H-box     with     an
<!-- l. 918 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math>
label.             So             instead             of             adding             the
<!-- l. 918 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math>
generator,            we            could            only            add            the
<!-- l. 918 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></msup></math>
generator.  We  then  have  to  modify  the  catalysis  rules:  instead  of
having   two   separate   ones,   we   need   to   stack   them   together   into
a   single   one.   Find   a   modified   catalysis   rule   that   works   in   the
label-free  ZH-calculus  augmented  with  just  an  H-box  with  a  label  of
<!-- l. 918 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></msup></math>
and find which other rules you need to get completeness.
</p>
   </div>
                                                                     

                                                                     
<!-- l. 919 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 920 --><p class='noindent'><span class='head'>
<a id='x12-256014r12'></a>
<span class='cmbx-10x-x-109'>Exercise* 10.12.</span>  </span>Prove  supplementarity (<a href='#x12-256001r62'>10.62<!-- tex4ht:ref: eq:supplementarity  --></a>)  using  the  phase-free
H-box rules and the catalysis rules.
</p>
   </div>
<!-- l. 922 --><p class='indent'>
</p>
   <h3 class='sectionHead' id='summary-what-to-remember8'><span class='titlemark'>10.6   </span> <a id='x12-25700010.6'></a>Summary: What to remember</h3>
<!-- l. 925 --><p class='noindent'>
     </p><dl class='enumerate'><dt class='enumerate'>
  1.. </dt><dd class='enumerate'>
     <!-- l. 925 --><p class='noindent'>The Clifford+<!-- l. 925 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
     gate set is approximately universal.
     </p></dd><dt class='enumerate'>
  2.. </dt><dd class='enumerate'>
     <!-- l. 926 --><p class='noindent'>In particular, it can exactly represent unitary <!-- l. 926 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>×</mo> <msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></math>
     matrices with entries in the ring <!-- l. 926 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mfrac><mrow><mn>1</mn></mrow>
<mrow><mn>2</mn></mrow></mfrac><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></msup><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>.
     </p></dd><dt class='enumerate'>
  3.. </dt><dd class='enumerate'>
     <!-- l. 927 --><p class='noindent'>We can efficiently approximately synthesise single-qubit unitaries over
     the Clifford+<!-- l. 927 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
     gate set. To achieve a precision of <!-- l. 927 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>𝜀</mi></math>
     requires <!-- l. 927 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --><mn>1</mn><mo class='MathClass-bin' stretchy='false'>∕</mo><mi>𝜀</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
     number of gates.
     </p></dd><dt class='enumerate'>
  4.. </dt><dd class='enumerate'>
     <!-- l. 928 --><p class='noindent'>The scalable ZX notation allows us to represent large collections of
     parities as a single diagram. This is especially useful in representing
     large collections of phase gadgets.
                                                                     

                                                                     
     </p></dd><dt class='enumerate'>
  5.. </dt><dd class='enumerate'>
     <!-- l. 929 --><p class='noindent'>Certain collections of phase gadgets with phases that are multiples of
     <!-- l. 929 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>
     correspond to Clifford unitaries or the identity. We call such collections
     of phase gadgets <span class='cmti-10x-x-109'>spider nest identities</span>.
     </p></dd><dt class='enumerate'>
  6.. </dt><dd class='enumerate'>
     <!-- l. 930 --><p class='noindent'>A collection of gadgets represents an identity if its corresponding parity
     matrix is <span class='cmti-10x-x-109'>strongly 3-even</span>, meaning that the Hamming weight of every
     column is a multiple of <!-- l. 930 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>8</mn></math>,
     of the product of every pair of columns is a multiple of <!-- l. 930 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>4</mn></math>,
     and the product of every triple of columns is a multiple of <!-- l. 930 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>2</mn></math>.
     The collection of gadgets is a Clifford if it’s parity matrix is <span class='cmti-10x-x-109'>3-even</span>,
     meaning that the three previous conditions only hold modulo 2.
     </p></dd><dt class='enumerate'>
  7.. </dt><dd class='enumerate'>
     <!-- l. 931 --><p class='noindent'>We can instead represent a collection of <!-- l. 931 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit
     gadgets by its indicator function. If this is a polynomial of degree at
     most <!-- l. 931 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>4</mn></mrow></math>,
     then it is equal to a Clifford.
     </p></dd><dt class='enumerate'>
  8.. </dt><dd class='enumerate'>
     <!-- l. 932 --><p class='noindent'>Using this representation we can show that the standard ZX rewrite
     rules plus one additional rule (S4) suffice for completeness of CNOT+<!-- l. 932 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
     circuits.
     </p></dd><dt class='enumerate'>
  9.. </dt><dd class='enumerate'>
     <!-- l. 933 --><p class='noindent'>Optimising the number of <!-- l. 933 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
     gates in a CNOT+<!-- l. 933 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
     circuit is equivalent to decoding a Reed-Muller code, or equivalently
     to finding a rank decomposition of a symmetric 3-tensor.
     </p></dd><dt class='enumerate'>
 10.. </dt><dd class='enumerate'>
     <!-- l. 934 --><p class='noindent'>We can relate gate sets involving the CCZ, CS or <!-- l. 934 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
     gate together using the framework of <span class='cmti-10x-x-109'>catalysis</span>, where we can interchange
     the role of one gate with another using a resource state that we call a
     <span class='cmti-10x-x-109'>catalyst</span>. This catalyst is not consumed in the process and hence can
     be reused.
                                                                     

                                                                     
     </p></dd><dt class='enumerate'>
 11.. </dt><dd class='enumerate'>
     <!-- l. 935 --><p class='noindent'>Using catalysis we can find an efficient way to implement small-angle
     rotations, prove the computational universality of a gate set, and prove
     completeness by extending other complete rule sets. </p></dd></dl>
<!-- l. 937 --><p class='noindent'>
</p>
   <h3 class='sectionHead' id='advanced-material5'><span class='titlemark'>10.7   </span> <a id='x12-25800010.7'></a>Advanced Material*</h3>
<!-- l. 938 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='exact-synthesis-of-cliffordt-states'><span class='titlemark'>10.7.1   </span> <a id='x12-25900010.7.1'></a>Exact synthesis of Clifford+T states*</h4>
<!-- l. 940 --><p class='noindent'>In this section we will take another look at the exact synthesis algorithm for
Clifford+<!-- l. 940 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
unitaries described in Section <a href='#exact-synthesis-of-onequbit-gates'>10.1.1<!-- tex4ht:ref: sec:exact-synth-one-qubit  --></a>, but now we will consider multi-qubit unitaries
and fill in the number theory details. As we saw in that section, when we understand
how to synthesise a <span class='cmti-10x-x-109'>state</span>, an algorithm for synthesising a unitary follows easily, so
let’s look at synthesising states first. So let’s suppose we have a normalised vector
<!-- l. 941 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>𝔻</mi><msup><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow><mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup>
   </mrow></msup></mrow></math>. Our task is to
find a Clifford+<!-- l. 941 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
unitary <!-- l. 941 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math> such
that <!-- l. 941 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>U</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>. Writing
<!-- l. 942 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>ψ</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo class='MathClass-rel' stretchy='false'>⋯</mo><mspace class='thinspace' width='0.17em'></mspace><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>ψ</mi></mrow><mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> we can represent the
vector components <!-- l. 942 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>ψ</mi></mrow><mrow><mi>i</mi></mrow></msub></math>
as <!-- l. 942 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>ψ</mi></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>a</mi></mrow><mrow><mi>i</mi></mrow></msub><msup><mrow><mi>ω</mi></mrow><mrow><mn>3</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>b</mi></mrow><mrow><mi>i</mi></mrow></msub><msup><mrow><mi>ω</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>c</mi></mrow><mrow><mi>i</mi></mrow></msub><mi>ω</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>d</mi></mrow><mrow><mi>i</mi></mrow></msub></mrow></math> where
<!-- l. 942 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>a</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>b</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>c</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>d</mi></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>𝔻</mi></mrow></math>.
In Lemma <a href='#x12-242001r2'>10.1.2<!-- tex4ht:ref: lem:norm-Zom-unit  --></a> we saw that if these coefficients are integers,
that then all the entries except one must be zero and hence
<!-- l. 943 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> is a
unit vector. For a single-qubit state, the only possible unit vectors are
<!-- l. 943 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> and
<!-- l. 943 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>, so if we got
<!-- l. 943 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> we just apply
an <!-- l. 943 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math> gate to get
it to be the <!-- l. 943 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
we want. However, now the state can be any
<!-- l. 943 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> up to global phase.
We can map this to <!-- l. 944 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mn>0</mn></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
by applying <!-- l. 944 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>
gates wherever <!-- l. 944 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>.
                                                                     

                                                                     
While this is fine if we are synthesising a state, this messes things
up when we are synthesising this state as part of a bigger unitary
synthesis routine where we care about many columns being sent to the
right location. In that case we need to apply the appropriate <span class='cmti-10x-x-109'>2-cycle</span>
classical gate (see Section* <a href='main_htmlch9.html#level-operators'>9.7.2<!-- tex4ht:ref: sec:2-level-op  --></a> for how these can decomposed into
Clifford+<!-- l. 944 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates),
to transform <!-- l. 944 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
into <!-- l. 944 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mn>0</mn></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>,
or whatever basis state we need it to be. We can also get rid of its phase
<!-- l. 944 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>ω</mi></mrow><mrow><mi>k</mi></mrow></msup></math> by applying
the 1-level <!-- l. 944 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msubsup><mrow><mi>T</mi></mrow><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>]</mo></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi>k</mi></mrow></msubsup></math> gate
that adds a <!-- l. 944 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>ω</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi>k</mi></mrow></msup></math>
phase just to the <!-- l. 944 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>00</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
state. Because these 2-level and 1-level operations only change the basis states we
are interested in, they do not mess up any of the other columns of the unitary we
are synthesising. So as in the single-qubit case, if all the components in the
vector are integers we are essentially done. We then just need to find a
strategy to make the vectors be ‘closer to being integers’, i.e. elements of
<!-- l. 945 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>.
The obvious metric for how far an element in
<!-- l. 946 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math> is from being an
element in <!-- l. 946 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math> is the
smallest power of <!-- l. 946 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>2</mn></math>
we have to multiply the element with to get an integer. However,
this turns out not to be the best choice. This is because
<!-- l. 947 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>2</mn></math> is not a <span class='cmti-10x-x-109'>prime number</span>
in <!-- l. 947 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>. The ‘magic number’
<!-- l. 947 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>δ</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>ω</mi></mrow></math> we saw in Section <a href='#exact-synthesis-of-onequbit-gates'>10.1.1<!-- tex4ht:ref: sec:exact-synth-one-qubit  --></a>
<span class='cmti-10x-x-109'>is </span>a prime in <!-- l. 947 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>.
</p>
   <div class='newtheorem'>
<!-- l. 948 --><p class='noindent'><span class='head'>
<a id='x12-259001r1'></a>
<span class='cmbx-10x-x-109'>Definition 10.7.1.</span>  </span>Let <!-- l. 949 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>R</mi></math>
be a ring and <!-- l. 949 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>R</mi></mrow></math>.
We say <!-- l. 949 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>a</mi></math>
is a <span class='cmbx-10x-x-109'>unit </span>if there exists <!-- l. 949 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>b</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>R</mi></mrow></math>
such that <!-- l. 949 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>ab</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>.
We instead say <!-- l. 949 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>a</mi></math>
is <span class='cmbx-10x-x-109'>prime </span>if <!-- l. 949 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>a</mi></math>
is not a unit or <!-- l. 949 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math>,
and if for any decomposition <!-- l. 949 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi mathvariant='italic'>bc</mi></mrow></math>
                                                                     

                                                                     
with <!-- l. 949 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>b</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>c</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>R</mi></mrow></math>
we have that either <!-- l. 949 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>b</mi></math>
or <!-- l. 949 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>c</mi></math>
is a unit.
</p>
   </div>
<!-- l. 950 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 951 --><p class='noindent'><span class='head'>
<a id='x12-259002r2'></a>
<span class='cmbx-10x-x-109'>Example 10.7.2.</span>  </span>In <!-- l. 952 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ℤ</mi></math>
the only units are <!-- l. 952 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>
and <!-- l. 952 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math>,
while in any field, like <!-- l. 952 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ℂ</mi></math>,
every non-zero element is a unit. The primes of <!-- l. 952 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ℤ</mi></math>
are precisely the prime numbers and their negations (since if <!-- l. 952 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>a</mi></math>
is prime, then multiplying <!-- l. 952 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>a</mi></math>
by any unit gives you another prime). In <!-- l. 952 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
examples of units are <!-- l. 952 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ω</mi></math>,
because <!-- l. 952 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ω</mi><msup><mrow><mi>ω</mi></mrow><mrow><mn>7</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>,
and <!-- l. 952 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>1</mn> <mo class='MathClass-bin' stretchy='false'>+</mo> <msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></math>,
because <!-- l. 952 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn> <mo class='MathClass-bin' stretchy='false'>+</mo> <msqrt><mrow><mn>2</mn></mrow></msqrt><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-open' stretchy='false'>(</mo><msqrt><mrow><mn>2</mn></mrow></msqrt> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>.
</p>
   </div>
<!-- l. 953 --><p class='indent'>    We can prove <!-- l. 954 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math> is
prime in <!-- l. 954 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math> by defining a
new kind of norm on <!-- l. 954 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>.
</p>
   <div class='newtheorem'>
<!-- l. 955 --><p class='noindent'><span class='head'>
<a id='x12-259003r13'></a>
<span class='cmbx-10x-x-109'>Exercise 10.13.</span>  </span>On the ring <!-- l. 956 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
we have a norm given by <!-- l. 956 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>N</mi></mrow><mrow><mi>ω</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mi>z</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>z</mi><mover accent='false' class='mml-overline'><mrow><mi>z</mi></mrow><mo accent='true'>¯</mo></mover></mrow></math>.
This norm has some nice properties, namely that it is multiplicative,
<!-- l. 956 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>N</mi></mrow><mrow><mi>ω</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>z</mi></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mi>z</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>N</mi></mrow><mrow><mi>ω</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>z</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><msub><mrow><mi>N</mi></mrow><mrow><mi>ω</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>z</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>,
and that it sends elements to positive elements of
<!-- l. 956 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><msqrt><mrow><mn>2</mn></mrow></msqrt><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>.
We can define a different norm with similar properties on
                                                                     

                                                                     
<!-- l. 956 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><msqrt><mrow><mn>2</mn></mrow></msqrt><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>. For
<!-- l. 956 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>b</mi><msqrt><mrow><mn>2</mn></mrow></msqrt> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><msqrt><mrow><mn>2</mn></mrow></msqrt><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math> define the conjugate
to be <!-- l. 956 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>a</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>b</mi><msqrt><mrow><mn>2</mn></mrow></msqrt><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi>′</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>a</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>b</mi><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></math>, and then define
the new norm by <!-- l. 956 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>N</mi></mrow><mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mi>z</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>z</mi><msup><mrow><mi>z</mi></mrow><mrow><mi>′</mi></mrow></msup></mrow></math>.
   </p><dl class='enumerate'><dt class='enumerate'>
a) </dt><dd class='enumerate'>
   <!-- l. 958 --><p class='noindent'>Show that the conjugate on <!-- l. 958 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><msqrt><mrow><mn>2</mn></mrow></msqrt><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
   is multiplicative: <!-- l. 958 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>z</mi></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mi>z</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi>′</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msubsup><mrow><mi>z</mi></mrow><mrow><mn>1</mn></mrow><mrow><mi>′</mi></mrow></msubsup><msubsup><mrow><mi>z</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>′</mi></mrow></msubsup></mrow></math>.
   Use this to show that the norm <!-- l. 958 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>N</mi></mrow><mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></msub></math>
   is multiplicative.
   </p></dd><dt class='enumerate'>
b) </dt><dd class='enumerate'>
   <!-- l. 959 --><p class='noindent'>For <!-- l. 959 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>z</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
   define <!-- l. 959 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>N</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>z</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>N</mi></mrow><mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>N</mi></mrow><mrow><mi>ω</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mi>z</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>z</mi><mover accent='false' class='mml-overline'><mrow><mi>z</mi></mrow><mo accent='true'>¯</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>z</mi><mover accent='false' class='mml-overline'><mrow><mi>z</mi></mrow><mo accent='true'>¯</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi>′</mi></mrow></msup></mrow></math>.
   Argue that <!-- l. 959 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>N</mi></math>
   is also multiplicative, and that it maps all <!-- l. 959 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>z</mi></math>
   to positive integers.
   </p></dd><dt class='enumerate'>
c) </dt><dd class='enumerate'>
   <!-- l. 960 --><p class='noindent'>Show that <!-- l. 960 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>z</mi></math>
   is a unit of <!-- l. 960 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
   if and only if <!-- l. 960 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>N</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>z</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>.
   <span class='cmti-10x-x-109'>Hint: For the if direction the definition of the norm already gives you the
   inverse of </span><!-- l. 960 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>z</mi></math><span class='cmti-10x-x-109'>.</span>
   </p></dd><dt class='enumerate'>
d) </dt><dd class='enumerate'>
   <!-- l. 961 --><p class='noindent'>Show that <!-- l. 961 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>z</mi></math>
   is prime if <!-- l. 961 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>N</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>z</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
   is prime in <!-- l. 961 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ℤ</mi></math>.
   </p></dd><dt class='enumerate'>
e) </dt><dd class='enumerate'>
   <!-- l. 962 --><p class='noindent'>Calculate <!-- l. 962 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>N</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>δ</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>,
   <!-- l. 962 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>N</mi><mo class='MathClass-open' stretchy='false'>(</mo><msqrt><mrow><mn>2</mn></mrow></msqrt><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
   and <!-- l. 962 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>N</mi><mo class='MathClass-open' stretchy='false'>(</mo><mn>2</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>,
   and conclude that <!-- l. 962 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>N</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>δ</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
   is prime, but the others are not. </p></dd></dl>
   </div>
                                                                     

                                                                     
<!-- l. 964 --><p class='indent'>    So now we know that <!-- l. 965 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math>
is prime while <!-- l. 965 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msqrt><mrow><mn>2</mn></mrow></msqrt></math> (and
hence <!-- l. 965 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>2</mn></math>) is not. But
it turns out that <!-- l. 965 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math> is
also a prime factor of <!-- l. 965 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msqrt><mrow><mn>2</mn></mrow></msqrt></math>
(and hence <!-- l. 965 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>2</mn></math>).
</p>
   <div class='newtheorem'>
<!-- l. 966 --><p class='noindent'><span class='head'>
<a id='x12-259009r14'></a>
<span class='cmbx-10x-x-109'>Exercise 10.14.</span>  </span> Let <!-- l. 967 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>δ</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>ω</mi></mrow></math>.
   </p><dl class='enumerate'><dt class='enumerate'>
a) </dt><dd class='enumerate'>
   <!-- l. 969 --><p class='noindent'>Write <!-- l. 969 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>δ</mi></mrow><mrow><mn>2</mn></mrow></msup></math>
   and <!-- l. 969 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>δ</mi></mrow><mrow><mn>3</mn></mrow></msup></math>
   as <!-- l. 969 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi mathvariant='italic'>bω</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>c</mi><msup><mrow><mi>ω</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>d</mi><msup><mrow><mi>ω</mi></mrow><mrow><mn>3</mn></mrow></msup></mrow></math>
   for some integers <!-- l. 969 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>b</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>c</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>d</mi></mrow></math>.
   </p></dd><dt class='enumerate'>
b) </dt><dd class='enumerate'>
   <!-- l. 970 --><p class='noindent'>Using the fact that <!-- l. 970 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ω</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>ω</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></math>,
   write <!-- l. 970 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>δ</mi></mrow><mrow><mn>2</mn></mrow></msup><msup><mrow><mi>ω</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup></mrow></math>
   as <!-- l. 970 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>y</mi><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></math>
   for some integers <!-- l. 970 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>x</mi></math>
   and <!-- l. 970 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>y</mi></math>.
   </p></dd><dt class='enumerate'>
c) </dt><dd class='enumerate'>
   <!-- l. 971 --><p class='noindent'>Define the unit <!-- l. 971 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>λ</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn> <mo class='MathClass-bin' stretchy='false'>−</mo><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></math>.
   Show that <!-- l. 971 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>δ</mi></mrow><mrow><mn>2</mn></mrow></msup><msup><mrow><mi>ω</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup><mi>λ</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></math>.
   </p></dd></dl>
   </div>
<!-- l. 973 --><p class='indent'>    So we see that <!-- l. 974 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msqrt><mrow><mn>2</mn></mrow></msqrt></math>
can be decomposed up to units into two copies of
<!-- l. 974 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math>, and
hence <!-- l. 974 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>2</mn></math> can
be decomposed into four copies. Hence, instead of considering the smallest power of
<!-- l. 974 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>2</mn></math> we have to multiply
a number in <!-- l. 974 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
with to get something in our integer ring
                                                                     

                                                                     
<!-- l. 974 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>, we instead consider
the smallest power of <!-- l. 974 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math>,
as this is a more finegrained metric. For a
<!-- l. 975 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>z</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>, we call the
smallest <!-- l. 975 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> such that
<!-- l. 975 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>δ</mi></mrow><mrow><mi>k</mi></mrow></msup><mi>z</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math> the <span class='cmbx-10x-x-109'>least denominator
exponent </span>(lde) of <!-- l. 975 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>z</mi></math>.
For a vector of values <!-- l. 975 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>𝔻</mi><msup><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow><mrow><mi>N</mi></mrow></msup></mrow></math>,
we call its least denominator exponent the smallest
<!-- l. 975 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> such that
<!-- l. 975 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>δ</mi></mrow><mrow><mi>k</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi><msup><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow><mrow><mi>N</mi></mrow></msup></mrow></math>. Of course if the lde of a
vector is <!-- l. 976 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math>, then it already
consists of elements in <!-- l. 976 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>,
and we know that such a normalised vector must be very simple. So
if we can just find some procedure to iteratively reduce the lde to
<!-- l. 976 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math>,
then we are happy. The goal then is to find, for a given
<!-- l. 976 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> with lde
<!-- l. 976 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>, a set of
unitaries <!-- l. 976 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>G</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>G</mi></mrow><mrow><mi>l</mi></mrow></msub></mrow></math>
such that <!-- l. 976 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><msup><mrow><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow><mrow><mi>′</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>G</mi></mrow><mrow><mi>l</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>G</mi></mrow><mrow><mn>1</mn></mrow></msub><mi>v</mi></mrow></math> has
lde at most <!-- l. 976 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math>.
Then we could just repeat this procedure until we get to denominator exponent 0. Given
a <!-- l. 977 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> with lde
<!-- l. 977 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>, we can define the vector
<!-- l. 977 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>u</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>δ</mi></mrow><mrow><mi>k</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi><msup><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow><mrow><mi>N</mi></mrow></msup></mrow></math>. After making some
modifications to <!-- l. 977 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>u</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> by
applying gates to get a <!-- l. 977 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msup><mrow><mi>u</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi><msup><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow><mrow><mi>N</mi></mrow></msup></mrow></math>,
we are interested in whether this modification has reduced the lde. In order to
see when this is the case, we hence need to know when we can divide
<!-- l. 977 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msup><mrow><mi>u</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> by
<!-- l. 977 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math>, and still get
a vector in <!-- l. 977 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><msup><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow><mrow><mi>N</mi></mrow></msup></mrow></math>.
Of course, when we start caring about divisibility by some number, we
will need to talk about calculating <span class='cmti-10x-x-109'>modulo </span>this number. So in the same
way as we have been talking about <span class='cmti-10x-x-109'>parities</span>, which are elements of
<!-- l. 977 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ℤ</mi></math> modulo
<!-- l. 977 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>2</mn></math>,
now we are going to work with <span class='cmbx-10x-x-109'>residues</span>, which are elements of
<!-- l. 977 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math> modulo
<!-- l. 977 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math>. For elements
<!-- l. 978 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math> we will
write <!-- l. 978 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><mi>δ</mi></mrow></msub><mi>y</mi></mrow></math> to
denote that <!-- l. 978 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>y</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi mathvariant='italic'>aδ</mi></mrow></math>
                                                                     

                                                                     
for some <!-- l. 978 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>.
For instance, in the exercise above we saw that
<!-- l. 979 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msqrt><mrow>
<mn>2</mn></mrow></msqrt> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>δ</mi><msup><mrow><mi>ω</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup><mi>λ</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi>δ</mi></mrow></math>, and hence
<!-- l. 979 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msqrt><mrow>
<mn>2</mn></mrow></msqrt> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><mi>δ</mi></mrow></msub><mn>0</mn></mrow></math>. It is not hard
to see that <!-- l. 980 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><mi>δ</mi></mrow></msub></mrow></math>
is an equivalence relation, and that it is preserved by addition and multiplication: if
<!-- l. 980 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><mi>δ</mi></mrow></msub><mi>b</mi></mrow></math> and
<!-- l. 980 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>c</mi> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><mi>δ</mi></mrow></msub><mi>d</mi></mrow></math>, then
<!-- l. 980 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>c</mi> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><mi>δ</mi></mrow></msub><mi>b</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>d</mi></mrow></math> and
<!-- l. 980 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>ac</mi> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><mi>δ</mi></mrow></msub><mi mathvariant='italic'>bd</mi></mrow></math>. We then
also have <!-- l. 980 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>2</mn> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><mi>δ</mi></mrow></msub><msqrt><mrow><mn>2</mn></mrow></msqrt><msqrt><mrow><mn>2</mn></mrow></msqrt> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><mi>δ</mi></mrow></msub><mn>0</mn></mrow></math>.
</p>
   <div class='newtheorem'>
<!-- l. 981 --><p class='noindent'><span class='head'>
<a id='x12-259013r3'></a>
<span class='cmbx-10x-x-109'>Lemma 10.7.3.</span>  </span>For any <!-- l. 982 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>z</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
we have <!-- l. 982 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>z</mi> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><mi>δ</mi></mrow></msub><mn>0</mn></mrow></math>
or <!-- l. 982 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>z</mi> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><mi>δ</mi></mrow></msub><mn>1</mn></mrow></math>.
</p>
   </div>
<!-- l. 983 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 985 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>We have <!-- l. 985 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>δ</mi><msub><mrow><mi>≅</mi></mrow><mrow><mi>δ</mi></mrow></msub><mn>0</mn></mrow></math>,
and as <!-- l. 985 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>δ</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>ω</mi></mrow></math>,
we calculate then that
<!-- tex4ht:inline --></p><!-- l. 986 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                  <mi>ω</mi><mspace class='nbsp' width='0.33em'></mspace> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><mi>δ</mi></mrow></msub><mspace class='nbsp' width='0.33em'></mspace><mi>ω</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>0</mn><mspace class='nbsp' width='0.33em'></mspace> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><mi>δ</mi></mrow></msub><mspace class='nbsp' width='0.33em'></mspace><mi>ω</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>2</mn><mspace class='nbsp' width='0.33em'></mspace> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><mi>δ</mi></mrow></msub><mspace class='nbsp' width='0.33em'></mspace><mi>δ</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn><mspace class='nbsp' width='0.33em'></mspace> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><mi>δ</mi></mrow></msub><mspace class='nbsp' width='0.33em'></mspace><mn>1</mn><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math>
                                                                     

                                                                     
<!-- l. 986 --><p class='nopar'> Hence for any <!-- l. 987 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>j</mi></math>
we have <!-- l. 987 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>ω</mi></mrow><mrow><mi>j</mi></mrow></msup> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><mi>δ</mi></mrow></msub><mn>1</mn></mrow></math>,
so that <!-- l. 987 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi mathvariant='italic'>bω</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>c</mi><msup><mrow><mi>ω</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>d</mi><msup><mrow><mi>ω</mi></mrow><mrow><mn>3</mn></mrow></msup> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><mi>δ</mi></mrow></msub><mi>a</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>b</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>c</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>d</mi></mrow></math>.
Since furthermore <!-- l. 987 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>2</mn> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><mi>δ</mi></mrow></msub><mn>0</mn></mrow></math>,
we see that hence the residue of an element modulo <!-- l. 987 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math>
is either <!-- l. 987 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math>
or <!-- l. 987 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>.
                                                                   □
</p>
   </div>
<!-- l. 989 --><p class='indent'>   Given some <!-- l. 989 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>u</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>δ</mi></mrow><mrow><mi>k</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi><msup><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow><mrow><mi>N</mi></mrow></msup></mrow></math> our goal
is to apply operations to <!-- l. 989 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>u</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
to make all the components divisible by
<!-- l. 989 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math>,
and hence have zero residue. The components with residue
<!-- l. 989 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math> are
then the ‘obstacles’ we want to get rid of.
</p>
   <div class='newtheorem'>
<!-- l. 990 --><p class='noindent'><span class='head'>
<a id='x12-259014r4'></a>
<span class='cmbx-10x-x-109'>Lemma 10.7.4.</span>  </span>Let <!-- l. 991 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>𝔻</mi><msup><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow><mrow><mi>N</mi></mrow></msup></mrow></math>
be a normalised vector with lde <!-- l. 991 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>&gt;</mo> <mn>0</mn></mrow></math>,
so that <!-- l. 991 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>u</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>δ</mi></mrow><mrow><mi>k</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi><msup><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow><mrow><mi>N</mi></mrow></msup></mrow></math>.
Then there are at least 2 components <!-- l. 991 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>u</mi></mrow><mrow><mi>i</mi></mrow></msub></math>
and <!-- l. 991 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>u</mi></mrow><mrow><mi>j</mi></mrow></msub></math>
of <!-- l. 991 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>u</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
that have residue <!-- l. 991 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>.
</p>
   </div>
<!-- l. 992 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 994 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span><!-- l. 994 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>u</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
is divisible by <!-- l. 994 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math>
iff <!-- l. 994 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>u</mi></mrow><mrow><mi>j</mi></mrow></msub> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><mi>δ</mi></mrow></msub><mn>0</mn></mrow></math>
for all <!-- l. 994 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>j</mi></math>.
                                                                     

                                                                     
But assuming that <!-- l. 994 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
was the lde of <!-- l. 994 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>,
then by definition it won’t be divisible, and so there will be at least one
<!-- l. 994 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>u</mi></mrow><mrow><mi>j</mi></mrow></msub></math>
with non-zero residue. By normalisation of <!-- l. 994 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
we have <!-- l. 994 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>⟨</mo><mi>ψ</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>
and hence <!-- l. 994 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>j</mi></mrow></msub><msub><mrow><mi>u</mi></mrow><mrow><mi>j</mi></mrow></msub><mover accent='false' class='mml-overline'><mrow><msub><mrow><mi>u</mi></mrow><mrow><mi>j</mi></mrow></msub></mrow><mo accent='true'>¯</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>⟨</mo><mi>u</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>u</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>δ</mi></mrow><mrow><mi>k</mi></mrow></msup><msup><mrow><mover accent='false' class='mml-overline'><mrow><mi>δ</mi></mrow><mo accent='true'>¯</mo></mover></mrow><mrow><mi>k</mi></mrow></msup> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><mi>δ</mi></mrow></msub><mn>0</mn></mrow></math>.
Since residues are either <!-- l. 994 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math>
or <!-- l. 994 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>,
we then know that there are an even number of cases where <!-- l. 994 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>u</mi></mrow><mrow><mi>j</mi></mrow></msub><mover accent='false' class='mml-overline'><mrow><msub><mrow><mi>u</mi></mrow><mrow><mi>j</mi></mrow></msub></mrow><mo accent='true'>¯</mo></mover> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><mi>δ</mi></mrow></msub><mn>1</mn></mrow></math>.
The residue is multiplicative, so for these <!-- l. 994 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>j</mi></math>
we must then also have <!-- l. 994 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>u</mi></mrow><mrow><mi>j</mi></mrow></msub> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><mi>δ</mi></mrow></msub><mn>1</mn></mrow></math>.
Hence, if <!-- l. 995 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>u</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
is not divisible by <!-- l. 995 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math>
there must be at least a pair of elements <!-- l. 995 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>u</mi></mrow><mrow><mi>i</mi></mrow></msub></math>
and <!-- l. 995 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>u</mi></mrow><mrow><mi>j</mi></mrow></msub></math>
that each have non-zero residue.                                                       □
</p>
   </div>
<!-- l. 997 --><p class='indent'>   The fact that non-zero residues come in pairs is good, because
it turns out we can only reduce the residue of elements of
<!-- l. 997 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>u</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
in pairs. We are working with Clifford+T gates. The CNOT,
<!-- l. 998 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math> and
<!-- l. 998 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
only contain non-zero elements that are units in
<!-- l. 998 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math> and have
at most one non-zero entry per row, and hence applying these gates does not affect the
residues of the state. The only gate then that can affect residues is the Hadamard
<!-- l. 998 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>H</mi> <mo class='MathClass-rel' stretchy='false'>=</mo>  <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'>   <mn>1</mn>   </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                     </mrow><mo fence='true' form='postfix'>)</mo></mrow></mrow></math>. We see that the
Hadamard creates sums <!-- l. 998 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>u</mi></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>u</mi></mrow><mrow><mi>j</mi></mrow></msub></mrow></math>
and differences <!-- l. 998 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>u</mi></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>−</mo> <msub><mrow><mi>u</mi></mrow><mrow><mi>j</mi></mrow></msub></mrow></math>
of elements of the vector, which can lead to lower lde, but then it also divides the elements by
<!-- l. 998 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msqrt><mrow>
<mn>2</mn></mrow></msqrt></math>, which can <span class='cmti-10x-x-109'>increase</span>
the lde. Because <!-- l. 998 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msqrt><mrow><mn>2</mn></mrow></msqrt></math>
contains two powers of <!-- l. 998 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math>,
we need to look at the vector elements modulo
<!-- l. 998 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>δ</mi></mrow><mrow><mn>3</mn></mrow></msup></math>
(the next power up), to see if applying a Hadamard will result in lower
lde.
</p>
   <div class='newtheorem'>
<!-- l. 999 --><p class='noindent'><span class='head'>
                                                                     

                                                                     
<a id='x12-259015r15'></a>
<span class='cmbx-10x-x-109'>Exercise 10.15.</span>  </span>We have <!-- l. 1000 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>δ</mi></mrow><mrow><mn>3</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>3</mn><mi>ω</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>3</mn><msup><mrow><mi>ω</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>ω</mi></mrow><mrow><mn>3</mn></mrow></msup></mrow></math>.
Show that any element in <!-- l. 1000 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
is equivalent modulo <!-- l. 1000 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>δ</mi></mrow><mrow><mn>3</mn></mrow></msup></math>
to an element in the set
<!-- tex4ht:inline --></p><!-- l. 1000 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                 <mo class='MathClass-open' stretchy='false'>{</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mi>ω</mi><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mi>ω</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mi>ω</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>ω</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>ω</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>ω</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>}</mo><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math>
<!-- l. 1000 --><p class='nopar'> <span class='cmti-10x-x-109'>Hint: First note that </span><!-- l. 1001 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>2</mn> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><msup><mrow><mi>δ</mi></mrow><mrow><mn>3</mn></mrow></msup></mrow></msub><mn>0</mn></mrow></math><span class='cmti-10x-x-109'>,
so that we only have to deal with elements </span><!-- l. 1001 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi mathvariant='italic'>bω</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>c</mi><msup><mrow><mi>ω</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>d</mi><msup><mrow><mi>ω</mi></mrow><mrow><mn>3</mn></mrow></msup></mrow></math>
<span class='cmti-10x-x-109'>where </span><!-- l. 1001 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>b</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>c</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>d</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo><mo class='MathClass-open' stretchy='false'>{</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math><span class='cmti-10x-x-109'>.
Then argue that when </span><!-- l. 1001 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>b</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>c</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>d</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math><span class='cmti-10x-x-109'>,
the residue is zero, so that you only have to consider the cases where at most
two of </span><!-- l. 1001 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>a</mi></math><span class='cmti-10x-x-109'>,</span>
<!-- l. 1001 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>b</mi></math><span class='cmti-10x-x-109'>,</span>
<!-- l. 1001 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>c</mi></math>
<span class='cmti-10x-x-109'>or </span><!-- l. 1001 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>d</mi></math>
<span class='cmti-10x-x-109'>are 1.</span>
</p>
   </div>
<!-- l. 1002 --><p class='indent'>    Note that from this above exercise we immediately get the following, just by
checking all the possible cases:
</p>
   <div class='newtheorem'>
<!-- l. 1004 --><p class='noindent'><span class='head'>
<a id='x12-259016r5'></a>
<span class='cmbx-10x-x-109'>Lemma 10.7.5.</span>  </span>If <!-- l. 1005 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>z</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
has <!-- l. 1005 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>z</mi> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><mi>δ</mi></mrow></msub><mn>1</mn></mrow></math>,
then <!-- l. 1005 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>z</mi> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><msup><mrow><mi>δ</mi></mrow><mrow><mn>3</mn></mrow></msup></mrow></msub><msup><mrow><mi>ω</mi></mrow><mrow><mi>j</mi></mrow></msup></mrow></math>
for some <!-- l. 1005 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>j</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo><mo class='MathClass-open' stretchy='false'>{</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>2</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>3</mn><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>.
                                                                     

                                                                     
</p>
   </div>
<!-- l. 1006 --><p class='indent'>    Now we have all the tools we need to solve the problem at hand. For
simplicity, let’s again first assume we are dealing with a single-qubit vector
<!-- l. 1007 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>u</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>u</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>u</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi><msup><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow><mrow><mn>2</mn></mrow></msup></mrow></math>. If it is not already
divisible by <!-- l. 1007 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math> then
we must have <!-- l. 1007 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>u</mi></mrow><mrow><mn>1</mn></mrow></msub> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><mi>δ</mi></mrow></msub><msub><mrow><mi>u</mi></mrow><mrow><mn>2</mn></mrow></msub> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><mi>δ</mi></mrow></msub><mn>1</mn></mrow></math>,
since the non-zero residues come in pairs. Then by the previous lemma we have
<!-- l. 1007 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>u</mi></mrow><mrow><mn>1</mn></mrow></msub> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><msup><mrow><mi>δ</mi></mrow><mrow><mn>3</mn></mrow></msup></mrow></msub><msup><mrow><mi>ω</mi></mrow><mrow><mi>l</mi></mrow></msup></mrow></math> and
<!-- l. 1007 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>u</mi></mrow><mrow><mn>2</mn></mrow></msub> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><msup><mrow><mi>δ</mi></mrow><mrow><mn>3</mn></mrow></msup></mrow></msub><msup><mrow><mi>ω</mi></mrow><mrow><mi>k</mi></mrow></msup></mrow></math>. In other
words: <!-- l. 1007 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>u</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>ω</mi></mrow><mrow><mi>l</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>x</mi><msup><mrow><mi>δ</mi></mrow><mrow><mn>3</mn></mrow></msup></mrow></math> and
<!-- l. 1007 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>u</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>ω</mi></mrow><mrow><mi>k</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>y</mi><msup><mrow><mi>δ</mi></mrow><mrow><mn>3</mn></mrow></msup></mrow></math> for some
<!-- l. 1007 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>. Then we see that
if we apply a <!-- l. 1008 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>T</mi></mrow><mrow><mi>l</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mi>k</mi></mrow></msup></math>
gate to this vector that we get: </p><table class='equation-star'><tr><td>
<!-- l. 1009 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow>
<mi>T</mi></mrow><mrow><mi>l</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mi>k</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>u</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><msup><mrow><mi>T</mi></mrow><mrow><mi>l</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mi>k</mi></mrow></msup> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <msup><mrow><mi>ω</mi></mrow><mrow><mi>l</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>x</mi><msup><mrow><mi>δ</mi></mrow><mrow><mn>3</mn></mrow></msup>  </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <msup><mrow><mi>ω</mi></mrow><mrow><mi>k</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>y</mi><msup><mrow><mi>δ</mi></mrow><mrow><mn>3</mn></mrow></msup>  </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                                         </mrow><mo fence='true' form='postfix'>)</mo></mrow> <mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'>       <msup><mrow><mi>ω</mi></mrow><mrow><mi>l</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>x</mi><msup><mrow><mi>δ</mi></mrow><mrow><mn>3</mn></mrow></msup>         </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <msup><mrow><mi>ω</mi></mrow><mrow><mi>k</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mi>l</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mi>k</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>ω</mi></mrow><mrow><mi>l</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mi>k</mi></mrow></msup><mi>y</mi><msup><mrow><mi>δ</mi></mrow><mrow><mn>3</mn></mrow></msup>  </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                          </mrow><mo fence='true' form='postfix'>)</mo></mrow> <mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <msup><mrow><mi>ω</mi></mrow><mrow><mi>l</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>x</mi><msup><mrow><mi>δ</mi></mrow><mrow><mn>3</mn></mrow></msup>  </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <msup><mrow><mi>ω</mi></mrow><mrow><mi>l</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>y</mi></mrow><mrow><mi>′</mi></mrow></msup><msup><mrow><mi>δ</mi></mrow><mrow><mn>3</mn></mrow></msup>  </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                                         </mrow><mo fence='true' form='postfix'>)</mo></mrow> <mo class='MathClass-punc' stretchy='false'>,</mo>
</mrow></math></td></tr></table>
<!-- l. 1014 --><p class='indent'>   where we have defined <!-- l. 1014 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>y</mi></mrow><mrow><mi>′</mi></mrow></msup> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>ω</mi></mrow><mrow><mi>l</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mi>k</mi></mrow></msup><mi>y</mi></mrow></math>.
Now comes the magic trick: we apply a Hadamard, and we use the fact that
<!-- l. 1015 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msqrt><mrow>
<mn>2</mn></mrow></msqrt> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>δ</mi></mrow><mrow><mn>2</mn></mrow></msup><msup><mrow><mi>ω</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup><mi>λ</mi></mrow></math>, and
hence <!-- l. 1015 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>δ</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msqrt><mrow><mn>2</mn></mrow></msqrt><mi>ω</mi><msup><mrow><mi>λ</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup></mrow></math>
where <!-- l. 1015 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>λ</mi></math> is
the unit from Exercise <a href='#x12-259009r14'>10.14<!-- tex4ht:ref: exer:synthesis-delta  --></a>: </p><table class='equation'><tr><td>
<!-- l. 1016 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 1016 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mstyle class='label' id='x12-259017r72'></mstyle><!-- endlabel --><mi>H</mi><msup><mrow><mi>T</mi></mrow><mrow><mi>l</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mi>k</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>u</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace>  <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>2</mn><msup><mrow><mi>ω</mi></mrow><mrow><mi>l</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>y</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo><msup><mrow><mi>δ</mi></mrow><mrow><mn>3</mn></mrow></msup>  </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'>       <mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>y</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo><msup><mrow><mi>δ</mi></mrow><mrow><mn>3</mn></mrow></msup>       </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                             </mrow><mo fence='true' form='postfix'>)</mo></mrow> <mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <msup><mrow><mi>δ</mi></mrow><mrow><mn>2</mn></mrow></msup><msup><mrow><mi>ω</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup><mi>λ</mi><msup><mrow><mi>ω</mi></mrow><mrow><mi>l</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>y</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo><mi>ω</mi><msup><mrow><mi>λ</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup><mi>δ</mi> </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'>        <mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>y</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo><mi>ω</mi><msup><mrow><mi>λ</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup><mi>δ</mi>        </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                  </mrow><mo fence='true' form='postfix'>)</mo></mrow><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td><td class='eq-no'>(10.72)</td></tr></table>
<!-- l. 1020 --><p class='indent'>   We see now that every term has at least one factor of
<!-- l. 1020 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math>, so
we can factor it out: </p><table class='equation'><tr><td>
<!-- l. 1021 --><p class='indent'>
</p><!-- l. 1021 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mstyle class='label' id='x12-259018r73'></mstyle><!-- endlabel --><mi>H</mi><msup><mrow><mi>T</mi></mrow><mrow><mi>l</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mi>k</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>u</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mi>δ</mi> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mi>δ</mi><msup><mrow><mi>ω</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup><mi>λ</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>y</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo><mi>ω</mi><msup><mrow><mi>λ</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup>  </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'>         <mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>y</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo><mi>ω</mi><msup><mrow><mi>λ</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup>         </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                  </mrow><mo fence='true' form='postfix'>)</mo></mrow> <mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td><td class='eq-no'>(10.73)</td></tr></table>
<!-- l. 1024 --><p class='indent'>   Success! Because this means that <!-- l. 1024 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>H</mi><msup><mrow><mi>T</mi></mrow><mrow><mi>l</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mi>k</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>u</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
is divisible by <!-- l. 1024 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math>.
As <!-- l. 1024 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>u</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>δ</mi></mrow><mrow><mi>k</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>, this means
that <!-- l. 1024 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>H</mi><msup><mrow><mi>T</mi></mrow><mrow><mi>l</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mi>k</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> now has lde
smaller than <!-- l. 1024 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>.
We can now repeat this procedure until we get to lde
<!-- l. 1024 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math>, in
which case we know the vector we have is a basis vector, and we are done. This just
covers the single-qubit case, but reducing the lde of a multi-qubit normalised vector
<!-- l. 1025 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>𝔻</mi><msup><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow><mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup>
   </mrow></msup></mrow></math> is done very
similarly. Defining <!-- l. 1025 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>u</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>δ</mi></mrow><mrow><mi>k</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>,
where <!-- l. 1025 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> is
the lde of <!-- l. 1025 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>,
we saw that there must be an even number of elements of
<!-- l. 1025 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>u</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
with non-zero residue. We can hence pick a pair
<!-- l. 1025 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>u</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>u</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> that
both have non-zero residue, and then apply the above technique, just ‘targeting’ this
pair to zero out their residues. We can do this targetting by replacing the Hadamard
and <!-- l. 1025 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates above with the 2-level and 1-level operators
<!-- l. 1025 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>H</mi></mrow><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mi mathvariant='italic'>ij</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></msub></math> and
<!-- l. 1025 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>T</mi></mrow><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mi>j</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></msub></math>
                                                                     

                                                                     
that hence only change the residues of the elements
<!-- l. 1025 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>u</mi></mrow><mrow><mi>i</mi></mrow></msub></math> and
<!-- l. 1025 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>u</mi></mrow><mrow><mi>j</mi></mrow></msub></math>.
The constructions in Section <a href='main_htmlch9.html#level-operators'>9.7.2<!-- tex4ht:ref: sec:2-level-op  --></a> show how to implement these gates
using just Clifford+T gates. We do this reduction of lde with every pair
that needs it, until all the residues are zero, in which case the modified
<!-- l. 1026 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>u</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> is divisible by
<!-- l. 1026 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math>. This then means
that the modified <!-- l. 1026 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
has lower lde. We then just repeat until the lde is zero and we are left with a
basis vector. Pfew, that was a lot, so let’s summarise what we have actually done
to get to the solution:
     </p><dl class='enumerate'><dt class='enumerate'>
  1.. </dt><dd class='enumerate'>
     <!-- l. 1029 --><p class='noindent'>We started out with a <!-- l. 1029 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>×</mo> <msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></math>
     unitary <!-- l. 1029 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
     where all the entries are in the ring <!-- l. 1029 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo> <mfrac><mrow><mn>1</mn></mrow>
<mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac><mo class='MathClass-punc' stretchy='false'>,</mo><mi>i</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>.
     </p></dd><dt class='enumerate'>
  2.. </dt><dd class='enumerate'>
     <!-- l. 1030 --><p class='noindent'>Then we realised in Eq. (<a href='#x12-260001r74'>10.74<!-- tex4ht:ref: eq:reduce-column-unitary  --></a>) that we wanted to find a unitary
     <!-- l. 1030 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>G</mi></math>
     that reduces the first column of <!-- l. 1030 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
     to a standard basis vector.
     </p></dd><dt class='enumerate'>
  3.. </dt><dd class='enumerate'>
     <!-- l. 1031 --><p class='noindent'>Finding such a unitary <!-- l. 1031 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>G</mi></math>
     is equivalent to finding a way to reduce an arbitrary normalised vector
     <!-- l. 1031 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
     to <!-- l. 1031 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
     using <!-- l. 1031 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>G</mi></math>:
     <!-- l. 1031 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>G</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
     </p></dd><dt class='enumerate'>
  4.. </dt><dd class='enumerate'>
     <!-- l. 1032 --><p class='noindent'>Instead of writing <!-- l. 1032 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
     as a vector over <!-- l. 1032 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo> <mfrac><mrow><mn>1</mn></mrow>
<mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac><mo class='MathClass-punc' stretchy='false'>,</mo><mi>i</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>,
     we write it as a vector over <!-- l. 1032 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>.
     We find its least denominator exponent <!-- l. 1032 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>:
     the smallest number such that <!-- l. 1032 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>δ</mi></mrow><mrow><mi>k</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>,
     where <!-- l. 1032 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>δ</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>ω</mi></mrow></math>.
     We picked <!-- l. 1032 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math>
                                                                     

                                                                     
     as the base, since it is prime in <!-- l. 1032 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>.
     </p></dd><dt class='enumerate'>
  5.. </dt><dd class='enumerate'>
     <!-- l. 1033 --><p class='noindent'>We look for two components <!-- l. 1033 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>u</mi></mrow><mrow><mi>i</mi></mrow></msub></math>
     and <!-- l. 1033 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>u</mi></mrow><mrow><mi>j</mi></mrow></msub></math>
     of <!-- l. 1033 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>u</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>δ</mi></mrow><mrow><mi>k</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
     such that the residues <!-- l. 1033 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>u</mi></mrow><mrow><mi>i</mi></mrow></msub> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><mi>δ</mi></mrow></msub><msub><mrow><mi>u</mi></mrow><mrow><mi>j</mi></mrow></msub> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><mi>δ</mi></mrow></msub><mn>1</mn></mrow></math>.
     If there is such a pair we apply 2-level Hadamard and 1-level <!-- l. 1033 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
     gates to zero out their residues.
     </p></dd><dt class='enumerate'>
  6.. </dt><dd class='enumerate'>
     <!-- l. 1034 --><p class='noindent'>If there isn’t such a pair of components left, then we have transformed
     <!-- l. 1034 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>u</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
     to be divisible by <!-- l. 1034 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math>,
     so that the new <!-- l. 1034 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
     we found must have lower least denominator exponent.
     </p></dd><dt class='enumerate'>
  7.. </dt><dd class='enumerate'>
     <!-- l. 1035 --><p class='noindent'>We then repeat this procedure until <!-- l. 1035 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
     has lde <!-- l. 1035 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math>,
     in which case it is a standard basis vector up to a phase, which is
     easily permuted into the desired basis vector, and its phase removed
     by applying the appropriate 1-level gate.
     </p></dd><dt class='enumerate'>
  8.. </dt><dd class='enumerate'>
     <!-- l. 1036 --><p class='noindent'>We have now found our desired unitary <!-- l. 1036 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>G</mi></mrow><mrow><mn>1</mn></mrow></msub></math>
     that we can apply to <!-- l. 1036 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
     to simplify its first column. Because <!-- l. 1036 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
     is unitary, this means its first row must now also be simplified.
     </p></dd><dt class='enumerate'>
  9.. </dt><dd class='enumerate'>
     <!-- l. 1037 --><p class='noindent'>Now just rinse and repeat for all the other columns of <!-- l. 1037 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>,
     resulting in a series of Clifford+<!-- l. 1037 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
     unitaries <!-- l. 1037 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>G</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>G</mi></mrow><mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></msub></mrow></math>
     such that <!-- l. 1037 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>G</mi></mrow><mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>G</mi></mrow><mrow><mn>1</mn></mrow></msub><mi>U</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi></mrow></math>.
     </p></dd><dt class='enumerate'>
 10.. </dt><dd class='enumerate'>
     <!-- l. 1038 --><p class='noindent'>We hence have <!-- l. 1038 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>U</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msubsup><mrow><mi>G</mi></mrow><mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msubsup><mo class='MathClass-rel' stretchy='false'>⋯</mo><msubsup><mrow><mi>G</mi></mrow><mrow><mn>1</mn></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msubsup></mrow></math>.
     </p></dd></dl>
                                                                     

                                                                     
<!-- l. 1040 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='exact-unitary-synthesis'><span class='titlemark'>10.7.2   </span> <a id='x12-26000010.7.2'></a>Exact unitary synthesis*</h4>
<!-- l. 1042 --><p class='noindent'>Let’s fill in the details on how to exactly synthesise an entire unitary and not just a single
state. We have a <!-- l. 1043 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>×</mo> <msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></math>
unitary <!-- l. 1043 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math> with
matrix entries in <!-- l. 1043 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>.
Let <!-- l. 1043 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>u</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> be the
first column of <!-- l. 1043 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>,
and <!-- l. 1043 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>V</mi> </mrow><mrow><mn>1</mn></mrow></msub></math> the
Clifford+<!-- l. 1043 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> unitary
satisfying <!-- l. 1043 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>V</mi> </mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>u</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mn>0</mn></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
that we can find using the procedure described in the previous section. Then we
have: </p><table class='equation'><tr><td>
<!-- l. 1045 --><p class='indent'>
</p><!-- l. 1045 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mstyle class='label' id='x12-260001r74'></mstyle><!-- endlabel --><msub><mrow><mi>G</mi></mrow><mrow><mn>1</mn></mrow></msub><mi>U</mi><mspace class='nbsp' width='0.33em'></mspace><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mspace class='nbsp' width='0.33em'></mspace> <mrow><mo fence='true' form='prefix'>(</mo><mrow> <mtable align='axis' class='array' columnlines='solid none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'>                                                 <mn>1</mn>                                                 </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'>  <mo class='MathClass-rel' stretchy='false'>⋯</mo>  </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr>  <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'>  </mtd> <mtd class='array-td' columnalign='center'>  </mtd> <mtd class='array-td' columnalign='center'> </mtd>
</mtr>  <mtr class='array-row'><mtd class='array-td' columnalign='center'>                                                 <mi>⋮</mi>                                          </mtd><mtd class='array-td' columnalign='center'>    </mtd><mtd class='array-td' columnalign='center'> <msup><mrow><mi>U</mi></mrow><mrow><mi>′</mi></mrow></msup> </mtd><mtd class='array-td' columnalign='center'>  </mtd>
</mtr>  <mtr class='array-row'><mtd class='array-td' columnalign='center'>                            <mn>0</mn>                                                 </mtd><mtd class='array-td' columnalign='center'>    </mtd><mtd class='array-td' columnalign='center'>      </mtd><mtd class='array-td' columnalign='center'>    </mtd></mtr> <!-- c|ccc --></mtable></mrow><mo fence='true' form='postfix'>)</mo></mrow><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td><td class='eq-no'>(10.74)</td></tr></table>
<!-- l. 1056 --><p class='indent'>   Note that here the first row also becomes a unit vector, because
of the orthogonality conditions between the columns of the unitary
<!-- l. 1056 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>G</mi></mrow><mrow><mn>1</mn></mrow></msub><mi>U</mi></mrow></math>.
Now we can take the first column of the smaller unitary
<!-- l. 1057 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>U</mi></mrow><mrow><mi>′</mi></mrow></msup></math>
and synthesise it as a state again. We have to be careful to
not undo the work we did with reducing the first column of
<!-- l. 1057 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>, and
hence we need to use 2-level and 1-level operators to only touch the elements of
the matrix we want to. Repeating this procedure, we see that we get
Clifford+<!-- l. 1058 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> unitaries
<!-- l. 1058 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>V</mi> </mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>V</mi> </mrow><mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></msub></mrow></math> satisfying
<!-- l. 1058 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>V</mi> </mrow><mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>V</mi> </mrow><mrow><mn>1</mn></mrow></msub><mi>U</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi></mrow></math>. Hence, we have
synthesised <!-- l. 1058 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
as <!-- l. 1058 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mrow><mi>V</mi> </mrow><mrow><mn>1</mn></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msubsup><mo class='MathClass-rel' stretchy='false'>⋯</mo><msubsup><mrow><mi>V</mi> </mrow><mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msubsup></mrow></math>.
All of this is a bit reminiscent of the CNOT synthesis algorithm
using Gaussian elimination of Chapter <a href='main_htmlch4.html#cnot-circuits-and-phasefree-zxdiagrams'>4<!-- tex4ht:ref: ch:phasefree  --></a>. However, there we
                                                                     

                                                                     
could encode the entire function of the CNOT circuit into an
<!-- l. 1059 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>×</mo> <mi>n</mi></mrow></math> matrix, while here we are
working with a <!-- l. 1059 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>×</mo> <msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></math> matrix.
Hence, even if each <!-- l. 1059 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>V</mi> </mrow><mrow><mi>i</mi></mrow></msub></math>
is a small circuit, the overall circuit synthesising
<!-- l. 1059 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
might still be exponentially large. We would not expect to do any better as we
are now dealing with an approximately universal gate set, and hence there
are simply too many possible unitaries we can synthesise for all circuits
implementing them to be small. Let’s record what we have now seen in a
Theorem.
</p>
   <div class='newtheorem'>
<!-- l. 1062 --><p class='noindent'><span class='head'>
<a id='x12-260002r6'></a>
<span class='cmbx-10x-x-109'>Theorem 10.7.6.</span>  </span>Let <!-- l. 1063 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
be an <!-- l. 1063 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit
unitary with entries in <!-- l. 1063 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>.
Then <!-- l. 1063 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
can be realised by a Clifford+<!-- l. 1063 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
circuit using at most one zeroed ancilla.
</p>
   </div>
<!-- l. 1064 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 1066 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>In these sections we have found a method to write <!-- l. 1066 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
using 2-level Hadamard and <!-- l. 1066 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>
operators and 1-level <!-- l. 1066 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
operators. As described in Section <a href='main_htmlch9.html#level-operators'>9.7.2<!-- tex4ht:ref: sec:2-level-op  --></a>, these can be built using gates with
<!-- l. 1066 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math>
controls, which require a single zeroed ancilla to be implemented over the
Clifford+<!-- l. 1066 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gate set (cf. Section <a href='main_htmlch9.html#adding-controls-to-other-quantum-gates'>9.4.2<!-- tex4ht:ref: sec:control-other-gate  --></a>).                                                             □
</p>
   </div>
                                                                     

                                                                     
<!-- l. 1068 --><p class='indent'>   These techniques we have seen for exact synthesis are not unique to
Clifford+<!-- l. 1068 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>.
They work for many gate sets that can at least express the 2-level
operators necessary to move elements of the vector to the place
where they are needed. One particularly simple example of this is
the correspondence between circuits of Toffoli, CNOT, NOT and
<!-- l. 1069 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math> gates, and unitaries over
the ring <!-- l. 1069 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ℤ</mi></math>. Since all the
entries in such a unitary <!-- l. 1069 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
are integers, the normalisation of the column means that there
is at most one non-zero element and that this element is
<!-- l. 1069 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>±</mo> <mn>1</mn></mrow></math>. Hence, ignoring
the possible <!-- l. 1069 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math>
phases, such a unitary is just a big permutation of the basis
vectors, which we know we can realise using a Toffoli circuit
<!-- l. 1069 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> </mrow></math> (Section <a href='main_htmlch9.html#from-truth-tables-to-toffolis'>9.7.1<!-- tex4ht:ref: sec:reversible-cycles  --></a>). The
resulting unitary <!-- l. 1069 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> <mi>U</mi></mrow></math> is then
diagonal and only has <!-- l. 1069 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>±</mo> <mn>1</mn></mrow></math>
phase. The <!-- l. 1069 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math> phases can
be realised by 1-level <!-- l. 1069 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math>
operators, and then we are done!
</p>
   <div class='newtheorem'>
<!-- l. 1070 --><p class='noindent'><span class='head'>
<a id='x12-260003r7'></a>
<span class='cmbx-10x-x-109'>Proposition 10.7.7.</span>  </span> Let <!-- l. 1071 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
be an <!-- l. 1071 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit
unitary with entries in the ring of integers <!-- l. 1071 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ℤ</mi></math>.
Then <!-- l. 1071 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
can be realised by a quantum circuit consisting of Toffoli, CNOT, NOT, and
<!-- l. 1071 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math>
gates, using at most one zeroed ancilla.
</p>
   </div>
<!-- l. 1072 --><p class='indent'>    There are several other results like this that make a correspondence
between a certain quantum gate set and the set of matrices over a given
ring.
</p>
   <div class='newtheorem'>
<!-- l. 1074 --><p class='noindent'><span class='head'>
<a id='x12-260004r8'></a>
                                                                     

                                                                     
<span class='cmbx-10x-x-109'>Theorem 10.7.8.</span>  </span>Let <!-- l. 1075 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
be an <!-- l. 1075 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit unitary and
let <!-- l. 1075 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>R</mi></math> be a ring such that
all the matrix entries of <!-- l. 1075 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
are in <!-- l. 1075 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>R</mi></math>.
Then <!-- l. 1075 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
can be synthesised as a quantum circuit over the gate set
<!-- l. 1075 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>G</mi></mstyle></math> using
at most one zeroed ancilla when: </p>
     <ul class='itemize1'>
     <li class='itemize'><!-- l. 1077 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>R</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>ℤ</mi></mrow></math>
     and <!-- l. 1077 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle mathvariant='script'><mi>G</mi></mstyle> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>{</mo><mstyle class='text'><mtext>TOF</mtext></mstyle><mo class='MathClass-punc' stretchy='false'>,</mo><mstyle class='text'><mtext>CNOT</mtext></mstyle><mo class='MathClass-punc' stretchy='false'>,</mo><mi>X</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>Z</mi><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>.
     </li>
     <li class='itemize'><!-- l. 1078 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>R</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>i</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
     and <!-- l. 1078 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle mathvariant='script'><mi>G</mi></mstyle> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>{</mo><mstyle class='text'><mtext>TOF</mtext></mstyle><mo class='MathClass-punc' stretchy='false'>,</mo><mstyle class='text'><mtext>CNOT</mtext></mstyle><mo class='MathClass-punc' stretchy='false'>,</mo><mi>X</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>S</mi><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>.
     </li>
     <li class='itemize'><!-- l. 1079 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>R</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mfrac><mrow><mn>1</mn></mrow>
<mrow><mn>2</mn></mrow></mfrac><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
     and <!-- l. 1079 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle mathvariant='script'><mi>G</mi></mstyle> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>{</mo><mstyle class='text'><mtext>TOF</mtext></mstyle><mo class='MathClass-punc' stretchy='false'>,</mo><mstyle class='text'><mtext>CNOT</mtext></mstyle><mo class='MathClass-punc' stretchy='false'>,</mo><mi>X</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>H</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>H</mi><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>.
     </li>
     <li class='itemize'><!-- l. 1080 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>R</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo> <mfrac><mrow><mn>1</mn></mrow>
<mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
     and <!-- l. 1080 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle mathvariant='script'><mi>G</mi></mstyle> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>{</mo><mstyle class='text'><mtext>TOF</mtext></mstyle><mo class='MathClass-punc' stretchy='false'>,</mo><mstyle class='text'><mtext>CNOT</mtext></mstyle><mo class='MathClass-punc' stretchy='false'>,</mo><mi>X</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>H</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi mathvariant='italic'>CH</mi><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>.
     </li>
     <li class='itemize'><!-- l. 1081 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>R</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo> <mfrac><mrow><mn>1</mn></mrow>
<mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac><mo class='MathClass-punc' stretchy='false'>,</mo><mi>i</mi><mo class='MathClass-close' stretchy='false'>]</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
     and <!-- l. 1081 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle mathvariant='script'><mi>G</mi></mstyle> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>{</mo><mstyle class='text'><mtext>CNOT</mtext></mstyle><mo class='MathClass-punc' stretchy='false'>,</mo><mi>H</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>.
     </li></ul>
   </div>
<!-- l. 1083 --><p class='indent'>    Hence, we see that the exact synthesis of
Clifford+<!-- l. 1084 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
circuits doesn’t exist in a vacuum, but is in fact part of a ladder of increasingly more
powerful gate sets corresponding to larger rings. This ladder can be continued, by replacing
the <!-- l. 1085 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>T</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> <mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> gate by
                                                                     

                                                                     
<!-- l. 1085 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mfrac><mrow><mn>2</mn><mi>π</mi></mrow>
<mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>k</mi></mrow></msup></mrow></mfrac><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> for some
<!-- l. 1085 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>&gt;</mo> <mn>3</mn></mrow></math>. The ring that corresponds
to the resulting Clifford+<!-- l. 1085 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mfrac><mrow><mn>2</mn><mi>π</mi></mrow>
<mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>k</mi></mrow></msup></mrow></mfrac><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
gate set is <!-- l. 1085 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mn>2</mn><mi>π</mi></mrow>
<mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>k</mi></mrow></msup></mrow></mfrac> </mrow></msup><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>.
</p>
   <h5 class='subsubsectionHead' id='optimality-of-singlequbit-cliffordt-unitary-synthesis'><span class='titlemark'>10.7.2.1   </span> <a id='x12-26100010.7.2.1'></a>Optimality of single-qubit Clifford+T unitary synthesis*</h5>
<!-- l. 1087 --><p class='noindent'>Using the exact synthesis algorithm for
Clifford+<!-- l. 1087 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
unitaries generally results in very large circuits. The exception is when we apply
it to single-qubit unitaries, for which it is in fact <span class='cmti-10x-x-109'>optimal </span>in the number of gates
needed. As we already saw in Section <a href='#optimality-of-singlequbit-cliffordt-unitary-synthesis'>10.7.2.1<!-- tex4ht:ref: sec:synthesis-exact-single  --></a>, for a single-qubit unitary, the
Clifford+<!-- l. 1088 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
exact synthesis takes a particular nice form. We start with some unitary
</p><table class='equation'><tr><td>
<!-- l. 1090 --><p class='indent'>
</p><!-- l. 1090 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mstyle class='label' id='x12-261001r75'></mstyle><!-- endlabel --><mi>U</mi><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <msub><mrow><mi>ψ</mi></mrow><mrow><mn>1</mn></mrow></msub>  </mtd><mtd class='array-td' columnalign='center'>   <mover accent='false' class='mml-overline'><mrow><msub><mrow><mi>ψ</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow><mo accent='true'>¯</mo></mover><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iα</mi></mrow></msup>   </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <msub><mrow><mi>ψ</mi></mrow><mrow><mn>2</mn></mrow></msub>  </mtd><mtd class='array-td' columnalign='center'>  <mo class='MathClass-bin' stretchy='false'>−</mo><mover accent='false' class='mml-overline'><mrow><msub><mrow><mi>ϕ</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow><mo accent='true'>¯</mo></mover><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iα</mi></mrow></msup> </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                     </mrow><mo fence='true' form='postfix'>)</mo></mrow> <mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td><td class='eq-no'>(10.75)</td></tr></table>
<!-- l. 1096 --><p class='indent'>   Then we find a unitary <!-- l. 1096 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> </mrow></math>
built out of <!-- l. 1096 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math>
and <!-- l. 1096 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates that
synthesises <!-- l. 1096 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>ψ</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>ψ</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
so that <!-- l. 1096 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> <mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
Then </p><table class='equation'><tr><td>
<!-- l. 1098 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 1098 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mstyle class='label' id='x12-261002r76'></mstyle><!-- endlabel --><mi>V</mi> <mi>U</mi><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'>   <mn>0</mn>   </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><msup><mrow><mi>α</mi></mrow><mrow><mi>′</mi> </mrow> </msup>
  </mrow></msup> </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                      </mrow><mo fence='true' form='postfix'>)</mo></mrow>
</mrow></math></td><td class='eq-no'>(10.76)</td></tr></table>
<!-- l. 1104 --><p class='indent'>   for some <!-- l. 1104 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>α</mi></mrow><mrow><mi>′</mi></mrow></msup></math> which is
a multiple of <!-- l. 1104 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>. Hence
we can further reduce <!-- l. 1104 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> <mi>U</mi></mrow></math>
to the identity by applying the appropriate power of
<!-- l. 1104 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>.
Up to some small constant, synthesising a single qubit unitary
hence costs just as much as synthesising a single-qubit state
<!-- l. 1104 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>. The cost of
synthesising <!-- l. 1104 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> is directly
related to its lde <!-- l. 1104 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>.
To reduce it to lde 0 we need to apply for each reduction a Hadamard gate and some
power <!-- l. 1104 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>T</mi></mrow><mrow><mi>m</mi></mrow></msup></math> of
the <!-- l. 1104 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gate
where <!-- l. 1104 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>m</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>2</mn></mrow></math> or
<!-- l. 1104 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>3</mn></math>. If
<!-- l. 1104 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>m</mi><mo class='MathClass-rel' stretchy='false'>≠</mo><mn>1</mn></mrow></math> we can see this as
applying a <!-- l. 1104 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gate and/or
an <!-- l. 1104 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math> gate. We hence
get a sequence of <!-- l. 1104 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math>,
<!-- l. 1104 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> and
<!-- l. 1104 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
gates, where each application of the Hadamard reduces the
lde by at least 1. The total number of gates is hence at most
<!-- l. 1104 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>3</mn><mi>k</mi></mrow></math>, and the number of
Hadamard gates and <!-- l. 1104 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates is each at most <!-- l. 1104 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>.
You could wonder whether there is any way we could do better, but it turns out
that this number of gates is actually optimal! Suppose we start from the state
<!-- l. 1105 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> and we apply
Hadamard, <!-- l. 1105 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
and <!-- l. 1105 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates to it. Then we end up with some state that we can write as </p><table class='equation'><tr><td>
<!-- l. 1106 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 1106 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mstyle class='label' id='x12-261003r77'></mstyle><!-- endlabel --><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msup><mrow><mi>δ</mi></mrow><mrow><mi>k</mi></mrow></msup></mrow></mfrac> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <mi>x</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi mathvariant='italic'>yδ</mi> </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mi>z</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi mathvariant='italic'>wδ</mi> </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                       </mrow><mo fence='true' form='postfix'>)</mo></mrow><mo class='MathClass-punc' stretchy='false'>,</mo>
</mrow></math></td><td class='eq-no'>(10.77)</td></tr></table>
<!-- l. 1109 --><p class='indent'>   where <!-- l. 1109 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
is its least denominator exponent. Assuming that
<!-- l. 1109 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>&gt;</mo> <mn>0</mn></mrow></math> we see
that <!-- l. 1109 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi mathvariant='italic'>yδ</mi> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><mi>δ</mi></mrow></msub><mi>z</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi mathvariant='italic'>wδ</mi></mrow></math>, as
<!-- l. 1109 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> is normalised. Hence
<!-- l. 1109 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><mi>δ</mi></mrow></msub><mi>z</mi></mrow></math>. Furthermore, we
necessarily have <!-- l. 1109 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><mi>δ</mi></mrow></msub><mi>z</mi> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><mi>δ</mi></mrow></msub><mn>1</mn></mrow></math>
since otherwise both expressions would be further divisible by
<!-- l. 1109 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math> contradicting
<!-- l. 1109 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> being the lde.
Applying an <!-- l. 1110 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
and <!-- l. 1110 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gate to this state doesn’t change the denominator exponent, but a Hadamard can
change the lde. We calculate then: </p><table class='equation'><tr><td>
<!-- l. 1111 --><p class='indent'>
</p><!-- l. 1111 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mstyle class='label' id='x12-261004r78'></mstyle><!-- endlabel --><mi>H</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msup><mrow><mi>δ</mi></mrow><mrow><mi>k</mi></mrow></msup></mrow></mfrac>  <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mi>x</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>z</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>y</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>w</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi>δ</mi> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mi>x</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>z</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>y</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>w</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi>δ</mi></mtd>
</mtr>   <!-- *\c@MaxMatrixCols c --></mtable>                                                                               </mrow><mo fence='true' form='postfix'>)</mo></mrow><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td><td class='eq-no'>(10.78)</td></tr></table>
<!-- l. 1114 --><p class='indent'>   Since <!-- l. 1114 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi> <msub><mrow><mo class='MathClass-rel' stretchy='false'>≡</mo></mrow><mrow><mi>δ</mi></mrow></msub><mi>z</mi></mrow></math>,
we see then that each of the components of the vector
<!-- l. 1114 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>z</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>y</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>w</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi>δ</mi></mrow></math> and
<!-- l. 1114 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>z</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>y</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>w</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi>δ</mi></mrow></math> are divisible
by <!-- l. 1114 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math>. As
furthermore <!-- l. 1114 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msqrt><mrow><mn>2</mn></mrow></msqrt></math>
is <!-- l. 1114 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>δ</mi></mrow><mrow><mn>2</mn></mrow></msup></math> up to
some unit <!-- l. 1114 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>ω</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup><mi>λ</mi></mrow></math>,
we see then that </p><table class='equation'><tr><td>
<!-- l. 1115 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 1115 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mstyle class='label' id='x12-261005r79'></mstyle><!-- endlabel --><mi>H</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msup><mrow><mi>δ</mi></mrow><mrow><mi>k</mi></mrow></msup></mrow></mfrac> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msup><mrow><mi>δ</mi></mrow><mrow><mn>2</mn></mrow></msup></mrow></mfrac> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <msup><mrow><mi>a</mi></mrow><mrow><mi>′</mi></mrow></msup><mi>δ</mi> </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <msup><mrow><mi>b</mi></mrow><mrow><mi>′</mi></mrow></msup><mi>δ</mi> </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                           </mrow><mo fence='true' form='postfix'>)</mo></mrow><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace>  <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msup><mrow><mi>δ</mi></mrow><mrow><mi>k</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mn>1</mn></mrow></msup></mrow></mfrac> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <msup><mrow><mi>a</mi></mrow><mrow><mi>′</mi></mrow></msup> </mtd>
</mtr><mtr class='array-row'><mtd class='array-td' columnalign='center'> <msup><mrow><mi>b</mi></mrow><mrow><mi>′</mi></mrow></msup> </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                   </mrow><mo fence='true' form='postfix'>)</mo></mrow>
</mrow></math></td><td class='eq-no'>(10.79)</td></tr></table>
<!-- l. 1118 --><p class='indent'>   for some numbers <!-- l. 1118 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>a</mi></mrow><mrow><mi>′</mi></mrow></msup></math>
and <!-- l. 1118 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>b</mi></mrow><mrow><mi>′</mi></mrow></msup></math>.
Applying a Hadamard can hence only increase the lde by at most 1. So if we got some
state <!-- l. 1118 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> with
lde <!-- l. 1118 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>,
then we know the circuit building it must contain at least
<!-- l. 1118 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
Hadamards. But our synthesis algorithm requires <span class='cmti-10x-x-109'>at most</span>
<!-- l. 1118 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> Hadamards
to synthesise it. Hence the lde is <span class='cmti-10x-x-109'>exactly </span>equal to the optimal number of Hadamards
needed to synthesise it. Or, well, this is almost true, because our argument above only
holds if <!-- l. 1118 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>&gt;</mo> <mn>0</mn></mrow></math>. If
we have <!-- l. 1118 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>,
so that <!-- l. 1118 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
is a unit vector up to some phase, applying a Hadamard increases the lde by
<!-- l. 1118 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>2</mn></math>. So the number
of Hadamards is <!-- l. 1118 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math>.
This is actually what our synthesis algorithm above also finds if we were to analyse
it a bit more carefully, because it turns out that there are no normalised vectors
that have lde 1, so that in Eq. (<a href='#x12-259018r73'>10.73<!-- tex4ht:ref: eq:synthesis-lde-reduction  --></a>) our lde would actually reduce by 2 if we
had <!-- l. 1118 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>2</mn></mrow></math>
to start with.
</p>
   <div class='newtheorem'>
<!-- l. 1119 --><p class='noindent'><span class='head'>
<a id='x12-261006r16'></a>
<span class='cmbx-10x-x-109'>Exercise 10.16.</span>  </span>Prove that there are no normalised vectors that have lde 1.
<br class='newline' /><span class='cmti-10x-x-109'>Hint: This corresponds to showing that there are no vectors </span><!-- l. 1121 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>u</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi><msup><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow><mrow><mi>N</mi></mrow></msup></mrow></math>
<span class='cmti-10x-x-109'>for which </span><!-- l. 1121 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>⟨</mo><mi>u</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>u</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>δ</mi><mover accent='false' class='mml-overline'><mrow><mi>δ</mi></mrow><mo accent='true'>¯</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>2</mn> <mo class='MathClass-bin' stretchy='false'>+</mo> <msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></math><span class='cmti-10x-x-109'>.
Now use Eq. </span>(<a href='#x12-242002r2'>10.2<!-- tex4ht:ref: eq:ring-norm  --></a>) <span class='cmti-10x-x-109'>for the component norms </span><!-- l. 1121 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>u</mi></mrow><mrow><mi>i</mi></mrow></msub><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup></mrow></math><span class='cmti-10x-x-109'>,
and argue that the only possible solution to </span><!-- l. 1121 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>i</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>u</mi></mrow><mrow><mi>i</mi></mrow></msub><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>2</mn> <mo class='MathClass-bin' stretchy='false'>+</mo> <msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></math>
<span class='cmti-10x-x-109'>is  the  one  where  there  is  a  single  non-zero  component  which  is  in  fact
                                                                     

                                                                     
divisible by </span><!-- l. 1121 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math><span class='cmti-10x-x-109'>.</span>
</p>
   </div>
<!-- l. 1122 --><p class='indent'>    To conclude we hence see that if we have a vector with lde
<!-- l. 1123 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>,
then our synthesis algorithm requires an optimal number of
<!-- l. 1123 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math> Hadamards to
synthesise it, and up to <!-- l. 1123 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
<!-- l. 1123 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates. This last part is
because we can have a <!-- l. 1123 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gate after every Hadamard, but we can also have one appear before the first
one.
</p>
   <h4 class='subsectionHead' id='approximate-singlequbit-cliffordt-synthesis'><span class='titlemark'>10.7.3   </span> <a id='x12-26200010.7.3'></a>Approximate single-qubit Clifford+T synthesis*</h4>
<!-- l. 1125 --><p class='noindent'>In Section <a href='#approximating-arbitrary-singlequbit-gates'>10.1.2<!-- tex4ht:ref: sec:approx-main  --></a> we hinted at how we can do approximate
synthesis of arbitrary single-qubit unitaries using a
Clifford+<!-- l. 1125 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
circuit. In this section we will fill in some more details on how this works, though
some parts are a bit too technical even for this advanced section, and so we
will just refer to the References for details on how to do that. So we
have some arbitrary single-qubit unitary we want to approximate using
Clifford+<!-- l. 1126 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates. First we recall that any single-qubit unitary can be written as
<!-- l. 1126 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi>X</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>β</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>γ</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> for some phases
<!-- l. 1126 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>α</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>β</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>γ</mi></mrow></math>. Additionally,
<!-- l. 1126 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>X</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>β</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi mathvariant='italic'>HZ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>β</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi>H</mi></mrow></math>, so if we know
how to synthesise <!-- l. 1126 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
gates, then we can synthesise arbitrary single-qubit unitaries.
Let’s assume then that our goal is to approximate a
<!-- l. 1127 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> gate for some
arbitrary <!-- l. 1127 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>α</mi></math> using just
single-qubit Clifford+<!-- l. 1127 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates. First, it will be useful to work with matrices that have determinant 1, so we write
our <!-- l. 1128 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> and our
approximating unitary <!-- l. 1128 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
as follows: </p><table class='equation'><tr><td>
<!-- l. 1129 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 1129 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mstyle class='label' id='x12-262001r80'></mstyle><!-- endlabel --><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>iα</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn></mrow></msup>  </mtd><mtd class='array-td' columnalign='center'>     <mn>0</mn>    </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'>     <mn>0</mn>     </mtd><mtd class='array-td' columnalign='center'> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iα</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn></mrow></msup>  </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                                  </mrow><mo fence='true' form='postfix'>)</mo></mrow> <mspace class='quad' width='1em'></mspace><mi>U</mi><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace>  <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msup><mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow><mrow><mi>k</mi></mrow></msup></mrow></mfrac> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mi>u</mi> </mtd><mtd class='array-td' columnalign='center'> <mo class='MathClass-bin' stretchy='false'>−</mo><mover accent='false' class='mml-overline'><mrow><mi>t</mi></mrow><mo accent='true'>¯</mo></mover> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mi>t</mi> </mtd> <mtd class='array-td' columnalign='center'> <mover accent='false' class='mml-overline'><mrow><mi>u</mi> </mrow><mo accent='true'>¯</mo></mover></mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                        </mrow><mo fence='true' form='postfix'>)</mo></mrow>
</mrow></math></td><td class='eq-no'>(10.80)</td></tr></table>
<!-- l. 1138 --><p class='indent'>   Here <!-- l. 1138 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>u</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>t</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>. Note this this
means our definition of <!-- l. 1139 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
is different from the one we have been using in this book by a global
phase. Note also that we wrote our approximation unitary with a factor of
<!-- l. 1139 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mfrac><mrow><mn>1</mn></mrow>
<mrow><msup><mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow><mrow><mi>k</mi></mrow></msup></mrow></mfrac></mrow></math> in front of it, instead
of a power of <!-- l. 1139 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>δ</mi></math>.
This turns out to be nicer for this algorithm. We will fix an error budget
<!-- l. 1140 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝜖</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℝ</mi></mrow></math>, and require
<!-- l. 1140 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>∥</mo><mi>U</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>∥</mo> <mo class='MathClass-rel' stretchy='false'>&lt;</mo> <mi>𝜖</mi></mrow></math>. If we
found a <!-- l. 1140 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math> with
this property, then we know how to synthesise it using the algorithm we described in
the previous section, and this synthesis will have an optimal number of Hadamards and
<!-- l. 1140 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates, given the
lde <!-- l. 1140 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>. So our goal
then is to find a <!-- l. 1140 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
within <!-- l. 1140 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>𝜖</mi></math> of
<!-- l. 1140 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>, with as
low a <!-- l. 1140 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> as
possible. Given that we know how to determine whether a solution exists for a given
<!-- l. 1140 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>, we can find the
optimal value of <!-- l. 1140 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
by just starting low and increasing it until we find a solution. Since
<!-- l. 1140 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> won’t be too
big (it will be <!-- l. 1140 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --><mn>1</mn><mo class='MathClass-bin' stretchy='false'>∕</mo><mi>𝜖</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>),
this will still be efficient. We can hence assume that
<!-- l. 1140 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> and
<!-- l. 1140 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>𝜖</mi></math> are
fixed, and then we need to determine whether a solution exists, and if it does,
what this solution is. In practice the finding of the solution will also tell us
whether there is a solution, so we will focus on that. Our goal then is to find a
<!-- l. 1141 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math> as in Eq. (<a href='#x12-262001r80'>10.80<!-- tex4ht:ref: eq:approx-synth-unitaries  --></a>)
for some given <!-- l. 1141 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
and <!-- l. 1141 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>α</mi></math>, such
that <!-- l. 1141 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>∥</mo><mi>U</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>∥</mo> <mo class='MathClass-rel' stretchy='false'>&lt;</mo> <mi>𝜖</mi></mrow></math> for
some given <!-- l. 1141 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>𝜖</mi></math>.
In order to help us do that, we need to have a more concrete description of the
norm <!-- l. 1142 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>∥</mo><mi>U</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>∥</mo></mrow></math>
in terms of the matrix elements.
                                                                     

                                                                     
</p>
   <div class='newtheorem'>
<!-- l. 1143 --><p class='noindent'><span class='head'>
<a id='x12-262002r9'></a>
<span class='cmbx-10x-x-109'>Lemma 10.7.9.</span>  </span>Let <!-- l. 1144 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>u</mi></mrow><mrow><mi>n</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo>   <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msup><mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow><mrow><mi>k</mi></mrow></msup></mrow></mfrac><mi>u</mi></mrow></math>
and <!-- l. 1144 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>t</mi></mrow><mrow><mi>n</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo>   <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msup><mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow><mrow><mi>k</mi></mrow></msup></mrow></mfrac><mi>t</mi></mrow></math> be the
normalised versions of <!-- l. 1144 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>u</mi></math>
and <!-- l. 1144 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>t</mi></math>, and
define <!-- l. 1144 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>z</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>iα</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn></mrow></msup></mrow></math>.
Then: </p><table class='equation-star'><tr><td>
<!-- l. 1145 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                    <mo class='MathClass-rel' stretchy='false'>∥</mo><mi>U</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo><msup><mrow><mo class='MathClass-rel' stretchy='false'>∥</mo></mrow><mrow><mn>2</mn></mrow></msup><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>u</mi></mrow><mrow>
<mi>n</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>z</mi><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>t</mi></mrow><mrow>
<mi>n</mi></mrow></msub><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup>
</mrow></math></td></tr></table>
   </div>
<!-- l. 1146 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 1148 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>Note first that <!-- l. 1148 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>∥</mo><mi>U</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>∥</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>∥</mo><mi>I</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>∥</mo></mrow></math>
by the unitary invariance of the operator norm. Now,
<!-- l. 1148 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> is unitary, and hence
has two eigenvectors <!-- l. 1148 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>ϕ</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
with eigenvalues <!-- l. 1148 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><msub><mrow><mi>α</mi></mrow><mrow><mi>j</mi></mrow></msub></mrow></msup></math>.
Because <!-- l. 1148 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math> and
<!-- l. 1148 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> both have determinant
1 we have <!-- l. 1148 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>1</mn> <mo class='MathClass-rel' stretchy='false'>=</mo> <mstyle class='text'><mtext>det</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><msub><mrow><mi>α</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><msub><mrow><mi>α</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></msup></mrow></math>, and
hence setting <!-- l. 1148 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>α</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>α</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></math> we
necessarily have <!-- l. 1148 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>α</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-bin' stretchy='false'>−</mo><mi>α</mi></mrow></math>. The
eigenvectors of <!-- l. 1148 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> are
                                                                     

                                                                     
also eigenvectors of <!-- l. 1148 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>I</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
and have eigenvalue <!-- l. 1148 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>1</mn> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>±</mo><mi mathvariant='italic'>iα</mi></mrow></msup></mrow></math>,
so that <!-- l. 1148 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>∥</mo><mi>I</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>∥</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iα</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>.
Recall that the Hilbert-Schmidt norm of a matrix
<!-- l. 1149 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math> is given
by <!-- l. 1149 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>∥</mo><mi>A</mi><msubsup><mrow><mo class='MathClass-rel' stretchy='false'>∥</mo></mrow><mrow><mstyle class='text'><mtext>HS</mtext></mstyle></mrow><mrow><mn>2</mn></mrow></msubsup> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow> <mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>∥</mo><mi>A</mi><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>ψ</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo><msup><mrow><mo class='MathClass-rel' stretchy='false'>∥</mo></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow><mo> ∑</mo>
<!-- nolimits --></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>⟨</mo><msub><mrow><mi>ψ</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><msup><mrow><mi>A</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mi>A</mi><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>ψ</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> where
the <!-- l. 1149 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>{</mo><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>ψ</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math> form
an orthonormal basis. It is a standard exercise in linear algebra to show that the
Hilbert-Schmidt norm is independent of choice of orthonormal basis. Choosing the
eigenbasis of <!-- l. 1149 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
we see that <!-- l. 1149 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>∥</mo><mi>I</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo><msubsup><mrow><mo class='MathClass-rel' stretchy='false'>∥</mo></mrow><mrow><mstyle class='text'><mtext>HS</mtext></mstyle></mrow><mrow><mn>2</mn></mrow></msubsup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>2</mn><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iα</mi></mrow></msup><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>2</mn><mo class='MathClass-rel' stretchy='false'>∥</mo><mi>I</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo><msup><mrow><mo class='MathClass-rel' stretchy='false'>∥</mo></mrow><mrow><mn>2</mn></mrow></msup></mrow></math>,
as both eigenvalues have equal magnitude. Instead picking
<!-- l. 1150 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>,
<!-- l. 1150 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> for our orthonormal
basis, we calculate that <!-- l. 1150 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>∥</mo><mi>U</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo><msubsup><mrow><mo class='MathClass-rel' stretchy='false'>∥</mo></mrow><mrow><mstyle class='text'><mtext>HS</mtext></mstyle></mrow><mrow><mn>2</mn></mrow></msubsup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>2</mn><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>u</mi></mrow><mrow><mi>n</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>z</mi><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>2</mn><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>t</mi></mrow><mrow><mi>n</mi></mrow></msub><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup></mrow></math>
by just evaluating the matrices. Putting these different expressions for the norm
together, we calculate:
</p><!-- tex4ht:inline --><!-- l. 1155 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mtable class='align-star' columnalign='left' displaystyle='true'>
         <mtr><mtd class='align-odd' columnalign='right'><mo class='MathClass-rel' stretchy='false'>∥</mo><mi>U</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo><msup><mrow><mo class='MathClass-rel' stretchy='false'>∥</mo></mrow><mrow><mn>2</mn></mrow></msup><mspace class='nbsp' width='0.33em'></mspace></mtd>         <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-rel' stretchy='false'>∥</mo><mi>I</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo><msup><mrow><mo class='MathClass-rel' stretchy='false'>∥</mo></mrow><mrow><mn>2</mn></mrow></msup><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><mo class='MathClass-rel' stretchy='false'>∥</mo><mi>I</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo><msubsup><mrow><mo class='MathClass-rel' stretchy='false'>∥</mo></mrow><mrow>
<mstyle class='text'><mtext>HS</mtext></mstyle></mrow><mrow><mn>2</mn></mrow></msubsup><mspace class='nbsp' width='0.33em'></mspace><mspace width='2em'></mspace></mtd>         <mtd class='align-label' columnalign='right'></mtd>         <mtd class='align-label'>
         <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>                     <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><mo class='MathClass-rel' stretchy='false'>∥</mo><mi>U</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo><msubsup><mrow><mo class='MathClass-rel' stretchy='false'>∥</mo></mrow><mrow><mstyle class='text'><mtext>HS</mtext></mstyle></mrow><mrow><mn>2</mn></mrow></msubsup><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>u</mi></mrow><mrow>
<mi>n</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>z</mi><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>t</mi></mrow><mrow>
<mi>n</mi></mrow></msub><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup><mspace width='2em'></mspace></mtd>         <mi>□</mi>
   </mtr></mtable></math>
   </div>
<!-- l. 1157 --><p class='indent'>   Now, using the fact that <!-- l. 1157 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>u</mi></mrow><mrow><mi>n</mi></mrow></msub><mover accent='false' class='mml-overline'><mrow><msub><mrow><mi>u</mi></mrow><mrow><mi>n</mi></mrow></msub></mrow><mo accent='true'>¯</mo></mover> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>t</mi></mrow><mrow><mi>n</mi></mrow></msub><mover accent='false' class='mml-overline'><mrow><msub><mrow><mi>t</mi></mrow><mrow><mi>n</mi></mrow></msub></mrow><mo accent='true'>¯</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>
and <!-- l. 1157 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>z</mi><mover accent='false' class='mml-overline'><mrow><mi>z</mi></mrow><mo accent='true'>¯</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>, we can
expand <!-- l. 1157 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>u</mi></mrow><mrow><mi>n</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>z</mi><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>t</mi></mrow><mrow><mi>n</mi></mrow></msub><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup></mrow></math>
further and simplify some more:
                                                                     

                                                                     
</p><!-- tex4ht:inline --><!-- l. 1162 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mtable class='align-star' columnalign='left' displaystyle='true'>
           <mtr><mtd class='align-odd' columnalign='right'><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>u</mi></mrow><mrow><mi>n</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>z</mi><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>t</mi></mrow><mrow>
<mi>n</mi></mrow></msub><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup><mspace class='nbsp' width='0.33em'></mspace></mtd>           <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>u</mi></mrow><mrow>
<mi>n</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>z</mi><mo class='MathClass-close' stretchy='false'>)</mo><mover accent='false' class='mml-overline'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>u</mi></mrow><mrow><mi>n</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>z</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mo accent='true'>¯</mo></mover> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>t</mi></mrow><mrow><mi>n</mi></mrow></msub><mover accent='false' class='mml-overline'><mrow><msub><mrow><mi>t</mi></mrow><mrow><mi>n</mi></mrow></msub></mrow><mo accent='true'>¯</mo></mover><mspace width='2em'></mspace></mtd>                 <mtd class='align-label' columnalign='right'></mtd>           <mtd class='align-label'>
           <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>                          <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><msub><mrow><mi>u</mi></mrow><mrow><mi>n</mi></mrow></msub><mover accent='false' class='mml-overline'><mrow><msub><mrow><mi>u</mi></mrow><mrow><mi>n</mi></mrow></msub></mrow><mo accent='true'>¯</mo></mover> <mo class='MathClass-bin' stretchy='false'>−</mo> <msub><mrow><mi>u</mi></mrow><mrow><mi>n</mi></mrow></msub><mover accent='false' class='mml-overline'><mrow><mi>z</mi></mrow><mo accent='true'>¯</mo></mover> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>z</mi><mover accent='false' class='mml-overline'><mrow><msub><mrow><mi>u</mi></mrow><mrow><mi>n</mi></mrow></msub></mrow><mo accent='true'>¯</mo></mover> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>z</mi><mover accent='false' class='mml-overline'><mrow><mi>z</mi></mrow><mo accent='true'>¯</mo></mover> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>t</mi></mrow><mrow><mi>n</mi></mrow></msub><mover accent='false' class='mml-overline'><mrow><msub><mrow><mi>t</mi></mrow><mrow><mi>n</mi></mrow></msub></mrow><mo accent='true'>¯</mo></mover><mspace width='2em'></mspace></mtd>           <mtd class='align-label' columnalign='right'></mtd>           <mtd class='align-label'>
           <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>                          <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mn>2</mn> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>2</mn><mi>ℜ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='false' class='mml-overline'><mrow><mi>z</mi></mrow><mo accent='true'>¯</mo></mover><msub><mrow><mi>u</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-punc' stretchy='false'>.</mo><mspace width='2em'></mspace></mtd>                           <mtd class='align-label' columnalign='right'></mtd>           <mtd class='align-label'>
   <mspace width='2em'></mspace></mtd></mtr></mtable></math>
<!-- l. 1163 --><p class='noindent'>Here <!-- l. 1163 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℜ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='false' class='mml-overline'><mrow><mi>z</mi></mrow><mo accent='true'>¯</mo></mover><msub><mrow><mi>u</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> denotes the real part
of the complex number <!-- l. 1163 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='false' class='mml-overline'><mrow><mi>z</mi></mrow><mo accent='true'>¯</mo></mover><msub><mrow><mi>u</mi></mrow><mrow><mi>n</mi></mrow></msub></mrow></math>.
So if <!-- l. 1164 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
is a solution to our approximation problem, then
<!-- l. 1164 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>2</mn> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>2</mn><mi>ℜ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='false' class='mml-overline'><mrow><mi>z</mi></mrow><mo accent='true'>¯</mo></mover><msub><mrow><mi>u</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>≤</mo> <msup><mrow><mi>𝜖</mi></mrow><mrow><mn>2</mn></mrow></msup></mrow></math>, or equivalently
<!-- l. 1164 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℜ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='false' class='mml-overline'><mrow><mi>z</mi></mrow><mo accent='true'>¯</mo></mover><msub><mrow><mi>u</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mn>1</mn> <mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><msup><mrow><mi>𝜖</mi></mrow><mrow><mn>2</mn></mrow></msup></mrow> 
 <mrow><mn>2</mn></mrow></mfrac> </mrow></math>. Interestingly, this
does not depend on <!-- l. 1164 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>t</mi></mrow><mrow><mi>n</mi></mrow></msub></math>,
but only <!-- l. 1164 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>u</mi></mrow><mrow><mi>n</mi></mrow></msub></math>. Furthermore,
if we write <!-- l. 1164 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>u</mi></mrow><mrow><mi>n</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>a</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi mathvariant='italic'>bi</mi></mrow></math>
and <!-- l. 1164 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>z</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>x</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi mathvariant='italic'>yi</mi></mrow></math>,
then we can interpret them as 2-dimensional real vectors
<!-- l. 1164 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mover accent='true'><mrow><mi>u</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>n</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>a</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>b</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> and
<!-- l. 1164 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>z</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>, and then
<!-- l. 1164 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℜ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='false' class='mml-overline'><mrow><mi>z</mi></mrow><mo accent='true'>¯</mo></mover><msub><mrow><mi>u</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow> <mover accent='true'><mrow><mi>u</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>n</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⋅</mo><mover accent='true'><mrow><mi>z</mi></mrow><mo accent='true'>→</mo></mover></mrow></math> is just a
dot-product. We hence want to solve the following problem: given a 2-dimensional real
unit-vector <!-- l. 1165 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>z</mi></mrow><mo accent='true'>→</mo></mover></math>, find a
subnormalised vector <!-- l. 1165 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mover accent='true'><mrow><mi>u</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>n</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>a</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>b</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>,
such that <!-- l. 1165 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mover accent='true'><mrow><mi>u</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>n</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⋅</mo><mover accent='true'><mrow><mi>z</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mn>1</mn> <mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><msup><mrow><mi>𝜖</mi></mrow><mrow><mn>2</mn></mrow></msup></mrow> 
 <mrow><mn>2</mn></mrow></mfrac> </mrow></math>, where
<!-- l. 1165 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>b</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo> <mfrac><mrow><mn>1</mn></mrow>
<mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math> and we allow some
maximal power of <!-- l. 1165 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mfrac><mrow><mn>1</mn></mrow>
<mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac></mrow></math>
depending on <!-- l. 1165 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>. We
call this a <span class='cmbx-10x-x-109'>grid problem</span>, because we have some target region, the vectors whose inner product
with <!-- l. 1165 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>z</mi></mrow><mo accent='true'>→</mo></mover></math> is very close
to <!-- l. 1165 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>, and a grid of
points, given by <!-- l. 1165 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><msup><mrow><mo class='MathClass-open' stretchy='false'>[</mo> <mfrac><mrow><mn>1</mn></mrow>
<mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac><mo class='MathClass-close' stretchy='false'>]</mo></mrow><mrow><mn>2</mn></mrow></msup></mrow></math>,
and we want to find a point on this grid that is in the target region. It turns out
that this problem is efficiently solvable, although describing in full how
to do so is quite lengthy (see the References of this chapter). So let’s
suppose that we can solve the grid problem, and hence that we get a
<!-- l. 1166 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>u</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>n</mi></mrow></msub></math> satisfying
<!-- l. 1166 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mover accent='true'><mrow><mi>u</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>n</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⋅</mo><mover accent='true'><mrow><mi>z</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mn>1</mn> <mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><msup><mrow><mi>𝜖</mi></mrow><mrow><mn>2</mn></mrow></msup></mrow> 
 <mrow><mn>2</mn></mrow></mfrac> </mrow></math>. This then gives
us the candidate <!-- l. 1166 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>u</mi></math>
we are looking for. But we then still need to find a
<!-- l. 1166 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>t</mi></math>, so that the
matrix <!-- l. 1166 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math> defined
as in Eq. (<a href='#x12-262001r80'>10.80<!-- tex4ht:ref: eq:approx-synth-unitaries  --></a>) is in fact unitary. The only equation we need to satisfy for this matrix to
                                                                     

                                                                     
be unitary is <!-- l. 1166 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>u</mi><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mi>t</mi><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mn>2</mn></mrow><mrow><mi>k</mi></mrow></msup></mrow></math>,
as this means that the columns of the matrix correspond to normalised
vectors. We know the expression for a norm for an element in
<!-- l. 1166 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℤ</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>, this is namely given
by Eq. (<a href='#x12-242002r2'>10.2<!-- tex4ht:ref: eq:ring-norm  --></a>): for <!-- l. 1166 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>z</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>a</mi><msup><mrow><mi>ω</mi></mrow><mrow><mn>3</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>b</mi><msup><mrow><mi>ω</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi mathvariant='italic'>cω</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>d</mi></mrow></math>
we have </p><table class='equation-star'><tr><td>
<!-- l. 1167 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
         <mo class='MathClass-rel' stretchy='false'>|</mo><mi>z</mi><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='false' class='mml-overline'><mrow><mi>z</mi></mrow><mo accent='true'>¯</mo></mover><mi>z</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>a</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>b</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>c</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>d</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi mathvariant='italic'>cd</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi mathvariant='italic'>bc</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi mathvariant='italic'>ab</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi mathvariant='italic'>da</mi><mo class='MathClass-close' stretchy='false'>)</mo><msqrt><mrow><mn>2</mn></mrow></msqrt><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td></tr></table>
<!-- l. 1170 --><p class='indent'>   Rewriting the equation <!-- l. 1170 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>u</mi><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mi>t</mi><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mn>2</mn></mrow><mrow><mi>k</mi></mrow></msup></mrow></math>
to isolate our unknown <!-- l. 1170 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>t</mi></math> we
get <!-- l. 1170 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>t</mi><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mn>2</mn></mrow><mrow><mi>k</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mi>u</mi><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-punc' stretchy='false'>.</mo></mrow></math> But this right-hand
side will now be some <!-- l. 1171 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ζ</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>x</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>y</mi><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></math>
for integers <!-- l. 1171 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi></mrow></math>.
Writing <!-- l. 1171 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>t</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>a</mi><msup><mrow><mi>ω</mi></mrow><mrow><mn>3</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>b</mi><msup><mrow><mi>ω</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi mathvariant='italic'>cω</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>d</mi></mrow></math>,
we can also expand the left-hand side. We then have a part of the equation that
results in an integer, and a different part that results in an integer multiple of
<!-- l. 1171 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msqrt><mrow>
<mn>2</mn></mrow></msqrt></math>.
These need to be independently satisfied, so that we can split the equation up
into two parts:
</p><!-- tex4ht:inline --><!-- l. 1175 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mtable class='align-star' columnalign='left' displaystyle='true'>
                        <mtr><mtd class='align-odd' columnalign='right'><msup><mrow><mi>a</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>b</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>c</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>d</mi></mrow><mrow><mn>2</mn></mrow></msup><mspace class='nbsp' width='0.33em'></mspace></mtd>                        <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mi>x</mi><mspace width='2em'></mspace></mtd>                        <mtd class='align-label' columnalign='right'></mtd>                        <mtd class='align-label'>
                        <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'><mi mathvariant='italic'>ab</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi mathvariant='italic'>bc</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi mathvariant='italic'>cd</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi mathvariant='italic'>da</mi><mspace class='nbsp' width='0.33em'></mspace></mtd>                        <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mi>y</mi><mspace width='2em'></mspace></mtd>                        <mtd class='align-label' columnalign='right'></mtd>                        <mtd class='align-label'>
   <mspace width='2em'></mspace></mtd></mtr></mtable></math>
<!-- l. 1176 --><p class='noindent'>This is a pair of quadratic equations over the integers, and is hence a special case
                                                                     

                                                                     
of a <span class='cmbx-10x-x-109'>Diophantine equation</span>. While these are in general hard to solve,
in this particular case it turns out that a large proportion of them are
fast to solve. So in practice, we can try a bunch of candidates until we
find one for which our solution strategy works. Once the details about
solving the grid problem and this Diophantine equation are filled in,
this gives an algorithm that gives an approximation of the phase gate
<!-- l. 1177 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
using Clifford+T gates that uses an optimal number of Hadamard and
<!-- l. 1177 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates. The length
of the circuit scales quite well with the desired precision. For instance, we can approximate
<!-- l. 1177 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>π</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>128</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> to within
<!-- l. 1177 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝜖</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn><msup><mrow><mn>0</mn></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>10</mn></mrow></msup></mrow></math> with a circuit
containing 102 <!-- l. 1177 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates. This algorithm turns out to be both efficient and <span class='cmti-10x-x-109'>optimal</span>. However, this
optimality guarantee only applies when we restrict to unitary ancilla-free circuits. If
we allow ancillae, measurements or classical control it is possible to do better by
some constant factors. The optimal number in the unitary ancilla-free case scales as
<!-- l. 1178 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>3</mn><msub><mrow><mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-bin' stretchy='false'>∕</mo><mi>𝜖</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>C</mi></mrow></math> for some small
constant <!-- l. 1178 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>C</mi></math>,
while the best known protocol when we allow measurements and classical control
scales as <!-- l. 1178 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mn>1</mn></mrow>
<mrow><mn>2</mn></mrow></mfrac><msub><mrow> <mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-bin' stretchy='false'>∕</mo><mi>𝜖</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>C</mi></mrow><mrow><mi>′</mi></mrow></msup></mrow></math>
(see the References of this chapter).
</p>
   <h4 class='subsectionHead' id='computational-universality-of-toffolihadamard'><span class='titlemark'>10.7.4   </span> <a id='x12-26300010.7.4'></a>Computational universality of Toffoli-Hadamard*</h4>
<!-- l. 1180 --><p class='noindent'>In this section we will show that the set of <span class='cmti-10x-x-109'>real-valued </span>unitaries, i.e. where all
matrix entries are real numbers, is computationally universal. Then we will show
that in fact the restriction to just Toffoli and Hadamard is already computationally
universal. First, obviously real-valued unitaries are not <span class='cmti-10x-x-109'>approximately</span>
universal as we can never approximate any complex-valued unitary (like the
<!-- l. 1181 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
gate). But as we saw in Section <a href='#computational-universality-via-catalysis'>10.5.2<!-- tex4ht:ref: sec:comp-universal  --></a> for a different gate set,
it turns out we can ‘simulate’ complex-valued unitaries using a
real-valued one on a larger set of qubits. For a (complex-valued)
<!-- l. 1182 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit
unitary <!-- l. 1182 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>, let
<!-- l. 1182 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℜ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>U</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> be the real part
of <!-- l. 1182 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>. That is:
<!-- l. 1182 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℜ</mi><msub><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>U</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi mathvariant='italic'>ij</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>ℜ</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>U</mi></mrow><mrow><mi mathvariant='italic'>ij</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>. Similarly define
the complex part <!-- l. 1182 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℑ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>U</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
Then <!-- l. 1182 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>U</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>ℜ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>U</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi mathvariant='italic'>iℑ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>U</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>. Now
define the <!-- l. 1183 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>-qubit
                                                                     

                                                                     
unitary <!-- l. 1183 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover></math>
via
</p><!-- tex4ht:inline --><!-- l. 1187 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mtable class='align-star' columnalign='left' displaystyle='true'>
          <mtr><mtd class='align-odd' columnalign='right'><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>)</mo><mspace class='nbsp' width='0.33em'></mspace></mtd>          <mtd class='align-even'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>ℜ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>U</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>ℑ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>U</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>)</mo><mspace width='2em'></mspace></mtd>             <mtd class='align-label' columnalign='right'></mtd>          <mtd class='align-label'>
          <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>)</mo><mspace class='nbsp' width='0.33em'></mspace></mtd>          <mtd class='align-even'> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-bin' stretchy='false'>−</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>ℑ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>U</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>ℜ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>U</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>)</mo><mspace width='2em'></mspace></mtd>          <mtd class='align-label' columnalign='right'></mtd>          <mtd class='align-label'>
   <mspace width='2em'></mspace></mtd></mtr></mtable></math>
<!-- l. 1188 --><p class='noindent'>While it is clear that <!-- l. 1188 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover></math>
is real-valued, it is not immediately obvious that it is unitary.
</p>
   <div class='newtheorem'>
<!-- l. 1189 --><p class='noindent'><span class='head'>
<a id='x12-263001r17'></a>
<span class='cmbx-10x-x-109'>Exercise 10.17.</span>  </span>In this exercise we will show that
<!-- l. 1190 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover></math> is indeed unitary
for any choice of <!-- l. 1190 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>.
   </p><dl class='enumerate'><dt class='enumerate'>
a) </dt><dd class='enumerate'>
   <!-- l. 1192 --><p class='noindent'>Express <!-- l. 1192 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℜ</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
   and <!-- l. 1192 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℑ</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
   in terms of <!-- l. 1192 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℜ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>U</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
   and <!-- l. 1192 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℑ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>U</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
   </p></dd><dt class='enumerate'>
b) </dt><dd class='enumerate'>
   <!-- l. 1193 --><p class='noindent'>Express <!-- l. 1193 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℜ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi mathvariant='italic'>UV</mi> <mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
   and <!-- l. 1193 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℑ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi mathvariant='italic'>UV</mi> <mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
   in terms of <!-- l. 1193 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℜ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>U</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>,
   <!-- l. 1193 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℜ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>V</mi> <mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>,
   <!-- l. 1193 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℑ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>U</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
   and <!-- l. 1193 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℑ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>V</mi> <mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
                                                                     

                                                                     
   </p></dd><dt class='enumerate'>
c) </dt><dd class='enumerate'>
   <!-- l. 1194 --><p class='noindent'>Show that <!-- l. 1194 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-open' stretchy='false'>⟨</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo><mo class='MathClass-open' stretchy='false'>⟨</mo><mi>ψ</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-close' stretchy='false'>)</mo><msup><mrow><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo><mo class='MathClass-rel' stretchy='false'>|</mo><msup><mrow><mi>ψ</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>⟨</mo><mi>ψ</mi><mo class='MathClass-rel' stretchy='false'>|</mo><msup><mrow><mi>ψ</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
   Hint: You will need <!-- l. 1194 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℜ</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mi>U</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>ℜ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>I</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi></mrow></math>.
   </p></dd><dt class='enumerate'>
d) </dt><dd class='enumerate'>
   <!-- l. 1195 --><p class='noindent'>Show that <!-- l. 1195 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-open' stretchy='false'>⟨</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo><mo class='MathClass-open' stretchy='false'>⟨</mo><mi>ψ</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-close' stretchy='false'>)</mo><msup><mrow><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo><mo class='MathClass-rel' stretchy='false'>|</mo><msup><mrow><mi>ψ</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>.
   Hint: You will need <!-- l. 1195 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ℑ</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mi>U</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>ℑ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>I</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>.
   </p></dd><dt class='enumerate'>
e) </dt><dd class='enumerate'>
   <!-- l. 1196 --><p class='noindent'>Conclude that <!-- l. 1196 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover></math>
   is indeed unitary. </p></dd></dl>
   </div>
<!-- l. 1198 --><p class='indent'>     The encoding into <!-- l. 1208 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover></math>
is also compositional, meaning we can apply it iteratively to a sequence of
unitaries.
</p>
   <div class='newtheorem'>
<!-- l. 1209 --><p class='noindent'><span class='head'>
<a id='x12-263007r18'></a>
<span class='cmbx-10x-x-109'>Exercise 10.18.</span>  </span>Show that <!-- l. 1210 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi mathvariant='italic'>UV</mi> </mrow><mo accent='true'>~</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover><mover accent='true'><mrow><mi>V</mi> </mrow><mo accent='true'>~</mo></mover></mrow></math>.
<span class='cmti-10x-x-109'>Hint: Use a case distinction on input states </span><!-- l. 1210 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo></mrow></math>
<span class='cmti-10x-x-109'>and </span><!-- l. 1210 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math><span class='cmti-10x-x-109'>.</span>
</p>
   </div>
<!-- l. 1211 --><p class='indent'>    Note that this construction is in fact an example of catalysis, as:
</p><table class='equation'><tr><td>
<!-- l. 1213 --><p class='indent'>
</p><!-- l. 1213 --><object id='x12-263008r81' data="svgs/eq-cat-real-encode.svg" alt="diagram of eq:cat-real-encode" class="svg-diagram"></object></td><td class='eq-no'>(10.81)</td></tr></table>
                                                                     

                                                                     
   <div class='newtheorem'>
<!-- l. 1216 --><p class='noindent'><span class='head'>
<a id='x12-263009r19'></a>
<span class='cmbx-10x-x-109'>Exercise 10.19.</span>  </span>Prove Eq. (<a href='#x12-263008r81'>10.81<!-- tex4ht:ref: eq:cat-real-encode  --></a>).
</p>
   </div>
<!-- l. 1218 --><p class='indent'>    We can however not use the argument of Section <a href='#computational-universality-via-catalysis'>10.5.2<!-- tex4ht:ref: sec:comp-universal  --></a> to use this to show
real-valued unitaries are computationally universal as there is no way to write the
<!-- l. 1219 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mi>S</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mi>S</mi><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>
catalyst state in terms of states that can be prepared by real-valued
unitaries. We can however use a different argument to prove computational
universality.
</p>
   <div class='newtheorem'>
<!-- l. 1220 --><p class='noindent'><span class='head'>
<a id='x12-263010r10'></a>
<span class='cmbx-10x-x-109'>Proposition 10.7.10.</span>  </span>   Real-valued    unitaries    are    computationally
universal.
</p>
   </div>
<!-- l. 1222 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 1224 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>Suppose <!-- l. 1224 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>C</mi></math> is an
<!-- l. 1224 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit circuit built out
of unitaries as <!-- l. 1224 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>C</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>U</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>U</mi></mrow><mrow><mi>k</mi></mrow></msub></mrow></math>. We then
build the real-valued <!-- l. 1224 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>-qubit
circuit <!-- l. 1224 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>C</mi></mrow><mo accent='true'>~</mo></mover></math>
by <!-- l. 1224 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>C</mi></mrow><mo accent='true'>~</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='true'><mrow><msub><mrow><mi>U</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow><mo accent='true'>~</mo></mover><mo class='MathClass-rel' stretchy='false'>⋯</mo><mover accent='true'><mrow><msub><mrow><mi>U</mi></mrow><mrow><mi>k</mi></mrow></msub></mrow><mo accent='true'>~</mo></mover></mrow></math>.
Then note that:
                                                                     

                                                                     
</p><!-- tex4ht:inline --><!-- l. 1228 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mtable class='align-star' columnalign='left' displaystyle='true'>
                <mtr><mtd class='align-odd' columnalign='right'><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-open' stretchy='false'>⟨</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo><mo class='MathClass-open' stretchy='false'>⟨</mo><mi>ψ</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-close' stretchy='false'>)</mo><mover accent='true'><mrow><mi>C</mi></mrow><mo accent='true'>~</mo></mover><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo><mo class='MathClass-rel' stretchy='false'>|</mo><msup><mrow><mi>ψ</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>)</mo><mspace class='nbsp' width='0.33em'></mspace></mtd>                <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mi>ψ</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ℜ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>C</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>|</mo><msup><mrow><mi>ψ</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace width='2em'></mspace></mtd>                <mtd class='align-label' columnalign='right'></mtd>                <mtd class='align-label'>
                <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-open' stretchy='false'>⟨</mo><mn>1</mn><mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo><mo class='MathClass-open' stretchy='false'>⟨</mo><mi>ψ</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-close' stretchy='false'>)</mo><mover accent='true'><mrow><mi>C</mi></mrow><mo accent='true'>~</mo></mover><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo><mo class='MathClass-rel' stretchy='false'>|</mo><msup><mrow><mi>ψ</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>)</mo><mspace class='nbsp' width='0.33em'></mspace></mtd>                <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mi>ψ</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ℑ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>C</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>|</mo><msup><mrow><mi>ψ</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-punc' stretchy='false'>.</mo><mspace width='2em'></mspace></mtd>                <mtd class='align-label' columnalign='right'></mtd>                <mtd class='align-label'>
   <mspace width='2em'></mspace></mtd></mtr></mtable></math>
<!-- l. 1229 --><p class='noindent'>Hence, if we input <!-- l. 1229 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo><mo class='MathClass-rel' stretchy='false'>|</mo><msup><mrow><mi>ψ</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
into <!-- l. 1229 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>C</mi></mrow><mo accent='true'>~</mo></mover></math>
and do a measurement marginalising over the first qubit we also get the
probabilities: </p><table class='equation-star'><tr><td>
<!-- l. 1230 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
       <munder class='msub'><mrow><mo>∑</mo>
  </mrow><mrow><mi>x</mi><mo class='MathClass-rel' stretchy='false'>=</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn></mrow></munder><mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-open' stretchy='false'>⟨</mo><mi>x</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>ψ</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>C</mi></mrow><mo accent='true'>~</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mi>ψ</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>⟩</mo><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-open' stretchy='false'>⟨</mo><mi>ψ</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ℜ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>C</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>|</mo><msup><mrow><mi>ψ</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>⟩</mo><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-open' stretchy='false'>⟨</mo><mi>ψ</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ℑ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>C</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>|</mo><msup><mrow><mi>ψ</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>⟩</mo><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td></tr></table>
<!-- l. 1233 --><p class='indent'>   Now, we can also, with some effort, calculate that
<!-- l. 1233 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-open' stretchy='false'>⟨</mo><mi>ψ</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>C</mi><mo class='MathClass-rel' stretchy='false'>|</mo><msup><mrow><mi>ψ</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>⟩</mo><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-open' stretchy='false'>⟨</mo><mi>ψ</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ℜ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>C</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>|</mo><msup><mrow><mi>ψ</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>⟩</mo><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-open' stretchy='false'>⟨</mo><mi>ψ</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ℑ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>C</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>|</mo><msup><mrow><mi>ψ</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>⟩</mo><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup></mrow></math>.
Hence, the probability distribution we get for
<!-- l. 1234 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>C</mi></math> is the same as that
for <!-- l. 1234 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>C</mi></mrow><mo accent='true'>~</mo></mover></math> when we prepare
the first qubit in the <!-- l. 1234 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
state and ignore its measurement outcome.                                         □
</p>
   </div>
<!-- l. 1236 --><p class='indent'>   Because we can simulate complex-valued quantum circuits using
real-valued unitaries in this direct manner, we don’t need <span class='cmti-10x-x-109'>all </span>the
real-valued unitaries. Given some approximately universal gate set
<!-- l. 1236 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>G</mi></math> we only need to be
able to represent <!-- l. 1236 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover></math> for
<!-- l. 1236 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>U</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>G</mi></mrow></math>. For instance, let’s
take the Clifford+<!-- l. 1237 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gate set <!-- l. 1237 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>G</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>{</mo><mi>T</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>H</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mstyle class='text'><mtext>CNOT</mtext></mstyle><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>.
Now, <!-- l. 1237 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math>
and <!-- l. 1237 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle class='text'><mtext>CNOT</mtext></mstyle></math>
are already real-valued, and it is easy to see that
<!-- l. 1237 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>U</mi></mrow><mo accent='true'>~</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>U</mi></mrow></math> if
                                                                     

                                                                     
<!-- l. 1237 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
is real-valued, so that it remains to see what gates we need for
<!-- l. 1237 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>T</mi></mrow><mo accent='true'>~</mo></mover></math>.
Calculating its matrix, we see that it is </p><table class='equation-star'><tr><td>
<!-- l. 1238 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mover accent='true'><mrow><mi>T</mi></mrow><mo accent='true'>~</mo></mover><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'>   <mn>0</mn>   </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'>    <mn>0</mn>    </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'>   <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac>  </mtd><mtd class='array-td' columnalign='center'>  <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mo class='MathClass-bin' stretchy='false'>−</mo> <mfrac><mrow><mn>1</mn></mrow>
<mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac>  </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'>   <mn>0</mn>   </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'>    <mn>0</mn>    </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'>   <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac>  </mtd><mtd class='array-td' columnalign='center'>  <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'>    <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac>    </mtd>
</mtr>    <!-- *\c@MaxMatrixCols c --></mtable>                                                                                                                        </mrow><mo fence='true' form='postfix'>)</mo></mrow> <mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td></tr></table>
<!-- l. 1246 --><p class='indent'>   It is straightforward to verify that this is equal to: </p><table class='equation'><tr><td>
<!-- l. 1247 --><p class='indent'>
</p><!-- l. 1247 --><object id='x12-263011r82' data="svgs/T-real-encoding.svg" alt="diagram of T-real-encoding" class="svg-diagram"></object></td><td class='eq-no'>(10.82)</td></tr></table>
<!-- l. 1250 --><p class='indent'>   We can construct the CZ gate using
<!-- l. 1250 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math> and
<!-- l. 1250 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle class='text'><mtext>CNOT</mtext></mstyle></math> so
that we only additionally need the controlled-Hadamard gate.
</p>
   <div class='newtheorem'>
<!-- l. 1251 --><p class='noindent'><span class='head'>
<a id='x12-263012r11'></a>
<span class='cmbx-10x-x-109'>Proposition 10.7.11.</span>  </span>               The                  gate                  set
<!-- l. 1252 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>{</mo><mstyle class='text'><mtext>CNOT</mtext></mstyle><mo class='MathClass-punc' stretchy='false'>,</mo><mstyle class='text'><mtext>CH</mtext></mstyle><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>
is computationally universal.
                                                                     

                                                                     
</p>
   </div>
<!-- l. 1253 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 1255 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>We can use an ancilla in the <!-- l. 1255 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
state and a CH gate to create the Hadamard. Using Hadamard and <!-- l. 1255 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle class='text'><mtext>CNOT</mtext></mstyle></math>
we can construct the CZ gate. We can hence represent <!-- l. 1255 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>T</mi></mrow><mo accent='true'>~</mo></mover></math>,
<!-- l. 1255 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>H</mi></mrow><mo accent='true'>~</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>H</mi></mrow></math>
and <!-- l. 1255 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mstyle class='text'><mtext>CNOT</mtext></mstyle></mrow><mo accent='true'>~</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mstyle class='text'><mtext>CNOT</mtext></mstyle></mrow></math>.
Since <!-- l. 1255 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>{</mo><mi>T</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>H</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mstyle class='text'><mtext>CNOT</mtext></mstyle><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>
is approximately universal, this means that we can use the <!-- l. 1255 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>{</mo><mi>X</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mstyle class='text'><mtext>CNOT</mtext></mstyle><mo class='MathClass-punc' stretchy='false'>,</mo><mstyle class='text'><mtext>CH</mtext></mstyle><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>
gate set to arbitrarily closely simulate any unitary.                              □
</p>
   </div>
<!-- l. 1257 --><p class='indent'>   The controlled-Hadamard is a bit of an arbitrary choice of gate. It turns out
that the gate set of Hadamard and Toffoli is also computationally universal.
This is a very pleasing result, because the Toffoli gate is universal for
reversible classical computing, while the Hadamard gate is the single-qubit
Fourier transform. So this in a way shows that the extra power of
quantum computing comes from having access to this Fourier transform.
The way we prove its computational universality, is by showing that
Toffoli-Hadamard ‘simulates’ the CS-Hadamard gate set, which we know is
computationally universal by Proposition <a href='#x12-255011r1'>10.5.1<!-- tex4ht:ref: prop:CS-Had-universal  --></a>. The real-valued encoding
<!-- l. 1258 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mstyle class='text'><mtext>CS</mtext></mstyle></mrow><mo accent='true'>~</mo></mover></math> of the
CS gate is equivalent to a Toffoli up to some swaps. With the Hadamard we just
get <!-- l. 1258 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>H</mi></mrow><mo accent='true'>~</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>H</mi></mrow></math>.
Hence, when we encode the CS+Hadamard gate set, we get the Toffoli+Hadamard
gate set. We can hence do the following: starting with a Clifford+T computation,
we write it as an ensemble of CS+Hadamard circuits. We then encode
each of these circuits into a real-valued Toffoli+Hadamard circuit. By
doing this we can efficiently simulate the original Clifford+T circuit.
We see then that Toffoli+Hadamard circuits are also computationally
universal.
</p>
   <div class='newtheorem'>
<!-- l. 1260 --><p class='noindent'><span class='head'>
<a id='x12-263013r12'></a>
                                                                     

                                                                     
<span class='cmbx-10x-x-109'>Theorem 10.7.12.</span>  </span>The  Toffoli+Hadamard  gate  set  is  computationally
universal.
</p>
   </div>
<!-- l. 1262 --><p class='indent'>    So just using Hadamard gates and Toffoli gates we can simulate any
quantum computation to any desired precision. The computational universality
of real-valued quantum computing has an interesting philosophical consequence.
One could wonder why quantum mechanics uses complex numbers. Why not just
stick to regular old real numbers? The results of this section show that one
plausible answer is in any case <span class='cmti-10x-x-109'>not </span>a solution: we don’t need the complex
numbers to reach a certain computational complexity, as we could have done the
same with real numbers.
</p>
   <h3 class='sectionHead' id='references-and-further-reading8'><span class='titlemark'>10.8   </span> <a id='x12-26400010.8'></a>References and further reading</h3>
<!-- l. 1267 --><p class='noindent'><span class='paragraphHead' id='exact-cliffordt-synthesis'><a id='x12-265000'></a><span class='cmbx-10x-x-109'>Exact Clifford+T synthesis</span></span>
   That unitaries over the ring <!-- l. 1267 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔻</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>ω</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
can be exactly synthesised over the Clifford+T gate set was proved in [<a href='main_htmlli2.html#Xgiles2013exact'>107</a>]. The
presentation we use here was originally given in Seth Greylyn’s Master
thesis [<a href='main_htmlli2.html#XGreylyn2014Generators'>118</a>].
</p>
<!-- l. 1268 --><p class='noindent'><span class='paragraphHead' id='approximating-unitaries-with-cliffordt-gates'><a id='x12-266000'></a><span class='cmbx-10x-x-109'>Approximating unitaries with Clifford+T gates</span></span>
   The first paper to give an efficient algorithm for approximating single-qubit phase
gates with Clifford+T gates was given in [<a href='main_htmlli2.html#XSelingerEfficientApproximation'>207</a>], which found a T-count complexity of
<!-- l. 1268 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>4</mn><msub><mrow><mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-bin' stretchy='false'>∕</mo><mi>𝜖</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>. This was improved
to the optimal <!-- l. 1268 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>3</mn><msub><mrow><mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-bin' stretchy='false'>∕</mo><mi>𝜖</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
in [<a href='main_htmlli2.html#Xross2014optimal'>201</a>]. A good reference for reading about the improvements made to
approximate Clifford+T synthesis by incorporating ancillae, measurements and
classical control is [<a href='main_htmlli2.html#Xkliuchnikov2022shorter'>154</a>].
</p>
<!-- l. 1269 --><p class='noindent'><span class='paragraphHead' id='spider-nests'><a id='x12-267000'></a><span class='cmbx-10x-x-109'>Spider nests</span></span>
   That a 4-qubit phase gadget can be decomposed into the collection of all
phase gadgets with at most 3 legs first appeared in [<a href='main_htmlli2.html#XAmy2017Dihedral'>12</a>], which hence gives the
first appearance of a spider nest identity. The name ‘spider nest’ was coined
in [<a href='main_htmlli2.html#XdeBeaudrap2020Techniques'>75</a>] which also described the optimisation technique based on toggling gadgets
based on small spider nest identities. The notion of a strongly 3-even matrix was
                                                                     

                                                                     
introduced in [<a href='main_htmlli2.html#XPhysRevA.86.052329'>35</a>]. The relation between strongly 3-even matrices and
<!-- l. 1270 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>-count
optimisation seems to have been folklore for a number of years as the
strongly 3-even matrices were mostly used in the context of quantum
error correcting codes to understand when a code has a transversal
<!-- l. 1270 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gate (we will have a lot more to say about all that in the next chapter).
The relation between strongly 3-even matrices and spider-nest identities
was formally spelled out in [<a href='main_htmlli2.html#Xkissinger2024scalable'>149</a>]. In [<a href='main_htmlli2.html#Xamy2016t'>16</a>] it was shown that phase
gadgets with dyadic angles are the only gadgets that allow non-trivial
identities. If we for instance have gadgets with phases that are multiples of
<!-- l. 1271 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>3</mn></mrow></mfrac> </mrow></math>, then
the only way they can cancel out is if they do so in the trivial way where the
gadgets fuse together. See also [<a href='main_htmlli2.html#Xvandewetering2024optimal'>224</a>] where they show that in certain settings the
only optimisation we can do to ‘black-box’ non-Clifford phases is to fuse
them.
</p>
<!-- l. 1272 --><p class='noindent'><span class='paragraphHead' id='tcount-optimisation'><a id='x12-268000'></a><span class='cmbx-10x-x-109'>T-count optimisation</span></span>
   The idea to use small spider nests to optimise
<!-- l. 1273 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>-count
was introduced in [<a href='main_htmlli2.html#XdeBeaudrap2020Techniques'>75</a>] and later improved upon in followup work by the same
authors [<a href='main_htmlli2.html#XdeBeaudrapN2020treducspidernest'>74</a>]. The relationship between T-count optimisation and Reed-Muller
codes was established in [<a href='main_htmlli2.html#Xamy2016t'>16</a>] and the relation to symmetric 3-tensor factorisation
in [<a href='main_htmlli2.html#Xheyfron2018efficient'>126</a>]. It is the representation as a symmetric 3-tensor that is currently the
leading approach in T-count optimisation, with the current best methods
being [<a href='main_htmlli2.html#Xruiz2024quantum'>202</a>, <a href='main_htmlli2.html#Xvandaele2024lower'>228</a>]. The NP-hardness of T-count optimisation was established
in [<a href='main_htmlli2.html#Xwetering2024Tcount'>223</a>].
</p>
<!-- l. 1276 --><p class='noindent'><span class='paragraphHead' id='scalable-zx'><a id='x12-269000'></a><span class='cmbx-10x-x-109'>Scalable ZX</span></span>
   The scalable ZX-calculus was formally introduced in [<a href='main_htmlli2.html#XSZXCalculus'>49</a>], though many of the
new features appeared in an informal way in an earlier preprint [<a href='main_htmlli2.html#Xchancellor2016coherent'>51</a>]. The
CNOT+<!-- l. 1276 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
completeness in scalable ZX of the Clifford rules plus the (S4) rule
appeared in [<a href='main_htmlli2.html#Xkissinger2024scalable'>149</a>]. Note that Clifford+(S4) is not complete for the
full fragment of ZX-diagrams where the phases are multiples of
<!-- l. 1276 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>. This
is because (S4) preserves the same invariant that was used in [<a href='main_htmlli2.html#Xsupplementarity'>191</a>] to
argue that the Clifford rules are incomplete for the universal fragment
of ZX-diagrams. In [<a href='main_htmlli2.html#XSimonCompleteness'>136</a>] a complete rule set for ZX-diagrams with
<!-- l. 1276 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>
phases was given.
                                                                     

                                                                     
</p>
<!-- l. 1277 --><p class='noindent'><span class='paragraphHead' id='catalysis1'><a id='x12-270000'></a><span class='cmbx-10x-x-109'>Catalysis</span></span>
   The CCZ to 2 <!-- l. 1277 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
catalysis was first described in [<a href='main_htmlli2.html#XGidney2019efficientmagicstate'>105</a>], while the
<!-- l. 1277 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>-CS
catalysis seems to be more of a folklore result. The idea of using catalysis to
relate different gate sets was introduced in [<a href='main_htmlli2.html#Xamy2023catalytic'>13</a>]. The synthesis of small phase
gates using an adder and measurement-based uncomputation was described
in [<a href='main_htmlli2.html#XGidney2018halvingcostof'>103</a>]. The relation between catalysis, computational universality and
completeness was studied by the authors of this book in [<a href='main_htmlli2.html#Xkissinger2024catalysing'>144</a>]. This paper serves
as the basis for Section <a href='#catalysis'>10.5<!-- tex4ht:ref: sec:catalysis  --></a>.
</p>
<!-- l. 1278 --><p class='noindent'><span class='paragraphHead' id='toffolihadamard-universality'><a id='x12-271000'></a><span class='cmbx-10x-x-109'>Toffoli-Hadamard universality</span></span>
   The original proof that Toffoli+Hadamard is computational universal is given
in [<a href='main_htmlli2.html#XShiToffoliHadamard'>208</a>] (this also seems to be the paper that coined the term ‘computational
universality’). This actually shows this property for a wider set of gates. Namely,
if you have a Toffoli gate and any non-computational-basis-preserving gate, then
this will lie dense in the group of special orthogonal matrices. A simpler proof of
Toffoli+H universality, which is what we use, is given in [<a href='main_htmlli2.html#Xaharonov2003simple'>4</a>], which also used the
term ‘computational universality’. They show this easily by establishing that the
gate set consisting of the controlled-S gate and the Hadamard gate maps to the
Toffoli+Hadamard gate set. The approximate universality of the CS+H gate set
was shown in [<a href='main_htmlli2.html#Xkitaev1997quantum'>152</a>, Lemma 4.6 on p. 1213]. Kitaev proves this using a
‘geometric lemma’ that adding a gate to a set of gates that stabilises a
given state creates a larger-dimensional space of gates. This proof is not
constructive. He then proves his Solovay-Kitaev algorithm to show how
you would do it constructively (that proof only requires that the set
of gates does in fact lie dense in the group). Note that what he calls
<!-- l. 1280 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math> is the Hadamard
gate, and <!-- l. 1280 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>K</mi></math>
is the <!-- l. 1280 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
gate. In this book we instead show that CS+H is ‘just’ computationally
universal, as this follows much more directly using catalysis. This proof originally
appeared in [<a href='main_htmlli2.html#Xkissinger2024catalysing'>144</a>].    </p><!-- l. 7 --><div class='crosslinks'><p class='noindent'>[<a href='main_htmlch11.html'>next</a>] [<a href='main_htmlch9.html'>prev</a>] [<a href='main_htmlch9.html#tailmain_htmlch9.html'>prev-tail</a>] [<a href='main_htmlch10.html'>front</a>] [<a href='main_html.html#main_htmlch10.html'>up</a>] </p></div>
<!-- l. 7 --><p class='indent'>   <a id='tailmain_htmlch10.html'></a></p> 
<script type="text/javascript" src="proof_collapse.js"></script> 
<script type="text/javascript" src="navigation_menu.js"></script> </body> 
</html>