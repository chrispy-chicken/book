<!DOCTYPE html> 
<html lang='en-US' xml:lang='en-US'> 
<head><title>9 Controlled gates and classical oracles</title> 
<meta charset='utf-8' /> 
<meta content='TeX4ht (https://tug.org/tex4ht/)' name='generator' /> 
<meta content='width=device-width,initial-scale=1' name='viewport' /> 
<link href='main_html.css' rel='stylesheet' type='text/css' /> 
<meta content='main_html.tex' name='src' /> 
 <script async='async' id='MathJax-script' src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/mml-chtml.js' type='text/javascript'></script>  
</head><body>
   <!-- l. 7 --><div class='crosslinks'><p class='noindent'>[<a href='main_htmlch10.html'>next</a>] [<a href='main_htmlch8.html'>prev</a>] [<a href='main_htmlch8.html#tailmain_htmlch8.html'>prev-tail</a>] [<a href='#tailmain_htmlch9.html'>tail</a>] [<a href='main_html.html#main_htmlch9.html'>up</a>] </p></div>
   <h2 class='chapterHead' id='controlled-gates-and-classical-oracles'><span class='titlemark'>Chapter 9</span><br /><a id='x11-2150009'></a>Controlled gates and classical oracles</h2>
<!-- l. 8 --><p class='noindent'>In Chapter <a href='main_htmlch7.html#universal-circuits'>7<!-- tex4ht:ref: ch:universal  --></a> we looked at universal quantum circuits built from low-level gates:
CNOTs, phase gates, and Hadamards. These are the types of gates you might be
able to implement on the hardware level of a quantum computer. However, many
useful quantum algorithms will contain higher-level primitives: classical oracles,
controlled unitaries, adders, etc. In this chapter we will see how we can
translate these higher-level constructions into the lower-level ones, and
how we can reason with the higher-level constructions directly. To do
this we will introduce a new derived generator for ZX-diagrams: the
<span class='cmbx-10x-x-109'>H-box</span>. This is a spider-like contraption that allows us to easily represent
AND-like gates, just like how the X-spider allows us to represent XOR-like
gates.
</p>
   <h3 class='sectionHead' id='controlled-unitaries1'><span class='titlemark'>9.1   </span> <a id='x11-2160009.1'></a>Controlled unitaries</h3>
<!-- l. 11 --><p class='noindent'>Let’s take a look first at controlled unitaries. First, what is a controlled unitary? Given
some <!-- l. 12 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit
unitary <!-- l. 12 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>, the
<!-- l. 12 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>-controlled
<!-- l. 12 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math> is an
<!-- l. 12 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>k</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>-qubit unitary that
applies <!-- l. 12 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math> to the
bottom <!-- l. 12 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math> qubits if
and only if the top <!-- l. 12 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
qubits are all in the <!-- l. 12 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
state. In terms of quantum circuit notation we write the following: </p><table class='equation'><tr><td>
<!-- l. 13 --><p class='indent'>
</p><!-- l. 13 --><object id='x11-216001r1' data="svgs/many-controlled-unitary.svg" alt="diagram of many-controlled-unitary" class="svg-diagram"></object></td><td class='eq-no'>(9.1)</td></tr></table>
<!-- l. 16 --><p class='indent'>   We refer to the top <!-- l. 16 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
qubits here as the ‘control wires’, with the bottom
<!-- l. 16 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
                                                                     

                                                                     
qubits being the ‘target wires’. We use quantum circuit notation here, instead of
ZX-diagrams, because there is no easy way to represent controlled unitaries in
ZX. We’ll see later in this chapter how to remedy this.
</p>
   <div class='newtheorem'>
<!-- l. 18 --><p class='noindent'><span class='head'>
<a id='x11-216002r1'></a>
<span class='cmbx-10x-x-109'>Example 9.1.1.</span>  </span>We   have   already   encountered   a   couple   of   simple
examples   of   controlled   unitaries:   the   CNOT   and   CZ   gates.   In
the   CNOT   gate   we   have   added   one   control   to   the   single-qubit
<!-- l. 19 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>
gate, while for the CZ gate we have added one control to the single-qubit
<!-- l. 19 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math>
gate.
</p>
   </div>
<!-- l. 20 --><p class='indent'>    When dealing with controlled unitaries, we will often talk about the unitary ‘firing’
or ‘not firing’. By this we mean whether the qubits on the control wires are in the state
that makes <!-- l. 21 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
get applied on the target wires, or whether the identity happens instead. For
instance, in the CNOT gate, the NOT gate fires when the top qubit is in the
<!-- l. 21 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> state.
When analysing the logic of a circuit containing controlled gates, we can often
reduce the analysis to a case distinction where we consider the situation where
the gate fires, and where it does not fire (see the next proposition for an example
of this). As an example of this kind of logic, let’s prove the following
proposition.
</p>
   <div class='newtheorem'>
<!-- l. 24 --><p class='noindent'><span class='head'>
<a id='x11-216003r2'></a>
<span class='cmbx-10x-x-109'>Proposition 9.1.2.</span>  </span> Let <!-- l. 25 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
and <!-- l. 25 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> </mrow></math> be
<!-- l. 25 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit unitaries. Then
conjugating the controlled <!-- l. 25 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
gate by <!-- l. 25 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> </mrow></math> is the same
thing as controlling the <!-- l. 25 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> <mi>U</mi><msup><mrow><mi>V</mi> </mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup></mrow></math>
gate: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 26 --><object data="svgs/many-controlled-unitary-conjugation.svg" alt="diagram of many-controlled-unitary-conjugation" class="svg-diagram"></object></td></tr></table>
   </div>
<!-- l. 29 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 31 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>Note  that  the  controlled  unitary  on  the  left-hand  side  fires  iff
that on the right-hand side fires. Let’s check the two cases of firing and
not  firing  to  see  that  they  agree  on  both  cases.  If  the  gate  does  not
fire,  then  the  right-hand  side  is  the  identity.  On  the  left-hand  side,  if
<!-- l. 33 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
doesn’t                         fire,                         then                         the
<!-- l. 33 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>V</mi> </mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup></math>
and
<!-- l. 33 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> </mrow></math>
cancel                   so                   that                   it                   also
gives the identity. If instead the gates do fire then both sides implement the
<!-- l. 34 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> <mi>U</mi><msup><mrow><mi>V</mi> </mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup></mrow></math>
gate on the bottom qubits.                                                              □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 36 --><p class='noindent'><span class='head'>
<a id='x11-216004r3'></a>
<span class='cmbx-10x-x-109'>Example 9.1.3.</span>  </span>We  have  seen  that  we  can  construct  the  CZ  gate  by
conjugating the bottom qubit of a CNOT by Hadamards. This works because
<!-- l. 37 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>HXH</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi mathvariant='italic'>HX</mi><msup><mrow><mi>H</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>Z</mi></mrow></math>
so that the previous proposition applies.
                                                                     

                                                                     
</p>
   </div>
<!-- l. 38 --><p class='indent'>
</p>
   <h4 class='subsectionHead' id='the-toffoli-gate'><span class='titlemark'>9.1.1   </span> <a id='x11-2170009.1.1'></a>The Toffoli gate</h4>
<!-- l. 40 --><p class='noindent'>A controlled unitary of particular importance is the <span class='cmti-10x-x-109'>Toffoli </span>gate. This
is the controlled CNOT gate, or equivalently, the two-qubit-controlled
<!-- l. 40 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>
gate.
</p>
   <div class='newtheorem'>
<!-- l. 41 --><p class='noindent'><span class='head'>
<a id='x11-217001r4'></a>
<span class='cmbx-10x-x-109'>Definition 9.1.4.</span>  </span>The <span class='cmbx-10x-x-109'>Toffoli gate </span>is the three-qubit unitary defined by
<!-- l. 42 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>x</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>z</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>↦</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mi>x</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>y</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>z</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
That is, it XORs the value of the third qubit with the AND of the first
two qubits. In quantum circuit notation we write the Toffoli gate as:
</p><table class='equation-star'><tr><td>
<!-- l. 43 --><object data="svgs/TOF-circ.svg" alt="diagram of TOF-circ" class="svg-diagram"></object></td></tr></table>
   </div>
<!-- l. 46 --><p class='indent'>    The Toffoli gate is important for a number of reasons. First, it is <span class='cmti-10x-x-109'>universal
for classical reversible logic</span>. Let’s unpack that statement a bit. What do
we mean by classical reversible logic? A classical function is any map
<!-- l. 49 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi> <mo class='MathClass-punc' stretchy='false'>:</mo> <mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>→</mo> <mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></math>.
Such a map only corresponds to a unitary via
<!-- l. 49 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>U</mi></mrow><mrow><mi>f</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> iff
<!-- l. 49 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math> is a
bijection, and hence has an inverse. When a classical function has an inverse, we
                                                                     

                                                                     
say it is <span class='cmbx-10x-x-109'>reversible</span>. As it turns out, any classical reversible function can be
decomposed into a sequence of <span class='cmti-10x-x-109'>generalised </span>Toffoli gates. These are the
<!-- l. 49 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit
generalisations of the Toffoli gate that control a NOT gate on
<!-- l. 49 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math> wires
(hence, the NOT and CNOT gates also count as such generalised Toffoli
gates). As we will see later, if we allow for clean ancillae initialised in the
<!-- l. 50 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math> state that also have to
be brought back to the <!-- l. 50 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math>
state at the end of the circuit, then we can implement any reversible function
using just (the three-bit) Toffoli and the NOT gate. It is in this sense
that the Toffoli gate is universal for classical reversible logic. Second,
the Toffoli gate is essentially the ‘quantum AND gate’: if we input a
<!-- l. 51 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
on the input of the target, and post-select the controls to
<!-- l. 51 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext class='MathClass-rel' stretchy='false'>|+⟩</mtext></mrow></math> we
can easily verify that: </p><table class='equation-star'><tr><td>
<!-- l. 52 --><object data="svgs/TOF-makes-AND.svg" alt="diagram of TOF-makes-AND" class="svg-diagram"></object></td></tr></table>
<!-- l. 55 --><p class='indent'>   Since we also have a NOT gate, we can combine these two gates to perform
arbitrary classical logic in a quantum circuit (although because the above
construction uses post-selection, we will have to be a bit smarter about this).
Third, which is related to the previous point, we can use Toffoli gates to add
control wires to other unitaries: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 57 --><object data="svgs/TOF-add-controls-U.svg" alt="diagram of TOF-add-controls-U" class="svg-diagram"></object></td></tr></table>
<!-- l. 60 --><p class='indent'>   If it is not clear why this works, don’t worry, we will analyse constructions
like this in more detail in Section <a href='#adding-controls-to-other-quantum-gates'>9.4.2<!-- tex4ht:ref: sec:control-other-gate  --></a>. The point we want to make here is that
Toffoli gates are very useful, and that it is worthwhile understanding how to
construct them.
</p>
   <h4 class='subsectionHead' id='diagonal-controlled-gates-and-phase-polynomials'><span class='titlemark'>9.1.2   </span> <a id='x11-2180009.1.2'></a>Diagonal controlled gates and phase polynomials</h4>
<!-- l. 62 --><p class='noindent'>Before we will look at how to construct Toffoli gates, it will first
be helpful to take a bit of a detour. As the Toffoli is just an
<!-- l. 62 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math> gate
with two controls, we can conjugate its target qubit by Hadamards to reduce this to
a <!-- l. 62 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math> gate
with two controls; see Proposition <a href='#x11-216003r2'>9.1.2<!-- tex4ht:ref: prop:controlled-unitary-conjugation  --></a>. The resulting <span class='cmbx-10x-x-109'>CCZ gate </span>is a diagonal
unitary, which makes it easier to think about in some ways. In this section we
will see how we can construct the CCZ gate, and related unitaries, using phase
gadgets. But first, let’s start by looking at a simpler gate: the CZ. This gate applies
a <!-- l. 64 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math>
gate—i.e. <!-- l. 64 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>y</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi>y</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>y</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>—to
the second qubit, if the first qubit is in the
<!-- l. 64 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> state, and
applies the identity otherwise. It turns out we can efficiently write down this operation
as <!-- l. 64 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext>CZ</mtext></mstyle><mo class='MathClass-rel' stretchy='false'>|</mo><mi>x</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi>x</mi><mo class='MathClass-bin' stretchy='false'>⋅</mo><mi>y</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>x</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
(convince yourself of this by plugging in different values of
<!-- l. 64 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo><mo class='MathClass-open' stretchy='false'>{</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>).
Interestingly, <!-- l. 64 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi>x</mi><mo class='MathClass-bin' stretchy='false'>⋅</mo><mi>y</mi></mrow></msup></math>
is not the only way in which we can represent the phase function of CZ. We’ve
seen two ways to write down a CZ gate as a ZX-diagram: </p><table class='equation'><tr><td>
<!-- l. 66 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 66 --><object id='x11-218001r2' data="svgs/CZ-2.svg" alt="diagram of CZ-2" class="svg-diagram"></object></td><td class='eq-no'>(9.2)</td></tr></table>
<!-- l. 69 --><p class='indent'>   We recognise the right-hand side as a circuit consisting of two phase gates and
one two-qubit phase gadget. We can hence represent the action of this circuit as
<!-- l. 69 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>x</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>↦</mo><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> <mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mi>y</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mi>x</mi><mo class='MathClass-bin' stretchy='false'>⊕</mo><mi>y</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>x</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>. As we
already saw in Section <a href='main_htmlch7.html#universal-circuits-with-path-sums'>7.1.3<!-- tex4ht:ref: sec:path-sum-univ  --></a>, the reason these two diagrams, corresponding to the
expressions <!-- l. 70 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi>x</mi><mo class='MathClass-bin' stretchy='false'>⋅</mo><mi>y</mi></mrow></msup></math>
and <!-- l. 70 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> <mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mi>y</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mi>x</mi><mo class='MathClass-bin' stretchy='false'>⊕</mo><mi>y</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup></math>
are equal is because we have: </p><table class='equation'><tr><td>
<!-- l. 71 --><p class='indent'>
</p><!-- l. 71 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                 <mstyle class='label' id='x11-218002r3'></mstyle><!-- endlabel --><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>y</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>y</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>y</mi><mo class='MathClass-close' stretchy='false'>)</mo><mspace class='qquad' width='2em'></mspace><mi class='MathClass-op'>∀</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo><mi>x</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo><mo class='MathClass-open' stretchy='false'>{</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>}</mo><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td><td class='eq-no'>(9.3)</td></tr></table>
<!-- l. 74 --><p class='indent'>   This formula allows us to construct other diagonal controlled
gates. For instance, if we want to construct the controlled
<!-- l. 74 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
gate, we first realise that this gate has a phase function of
<!-- l. 74 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iα</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-bin' stretchy='false'>⋅</mo><mi>y</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup></math>, which we can transform
using Eq. (<a href='#x11-218002r3'>9.3<!-- tex4ht:ref: eq:Boolean-identity-reverse  --></a>) to <!-- l. 74 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>α</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> <mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mi>y</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mi>x</mi><mo class='MathClass-bin' stretchy='false'>⊕</mo><mi>y</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup></math>.
Then we can simply write this as a phase polynomial circuit: </p><table class='equation'><tr><td>
<!-- l. 75 --><p class='indent'>
</p><!-- l. 75 --><object id='x11-218003r4' data="svgs/eq-cz-alpha-decomposed.svg" alt="diagram of eq:cz-alpha-decomposed" class="svg-diagram"></object></td><td class='eq-no'>(9.4)</td></tr></table>
                                                                     

                                                                     
<!-- l. 78 --><p class='indent'>   But what if we want to construct multiply-controlled gates?
For the CCZ gate, the controlled CZ gate, the phase function is
<!-- l. 78 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iπ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-bin' stretchy='false'>⋅</mo><mi>y</mi><mo class='MathClass-bin' stretchy='false'>⋅</mo><mi>z</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup></math>, so we need some
way to decompose <!-- l. 78 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>y</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>z</mi></mrow></math>
into a phase polynomial. We can do this by generalising Eq. (<a href='#x11-218002r3'>9.3<!-- tex4ht:ref: eq:Boolean-identity-reverse  --></a>) to more bits:
</p><table class='equation'><tr><td>
<!-- l. 80 --><p class='indent'>
</p><!-- l. 80 --><object id='x11-218004r5' data="svgs/eq-mult-xor-3.svg" alt="diagram of eq:mult-xor-3" class="svg-diagram"></object></td><td class='eq-no'>(9.5)</td></tr></table>
<!-- l. 83 --><p class='indent'>   So the phase polynomial of the CCZ gate is
<!-- l. 83 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> <mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mi>y</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mi>z</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mi>x</mi><mo class='MathClass-bin' stretchy='false'>⊕</mo><mi>y</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mi>x</mi><mo class='MathClass-bin' stretchy='false'>⊕</mo><mi>z</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mi>y</mi><mo class='MathClass-bin' stretchy='false'>⊕</mo><mi>z</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mi>x</mi><mo class='MathClass-bin' stretchy='false'>⊕</mo><mi>y</mi><mo class='MathClass-bin' stretchy='false'>⊕</mo><mi>z</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup></math>. We
can hence represent it using the following ZX-diagram: </p><table class='equation'><tr><td>
<!-- l. 85 --><p class='indent'>
</p><!-- l. 85 --><object id='x11-218005r6' data="svgs/eq-CCZ-decomposed.svg" alt="diagram of eq:CCZ-decomposed" class="svg-diagram"></object></td><td class='eq-no'>(9.6)</td></tr></table>
<!-- l. 88 --><p class='indent'>   We can generalise Eq. (<a href='#x11-218004r5'>9.5<!-- tex4ht:ref: eq:mult-xor-3  --></a>) to work for any number of
<!-- l. 88 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
bits. This will result in an expression with
<!-- l. 88 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>k</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math> XOR terms and a constant
of <!-- l. 88 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>1</mn><mo class='MathClass-bin' stretchy='false'>∕</mo><msup><mrow><mn>2</mn></mrow><mrow><mi>k</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup></mrow></math>. Hence, the phase
polynomial of an <!-- l. 89 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-controlled
<!-- l. 89 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> gate consists of
<!-- l. 89 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math> phase gadgets
with a phase of <!-- l. 89 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>±</mo> <mi>α</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup></mrow></math>.
On the one hand this is great, as it means we can represent arbitrary controlled
phase gates using a phase polynomial circuit. On the other hand, we need
                                                                     

                                                                     
exponentially many exponentially small phase gates if the number of controls is
high. Luckily there are ways around this exponential cost, as we will explore in
this chapter. For now though, let’s see how we can use these multiply-controlled
phase gates to construct arbitrary diagonal unitaries. Note that the matrix of an
<!-- l. 93 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>-controlled
<!-- l. 93 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> gate
is <!-- l. 93 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext>diag</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iα</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
This matrix is diagonal, and it only applies an
<!-- l. 94 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iα</mi></mrow></msup></math> phase if the input is in the
<!-- l. 94 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> state, and applies a trivial
phase of <!-- l. 94 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math> otherwise. So the
matrix consists of all <!-- l. 94 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>’s on
the diagonal except for an <!-- l. 94 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iα</mi></mrow></msup></math>
in the bottom corner. The reason it appears in the bottom
corner is because we are controlling the phase on the
all-<!-- l. 94 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>
state. By conjugating some of the qubits with a NOT gate we can instead make
it controlled on some other specific bit-string. This moves the position of the
<!-- l. 94 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iα</mi></mrow></msup></math> on the diagonal.
For instance, for a <!-- l. 95 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>CZ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
gate, the matrix is <!-- l. 95 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext>diag</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iα</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
If we conjugate the second qubit by NOT gates, the
<!-- l. 95 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iα</mi></mrow></msup></math> fires on the
<!-- l. 95 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>10</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> state instead, and
the matrix looks like <!-- l. 95 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext>diag</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iα</mi></mrow></msup><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
Another way of saying this, is that an
<!-- l. 96 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-controlled
<!-- l. 96 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> gate
on an <!-- l. 96 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn></mrow></math>
qubit circuit which is conjugated by NOT gates implements a ‘Dirac delta’ diagonal
unitary <!-- l. 96 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>U</mi></mrow><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iα</mi><msub><mrow><mi>δ</mi></mrow><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
Here <!-- l. 96 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>δ</mi></mrow><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>
iff <!-- l. 96 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></mrow></math> and is
<!-- l. 96 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math> otherwise.
But we can write an arbitrary phase function in terms of these delta functions! Let
<!-- l. 98 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi> <mo class='MathClass-punc' stretchy='false'>:</mo> <mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>→</mo> <mi>ℝ</mi></mrow></math> be some phase function.
The delta functions <!-- l. 98 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>δ</mi></mrow><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo> <mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>→</mo> <mi>ℝ</mi></mrow></math>
form a basis for the space of phase functions, and hence we can write
<!-- l. 98 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi> <mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow> <mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>∈</mo><mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></msub><msub><mrow><mi>α</mi></mrow><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub><msub><mrow><mi>δ</mi></mrow><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub></mrow></math>. Hence, to implement
the diagonal unitary <!-- l. 99 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>U</mi></mrow><mrow><mi>f</mi></mrow></msub></math>
that acts as <!-- l. 99 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>U</mi></mrow><mrow><mi>f</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>if</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>,
we can multiply together unitaries implementing the delta phase functions
<!-- l. 99 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>α</mi></mrow><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub><msub><mrow><mi>δ</mi></mrow><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub></mrow></math>.
This means we can implement an arbitrary
                                                                     

                                                                     
<!-- l. 99 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit diagonal
unitary using <!-- l. 99 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></math>
<!-- l. 99 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>-controlled
phase gates.
</p>
   <div class='newtheorem'>
<!-- l. 100 --><p class='noindent'><span class='head'>
<a id='x11-218006r5'></a>
<span class='cmbx-10x-x-109'>Proposition 9.1.5.</span>  </span>Any <!-- l. 101 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit
diagonal unitary can be constructed using <!-- l. 101 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
<!-- l. 101 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>-controlled
phase gates and NOT gates.
</p>
   </div>
<!-- l. 102 --><p class='indent'>    Each of the controlled-phase gates can be decomposed into
<!-- l. 103 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
phase gadgets. The NOT gates conjugating some of the qubits of these
controlled-phase gates can then be absorbed into the phase gadgets, so that any
circuit of such NOT-conjugated controlled-phase gates can be reduced to
a circuit of just phase gadgets. While we are decomposing each of the
<!-- l. 103 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> controlled-phase
gates into <!-- l. 103 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> phase
gates, the phase gates acting on the same qubits combine, so that in the end the circuit only
requires <!-- l. 103 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> of
them (and not <!-- l. 103 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>).
</p>
   <div class='newtheorem'>
<!-- l. 104 --><p class='noindent'><span class='head'>
<a id='x11-218007r6'></a>
<span class='cmbx-10x-x-109'>Proposition 9.1.6.</span>  </span>Any <!-- l. 105 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit
diagonal unitary can be constructed using <!-- l. 105 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
phase gadgets.
</p>
   </div>
<!-- l. 106 --><p class='indent'>    As the group of diagonal unitaries has
<!-- l. 107 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
degrees of freedom, this construction is essentially optimal.
                                                                     

                                                                     
</p>
   <h4 class='subsectionHead' id='fourier-transforming-diagonal-unitaries'><span class='titlemark'>9.1.3   </span> <a id='x11-2190009.1.3'></a>Fourier transforming diagonal unitaries</h4>
<!-- l. 109 --><p class='noindent'>In the previous section we converted controlled phase gates to phase gadgets,
but this translation goes both ways. In fact, the relationship between
these two types of phase gates is closely related to the <span class='cmbx-10x-x-109'>pseudo-Boolean
Fourier transform</span>. A <span class='cmbx-10x-x-109'>pseudo-Boolean function </span>is any function
<!-- l. 110 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi> <mo class='MathClass-punc' stretchy='false'>:</mo> <mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>→</mo> <mi>ℝ</mi></mrow></math>, where
<!-- l. 110 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝔽</mi><mn>2</mn> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>{</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math> is the
Booleans. We can decompose a pseudo-Boolean function into primitive terms in a
number of ways. We already saw that we can write it in terms of delta functions,
which we can treat as a set of ‘maximally controlled’ expressions. These delta
functions could be translated into XOR terms, and hence that gives us a different
decomposition: </p><table class='equation'><tr><td>
<!-- l. 111 --><p class='indent'>
</p><!-- l. 111 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                     <mstyle class='label' id='x11-219001r7'></mstyle><!-- endlabel --><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo><munder class='msub'><mrow><mo> ∑</mo>
   </mrow><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>∈</mo><mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></munder><msub><mrow><mi>λ</mi></mrow><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-bin' stretchy='false'>⋅</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td><td class='eq-no'>(9.7)</td></tr></table>
<!-- l. 114 --><p class='indent'>   Here the <!-- l. 114 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>λ</mi></mrow><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub></math> are real
coefficients that determine <!-- l. 114 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math>
and <!-- l. 114 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mo class='MathClass-bin' stretchy='false'>⋅</mo></math>
is the dot product of bit strings, which for a fixed
<!-- l. 114 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></math> represents an
XOR of bits of <!-- l. 114 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></math>.
For instance, if <!-- l. 114 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>101</mn></mrow></math>,
then <!-- l. 114 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-bin' stretchy='false'>⋅</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub></mrow></math>.
Note that in Eq. (<a href='#x11-219001r7'>9.7<!-- tex4ht:ref: eq:pseudo-Bool-XOR  --></a>) we are treating the Booleans
<!-- l. 114 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math> and
<!-- l. 114 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math>
both as Booleans and as real numbers. This decomposition contains
<!-- l. 115 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></math> independent
parameters <!-- l. 115 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>λ</mi></mrow><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub></math>.
As <!-- l. 115 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math>
has <!-- l. 115 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></math>
possible inputs, we see that each pseudo-Boolean function can indeed uniquely be
written in this way. The phase polynomials of Chapter <a href='main_htmlch7.html#universal-circuits'>7<!-- tex4ht:ref: ch:universal  --></a> are examples
                                                                     

                                                                     
of pseudo-Boolean functions written as XOR terms. Instead of using
XOR as the primitive function to decompose it to, we can also use AND:
</p><table class='equation-star'><tr><td>
<!-- l. 117 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                    <mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo><munder class='msub'><mrow><mo> ∑</mo>
   </mrow><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>∈</mo><mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></munder><msub><mrow><mover accent='true'><mrow><mi>λ</mi></mrow><mo accent='true'>^</mo></mover></mrow><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub><mo> ∏</mo><msup><mrow>
  <mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow></msup><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td></tr></table>
<!-- l. 118 --><p class='indent'>   Here <!-- l. 118 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow></msup></math> is
the bit string <!-- l. 118 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow><mrow><msub><mrow><mi>y</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></msubsup><msubsup><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow><mrow><msub><mrow><mi>y</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></msubsup><mo class='MathClass-rel' stretchy='false'>⋯</mo><msubsup><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow><mrow><msub><mrow><mi>y</mi></mrow><mrow><mi>n</mi></mrow></msub></mrow></msubsup></mrow></math>
where we set <!-- l. 118 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mn>0</mn></mrow><mrow><mn>0</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>
and <!-- l. 118 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mn>1</mn></mrow><mrow><mn>0</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>. Hence,
if <!-- l. 118 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>101</mn></mrow></math> then
<!-- l. 118 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mn>1</mn><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub></mrow></math>, so that
<!-- l. 118 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi class='MathClass-op'>∏</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --><msup><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>∧</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub></mrow></math>. Again, as
there are <!-- l. 118 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></math>
independent terms in this decomposition, any pseudo-Boolean function can be
written in this way. The transformation of a pseudo-Boolean function
written as sums of XOR terms to one written as sums of AND terms
and back is what we call the <span class='cmbx-10x-x-109'>Fourier transform </span>of such a function.
This Fourier transform essentially boils down to Eq. (<a href='#x11-218004r5'>9.5<!-- tex4ht:ref: eq:mult-xor-3  --></a>) and its
<!-- l. 120 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-bit
generalisation. In particular, to transform back from XOR to AND, we use its
‘inverse’:
</p><!-- tex4ht:inline --><!-- l. 126 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mtable class='align-star' columnalign='left' displaystyle='true'>
 <mtr><mtd class='align-odd' columnalign='right'><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>y</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>z</mi></mtd> <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>z</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>y</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>z</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>2</mn><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>y</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>z</mi><mspace width='2em'></mspace></mtd>                              <mtd class='align-label' columnalign='right'></mtd> <mtd class='align-label'>
 <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>           <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>x</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>z</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>2</mn><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>z</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>y</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>z</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>2</mn><mo class='MathClass-open' stretchy='false'>(</mo><mi>y</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>z</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>2</mn><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>y</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>z</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>4</mn><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>y</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>z</mi><mo class='MathClass-close' stretchy='false'>)</mo><mspace width='2em'></mspace></mtd> <mtd class='align-label' columnalign='right'></mtd> <mtd class='align-label'>
 <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>           <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>x</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>y</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>z</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>2</mn><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>y</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>z</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>y</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>z</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>4</mn><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>y</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>z</mi><mo class='MathClass-close' stretchy='false'>)</mo><mspace width='2em'></mspace></mtd>             <mtd class='align-label' columnalign='right'></mtd> <mtd class='align-label'>
   <mspace width='2em'></mspace></mtd></mtr></mtable></math>
                                                                     

                                                                     
<!-- l. 127 --><p class='noindent'>By using this translation we can hence also write an arbitrary diagonal unitary
as a circuit of controlled-phase gates where now we do not need any
NOT gates and we use controlled gates acting on different numbers of
qubits.
</p>
   <h3 class='sectionHead' id='hboxes'><span class='titlemark'>9.2   </span> <a id='x11-2200009.2'></a>H-boxes</h3>
<!-- l. 129 --><p class='noindent'>The representation we found of the CCZ gate in Eq. (<a href='#x11-218005r6'>9.6<!-- tex4ht:ref: eq:CCZ-decomposed  --></a>) looks a bit
messy. The reason for this is that we had to translate the phase function
<!-- l. 129 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi>x</mi><mo class='MathClass-bin' stretchy='false'>⋅</mo><mi>y</mi><mo class='MathClass-bin' stretchy='false'>⋅</mo><mi>z</mi></mrow></msup></math> into
a sum of XOR phase functions. This is because the Z- and X-spiders <span class='cmti-10x-x-109'>can </span>directly
represent these XOR phases, while they <span class='cmti-10x-x-109'>cannot </span>directly represent these
‘multiplicative’ phases. We can solve this issue by introducing a new generator
for ZX-diagrams: <span class='cmbx-10x-x-109'>H-boxes</span>. We define H-boxes as follows (why we call these
things H-boxes will become clear soon enough): </p><table class='equation'><tr><td>
<!-- l. 132 --><p class='indent'>
</p><!-- l. 132 --><object id='x11-220001r8' data="svgs/eq-H-spider-def.svg" alt="diagram of eq:H-spider-def" class="svg-diagram"></object></td><td class='eq-no'>(9.8)</td></tr></table>
<!-- l. 135 --><p class='indent'>   The sum in this equation is over all
<!-- l. 135 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>i</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>i</mi></mrow><mrow><mi>m</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>j</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>j</mi></mrow><mrow><mi>n</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>∈</mo><mo class='MathClass-open' stretchy='false'>{</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math> and
<!-- l. 135 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>a</mi></math> is an
arbitrary complex number. Hence, an H-box represents a matrix with, up to a global
factor of <!-- l. 135 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msqrt><mrow><mn>2</mn></mrow></msqrt></math>,
all entries are equal to 1, except the bottom right element, which is equal to
<!-- l. 135 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>a</mi></math>. We
have for instance </p><table class='equation'><tr><td>
<!-- l. 137 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 137 --><object id='x11-220002r9' data="svgs/Hbox-2-1.svg" alt="diagram of Hbox-2-1" class="svg-diagram"></object></td><td class='eq-no'>(9.9)</td></tr></table>
<!-- l. 140 --><p class='indent'>   Hence, in particular, when <!-- l. 140 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></math>,
the 1-input 1-output H-box is just the Hadamard: </p><table class='equation'><tr><td>
<!-- l. 141 --><p class='indent'>
</p><!-- l. 141 --><object id='x11-220003r10' data="svgs/eq-Hbox-is-had.svg" alt="diagram of eq:Hbox-is-had" class="svg-diagram"></object></td><td class='eq-no'>(9.10)</td></tr></table>
<!-- l. 144 --><p class='indent'>   We can then view H-boxes as a generalisation of Hadamard gates to an arbitrary
number of inputs and outputs (hence, the letter ‘H’). Just as spiders with a zero
phase are depicted without a phase label, we will depict H-boxes with a label of
<!-- l. 145 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math>
without any label: </p><table class='equation'><tr><td>
<!-- l. 146 --><p class='indent'>
</p><!-- l. 146 --><object id='x11-220004r11' data="svgs/H-spider-nolabel.svg" alt="diagram of H-spider-nolabel" class="svg-diagram"></object></td><td class='eq-no'>(9.11)</td></tr></table>
<!-- l. 149 --><p class='indent'>   We will call such H-boxes <span class='cmbx-10x-x-109'>phase-free</span>. Note that this convention means that
the 1-input 1-output phase-free H-box is denoted exactly the same as the
Hadamard gate in the ZX-calculus, which is fine since they represent the same
matrix. The linear maps that H-boxes represent have all the symmetries that
spiders have: </p><table class='equation'><tr><td>
<!-- l. 152 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 152 --><object id='x11-220005r12' data="svgs/eq-Hbox-symmetries.svg" alt="diagram of eq:Hbox-symmetries" class="svg-diagram"></object></td><td class='eq-no'>(9.12)</td></tr></table>
<!-- l. 155 --><p class='indent'>   We can hence bend the wires of an H-box however we want. We will introduce
some rewrite rules for H-boxes, but for now let’s check that they indeed help us
accomplish our goal of having a nicer representation of a CCZ gate. First note
that: </p><table class='equation'><tr><td>
<!-- l. 158 --><p class='indent'>
</p><!-- l. 158 --><object id='x11-220006r13' data="svgs/eq-Hbox-state.svg" alt="diagram of eq:Hbox-state" class="svg-diagram"></object></td><td class='eq-no'>(9.13)</td></tr></table>
<!-- l. 161 --><p class='indent'>   We can use this state to represent a CCZ gate: </p><table class='equation'><tr><td>
<!-- l. 162 --><p class='indent'>
</p><!-- l. 162 --><object id='x11-220007r14' data="svgs/eq-CCZ-with-Hboxes.svg" alt="diagram of eq:CCZ-with-Hboxes" class="svg-diagram"></object></td><td class='eq-no'>(9.14)</td></tr></table>
   <div class='newtheorem'>
<!-- l. 165 --><p class='noindent'><span class='head'>
<a id='x11-220008r1'></a>
<span class='cmbx-10x-x-109'>Exercise 9.1.</span>  </span>Verify Eq. (<a href='#x11-220007r14'>9.14<!-- tex4ht:ref: eq:CCZ-with-Hboxes  --></a>) by plugging in computational basis states
and checking that it gives the correct phase.
                                                                     

                                                                     
</p>
   </div>
<!-- l. 167 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 168 --><p class='noindent'><span class='head'>
<a id='x11-220009r2'></a>
<span class='cmbx-10x-x-109'>Exercise 9.2.</span>  </span> The state of Eq. (<a href='#x11-220006r13'>9.13<!-- tex4ht:ref: eq:Hbox-state  --></a>) turns out to be the <span class='cmbx-10x-x-109'>CCZ magic state</span>,
meaning we can use it to construct a CCZ gate by doing some Clifford unitaries
and measurements. Show that the following post-selected unitary that uses a
CCZ magic state indeed implements a CCZ gate, by rewriting it to Eq. (<a href='#x11-220007r14'>9.14<!-- tex4ht:ref: eq:CCZ-with-Hboxes  --></a>):
</p><table class='equation-star'><tr><td>
<!-- l. 170 --><object data="svgs/CCZ-from-magic.svg" alt="diagram of CCZ-from-magic" class="svg-diagram"></object></td></tr></table>
<!-- l. 173 --><p class='indent'>   We will later introduce some rewrite rules for H-boxes that allow us to
prove that this construction works regardless of the measurement outcome,
by doing some Clifford corrections.
</p>
   </div>
<!-- l. 174 --><p class='indent'>    Now, we introduced H-boxes as a new ‘generator’ of ZX-diagrams. But we
also know that ZX-diagrams were already <span class='cmti-10x-x-109'>universal</span>. This means there must be
some way to represent the H-boxes just using spiders. In fact, that is actually
what the relations Eqs. (<a href='#x11-218002r3'>9.3<!-- tex4ht:ref: eq:Boolean-identity-reverse  --></a>), (<a href='#x11-218004r5'>9.5<!-- tex4ht:ref: eq:mult-xor-3  --></a>) and their generalisations allow us to do:
</p><table class='equation'><tr><td>
<!-- l. 176 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 176 --><object id='x11-220010r15' data="svgs/Hboxes-as-spiders.svg" alt="diagram of Hboxes-as-spiders" class="svg-diagram"></object></td><td class='eq-no'>(9.15)</td></tr></table>
<!-- l. 179 --><p class='indent'>   In general, for an arity <!-- l. 179 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
H-box this construction requires <!-- l. 179 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math>
phase gadgets. If the parameter of the H-box is not a complex phase
<!-- l. 180 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iα</mi></mrow></msup></math> we
can still represent the H-box using spiders, but it is a bit more complicated: see
Exercise <a href='#x11-233008r19'>9.19<!-- tex4ht:ref: exer:H-boxes-complex  --></a>.
</p>
   <h4 class='subsectionHead' id='and-gates'><span class='titlemark'>9.2.1   </span> <a id='x11-2210009.2.1'></a>AND gates</h4>
<!-- l. 182 --><p class='noindent'>Using an H-box we can easily represent the CCZ gate. But of course the CCZ
gate is related to the Toffoli by conjugating the target by a Hadamard, so with
some rewriting we can get an interesting representation of the Toffoli:
</p><table class='equation'><tr><td>
<!-- l. 183 --><p class='indent'>
</p><!-- l. 183 --><object id='x11-221001r16' data="svgs/eq-CCZ-had-to-tof.svg" alt="diagram of eq:CCZ-had-to-tof" class="svg-diagram"></object></td><td class='eq-no'>(9.16)</td></tr></table>
<!-- l. 186 --><p class='indent'>   The reason this is interesting is because it is showing directly the two
components that make up the Toffoli: calculating the AND of the first two
qubits, and then XORing it with the third qubit. Indeed, we can calculate:
</p><table class='equation'><tr><td>
<!-- l. 188 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 188 --><object id='x11-221002r17' data="svgs/AND-from-hbox.svg" alt="diagram of AND-from-hbox" class="svg-diagram"></object></td><td class='eq-no'>(9.17)</td></tr></table>
<!-- l. 191 --><p class='indent'>   Hence: </p><table class='equation'><tr><td>
<!-- l. 192 --><p class='indent'>
</p><!-- l. 192 --><object id='x11-221003r18' data="svgs/eq-AND-hbox-states.svg" alt="diagram of eq:AND-hbox-states" class="svg-diagram"></object></td><td class='eq-no'>(9.18)</td></tr></table>
<!-- l. 195 --><p class='indent'>   We can then directly verify that Eq. (<a href='#x11-221001r16'>9.16<!-- tex4ht:ref: eq:CCZ-had-to-tof  --></a>) implements a Toffoli:
</p><table class='equation'><tr><td>
<!-- l. 196 --><p class='indent'>
</p><!-- l. 196 --><object id='x11-221004r19' data="svgs/eq-Toffoli-AND-calc-ZH.svg" alt="diagram of eq:Toffoli-AND-calc-ZH" class="svg-diagram"></object></td><td class='eq-no'>(9.19)</td></tr></table>
   <div class='newtheorem'>
<!-- l. 199 --><p class='noindent'><span class='head'>
<a id='x11-221005r1'></a>
<span class='cmbx-10x-x-109'>Remark 9.2.1.</span>  </span>Since a 2-to-1 H-box followed by a Hadamard implements an
‘AND gate’, it is reasonable to wonder why we didn’t just define an ‘AND-box’ as
a new element of ZX-diagrams. This would make it a nice counterpart
to the X-spider that implements an XOR. However, one of the main
symmetries present in the Z- and X-spiders does not hold for this hypothetical
AND-box (which can be verified by calculating the associated matrices):
</p><table class='equation'><tr><td>
                                                                     

                                                                     
<!-- l. 202 --><p class='indent'>
</p><!-- l. 202 --><object id='x11-221006r20' data="svgs/AND-not-symmetric.svg" alt="diagram of AND-not-symmetric" class="svg-diagram"></object></td><td class='eq-no'>(9.20)</td></tr></table>
<!-- l. 205 --><p class='indent'>   This symmetry, known as <span class='cmbx-10x-x-109'>flexsymmetry</span>, <span class='cmti-10x-x-109'>does </span>hold for the H-box (see
Eq. (<a href='#x11-220005r12'>9.12<!-- tex4ht:ref: eq:Hbox-symmetries  --></a>)). Hence, by splitting up the AND gate into an H-box and
Hadamard, we still get the benefit of having a compact representation of
the AND, while also only dealing with components that have all the
symmetries we want, meaning we can still think of ZX-diagrams as undirected
graphs.
</p>
   </div>
<!-- l. 206 --><p class='indent'>
</p>
   <h4 class='subsectionHead' id='rules-for-the-hbox'><span class='titlemark'>9.2.2   </span> <a id='x11-2220009.2.2'></a>Rules for the H-box</h4>
<!-- l. 209 --><p class='noindent'>Of course we wouldn’t be introducing a new graphical part to the ZX-calculus, if
it didn’t allow us to do some more rewriting! There are some H-box specific
rewrite rules that we can use to reason about, for instance, controlled unitaries,
and Toffoli gates. First, let us recall that arity-1 H-boxes labelled by a complex
phase are just Z-spiders: </p><table class='equation'><tr><td>
<!-- l. 212 --><p class='indent'>
</p><!-- l. 212 --><object id='x11-222001r21' data="svgs/eq-H-state-as-Z.svg" alt="diagram of eq:H-state-as-Z" class="svg-diagram"></object></td><td class='eq-no'>(9.21)</td></tr></table>
                                                                     

                                                                     
<!-- l. 215 --><p class='indent'>   In particular, taking respectively <!-- l. 215 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>α</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>
and <!-- l. 215 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>α</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>π</mi></mrow></math>,
we get: </p><table class='equation'><tr><td>
<!-- l. 216 --><p class='indent'>
</p><!-- l. 216 --><object id='x11-222002r22' data="svgs/eq-H-state-unit.svg" alt="diagram of eq:H-state-unit" class="svg-diagram"></object></td><td class='eq-no'>(9.22)</td></tr></table>
<!-- l. 219 --><p class='indent'>   Most of the other H-box rewrite rules we will use can be motivated by the
relation between an H-box and the AND gate. To understand these it will be
helpful to use multi-input AND gates: </p><table class='equation'><tr><td>
<!-- l. 221 --><p class='indent'>
</p><!-- l. 221 --><object id='x11-222003r23' data="svgs/eq-AND-mult-hbox.svg" alt="diagram of eq:AND-mult-hbox" class="svg-diagram"></object></td><td class='eq-no'>(9.23)</td></tr></table>
<!-- l. 224 --><p class='indent'>   A rule on H-boxes we have already seen is that two Hadamard gates cancel:
<img src="svgs/had-had-cancel.svg" alt="diagram of had-had-cancel" class="inline-diagram" /> . Using our interpretation of multi-input AND
gates (<a href='#x11-222003r23'>9.23<!-- tex4ht:ref: eq:AND-mult-hbox  --></a>) as H-boxes we can get a different view on this equation. Using
Eq. (<a href='#x11-222003r23'>9.23<!-- tex4ht:ref: eq:AND-mult-hbox  --></a>) we see that two Hadamard gates in a row correspond to an AND gate
with a single input, and this gate is of course the identity. Our first new rule
expresses how a sequence of ANDs can be combined into a single multi-input
AND: </p><table class='equation'><tr><td>
<!-- l. 228 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 228 --><object id='x11-222004r24' data="svgs/AND-spider-fusion.svg" alt="diagram of AND-spider-fusion" class="svg-diagram"></object></td><td class='eq-no'>(9.24)</td></tr></table>
<!-- l. 231 --><p class='indent'>   This rule can be presented a bit more generally as an <span class='cmti-10x-x-109'>H-box fusion </span>rule:
</p><table class='equation'><tr><td>
<!-- l. 232 --><p class='indent'>
</p><!-- l. 232 --><object id='x11-222005r25' data="svgs/eq-Hbox-spider.svg" alt="diagram of eq:Hbox-spider" class="svg-diagram"></object></td><td class='eq-no'>(9.25)</td></tr></table>
<!-- l. 235 --><p class='indent'>   Note that whereas two spiders fuse together when they are connected
by a leg, for an H-box, this connection needs to be a Hadamard
edge. An important consequence of this rule is that H-boxes absorb
<!-- l. 236 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
states: </p><table class='equation'><tr><td>
<!-- l. 237 --><p class='indent'>
</p><!-- l. 237 --><object id='x11-222006r26' data="svgs/eq-Hbox-absorb-1.svg" alt="diagram of eq:Hbox-absorb-1" class="svg-diagram"></object></td><td class='eq-no'>(9.26)</td></tr></table>
<!-- l. 240 --><p class='indent'>   Using this we can show for instance that inputting a
<!-- l. 240 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> on
one of the controls of a Toffoli reduces it to a CNOT: </p><table class='equation'><tr><td>
<!-- l. 241 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 241 --><object id='x11-222007r27' data="svgs/TOF-becomes-CNOT.svg" alt="diagram of TOF-becomes-CNOT" class="svg-diagram"></object></td><td class='eq-no'>(9.27)</td></tr></table>
<!-- l. 244 --><p class='indent'>   We will see later in (<a href='#x11-222011r31'>9.31<!-- tex4ht:ref: eq:X-H-state-copy  --></a>) that, in contrast, a
<!-- l. 244 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
‘explodes’ an H-box into Z-spiders. In Section <a href='main_htmlch3.html#strong-complementarity'>3.2.4<!-- tex4ht:ref: sec:bialgebra-hopf  --></a> we saw how the
interpretation of the Z- and X-spider as respectively COPY and XOR lead us to
the strong complementarity rule that allowed us to push (phaseless) Z- and
X-spiders through each other. This equation (<a href='main_htmlch3.html#x5-63001r55'>3.55<!-- tex4ht:ref: eq:XOR-COPY-bialgebra  --></a>) involving COPY and
XOR holds in exactly the same way when XOR is replaced by AND:
</p><table class='equation'><tr><td>
<!-- l. 246 --><p class='indent'>
</p><!-- l. 246 --><object id='x11-222008r28' data="svgs/AND-COPY-bialgebra.svg" alt="diagram of AND-COPY-bialgebra" class="svg-diagram"></object></td><td class='eq-no'>(9.28)</td></tr></table>
<!-- l. 249 --><p class='indent'>   We can directly translate this into a rule involving Z-spiders and H-boxes:
</p><table class='equation'><tr><td>
<!-- l. 250 --><p class='indent'>
</p><!-- l. 250 --><object id='x11-222009r29' data="svgs/eq-ZH-bialgebra-AND.svg" alt="diagram of eq:ZH-bialgebra-AND" class="svg-diagram"></object></td><td class='eq-no'>(9.29)</td></tr></table>
                                                                     

                                                                     
<!-- l. 253 --><p class='indent'>   By pushing the Hadamard through the Z-spider and cancelling some
Hadamards we can also present this in a format that is often more convenient:
</p><table class='equation'><tr><td>
<!-- l. 254 --><p class='indent'>
</p><!-- l. 254 --><object id='x11-222010r30' data="svgs/eq-ZH-bialgebra.svg" alt="diagram of eq:ZH-bialgebra" class="svg-diagram"></object></td><td class='eq-no'>(9.30)</td></tr></table>
<!-- l. 257 --><p class='indent'>   As in (<a href='main_htmlch3.html#x5-65001r69'>3.69<!-- tex4ht:ref: eq:bialgebra-rule-many  --></a>), the right-hand side of both of these equations is a fully connected
bipartite graph. Note that as a special case of the second equation (taking
<!-- l. 258 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>) we
get the following useful state-copy rule, which is a counterpart of (<a href='#x11-222006r26'>9.26<!-- tex4ht:ref: eq:Hbox-absorb-1  --></a>):
</p><table class='equation'><tr><td>
<!-- l. 259 --><p class='indent'>
</p><!-- l. 259 --><object id='x11-222011r31' data="svgs/eq-X-H-state-copy.svg" alt="diagram of eq:X-H-state-copy" class="svg-diagram"></object></td><td class='eq-no'>(9.31)</td></tr></table>
<!-- l. 262 --><p class='indent'>   Here in the last step we dropped the scalar subdiagram, as it only contributes
a (usually irrelevant) non-zero scalar. Using this rule we can show that inputting
a <!-- l. 263 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> on
a control wire of a Toffoli reduces it to an identity: </p><table class='equation'><tr><td>
<!-- l. 264 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 264 --><object id='x11-222012r32' data="svgs/TOF-ket0-removes.svg" alt="diagram of TOF-ket0-removes" class="svg-diagram"></object></td><td class='eq-no'>(9.32)</td></tr></table>
   <div class='newtheorem'>
<!-- l. 267 --><p class='noindent'><span class='head'>
<a id='x11-222013r3'></a>
<span class='cmbx-10x-x-109'>Exercise 9.3.</span>  </span>Using Eqs. (<a href='#x11-222010r30'>9.30<!-- tex4ht:ref: eq:ZH-bialgebra  --></a>) and (<a href='#x11-222011r31'>9.31<!-- tex4ht:ref: eq:X-H-state-copy  --></a>) (and the standard ZX rules), prove
that two CCZs in a row equal the identity: </p><table class='equation-star'><tr><td>
<!-- l. 269 --><object data="svgs/CCZ-CCZ-cancel.svg" alt="diagram of CCZ-CCZ-cancel" class="svg-diagram"></object></td></tr></table>
   </div>
<!-- l. 272 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 280 --><p class='noindent'><span class='head'>
<a id='x11-222014r4'></a>
<span class='cmbx-10x-x-109'>Exercise 9.4.</span>  </span>Prove that we can commute a NOT gate through an H-box,
resulting in a CZ on the other side: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 282 --><object data="svgs/H-box-NOT-commute.svg" alt="diagram of H-box-NOT-commute" class="svg-diagram"></object></td></tr></table>
<!-- l. 285 --><p class='indent'>   Hint:                                     Unfuse                                     the
<!-- l. 285 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>
phase onto its own spider, and then apply Eq. (<a href='#x11-222010r30'>9.30<!-- tex4ht:ref: eq:ZH-bialgebra  --></a>).
</p>
   </div>
<!-- l. 286 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 294 --><p class='noindent'><span class='head'>
<a id='x11-222015r5'></a>
<span class='cmbx-10x-x-109'>Exercise 9.5.</span>  </span> In Exercise <a href='#x11-220009r2'>9.2<!-- tex4ht:ref: exer:CCZ-from-magic  --></a> we saw that with post-selection, a CCZ gate can
be implemented by using a magic state and post-selection. However, this
post-selection is not necessary, as the other measurement outcomes can be
corrected by applying the right gates in the future. For instance, if we get the
<!-- l. 295 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>⟨</mo><mn>1</mn><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>
outcome on the first measured qubit instead, we can correct this with a CZ
gate on the second and third output qubits. Show this by proving that:
</p><table class='equation-star'><tr><td>
<!-- l. 296 --><object data="svgs/CCZ-from-magic-correction.svg" alt="diagram of CCZ-from-magic-correction" class="svg-diagram"></object></td></tr></table>
<!-- l. 299 --><p class='indent'>   Bonus exercise: figure out what the correction operator is when both the
first         and         second         measured         qubits         get         the
<!-- l. 299 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>⟨</mo><mn>1</mn><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>
outcome.
                                                                     

                                                                     
</p>
   </div>
<!-- l. 300 --><p class='indent'>     Another consequence of Eq. (<a href='#x11-222010r30'>9.30<!-- tex4ht:ref: eq:ZH-bialgebra  --></a>) is that the identification of a
<!-- l. 304 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>-labelled
H-box with a Z-spider of (<a href='#x11-222002r22'>9.22<!-- tex4ht:ref: eq:H-state-unit  --></a>) can be generalised to higher arity as follows:
</p><table class='equation'><tr><td>
<!-- l. 305 --><p class='indent'>
</p><!-- l. 305 --><object id='x11-222016r33' data="svgs/eq-unit-rule-many.svg" alt="diagram of eq:unit-rule-many" class="svg-diagram"></object></td><td class='eq-no'>(9.33)</td></tr></table>
<!-- l. 308 --><p class='indent'>   Let us now introduce the last pair of AND-inspired rewrite rules for H-boxes.
These are based on the following identities: </p><table class='equation'><tr><td>
<!-- l. 309 --><p class='indent'>
</p><!-- l. 309 --><object id='x11-222017r34' data="svgs/AND-COPY-cancel.svg" alt="diagram of AND-COPY-cancel" class="svg-diagram"></object></td><td class='eq-no'>(9.34)</td></tr></table>
<!-- l. 312 --><p class='indent'>   The first is quite self-evident: if we copy a value and then AND those values
together, it is the same thing as doing nothing to the value. The second requires a bit
more explanation. It expresses a fact about the possible ways that AND can return
<!-- l. 313 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>. Indeed, as a linear map,
we can write AND as <!-- l. 313 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mn>00</mn><mo class='MathClass-rel' stretchy='false'>|</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mn>01</mn><mo class='MathClass-rel' stretchy='false'>|</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mn>01</mn><mo class='MathClass-rel' stretchy='false'>|</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mn>11</mn><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>,
and hence post-selecting the output of AND with
<!-- l. 313 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>⟨</mo><mn>1</mn><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math> we
calculate <!-- l. 313 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>⟨</mo><mn>1</mn><mo class='MathClass-rel' stretchy='false'>|</mo><mspace class='thinspace' width='0.17em'></mspace><mstyle class='text'><mtext>AND</mtext></mstyle> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>⟨</mo><mn>11</mn><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>.
Writing the ANDs as H-boxes and simplifying the expressions a bit we get the
following rewrite rules: </p><table class='equation'><tr><td>
<!-- l. 315 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 315 --><object id='x11-222018r35' data="svgs/eq-Hbox-ANDlike-rules.svg" alt="diagram of eq:Hbox-ANDlike-rules" class="svg-diagram"></object></td><td class='eq-no'>(9.35)</td></tr></table>
<!-- l. 318 --><p class='indent'>   Note that using (<a href='#x11-222002r22'>9.22<!-- tex4ht:ref: eq:H-state-unit  --></a>) we could also have written the second equation
of (<a href='#x11-222018r35'>9.35<!-- tex4ht:ref: eq:Hbox-ANDlike-rules  --></a>) as: </p><table class='equation'><tr><td>
<!-- l. 319 --><p class='indent'>
</p><!-- l. 319 --><object id='x11-222019r36' data="svgs/Hbox-pi-rule2.svg" alt="diagram of Hbox-pi-rule2" class="svg-diagram"></object></td><td class='eq-no'>(9.36)</td></tr></table>
<!-- l. 322 --><p class='indent'>   The rules introduced so far are summarised in Figure <a href='#the-basic-rules-for-hboxes-'>9.0<!-- tex4ht:ref: fig:zh-rules  --></a>. </p><figure class='figure' id='x11-2220200'><span id='the-basic-rules-for-hboxes-'></span> 

                                                                     

                                                                     

                                                                     

                                                                     
<!-- l. 324 --><p class='noindent'>figure<a id='figure._theHfigure_'></a>
</p><!-- l. 326 --><p class='noindent'><img src="svgs/ZH-rules.svg" alt="diagram of ZH-rules" class="inline-diagram" />
</p>
<figcaption class='caption'><span class='id'>Figure 9.0: </span><span class='content'>The basic rules for H-boxes. </span></figcaption><!-- tex4ht:label?: x11-2220200  -->
                                                                     

                                                                     
   </figure>
<!-- l. 333 --><p class='indent'>   We have now covered all the ‘AND inspired’ H-box rules. In fact,
these rules, together with the phase-free ZX-calculus rules we have been
using throughout the book (that is, those of Figure <a href='main_htmlch4.html#the-rules-of-the-phasefree-zx-calculus-the-spider-rules-sp-and-strong-complementarity-sc-note-the-righthandside-of-the-sc-rule-is-a-complete-bipartite-graph-of-m-z-spiders-and-n-x-spiders-with-a-normalisation-factor-mn-which-we-typically-drop-when-scalar-factors-are-irrelevant'>4.0<!-- tex4ht:ref: fig:pp-zx  --></a>), are already
complete for a useful fragment of quantum computing. Namely, if we
restrict ourselves to phase-free H-boxes, and spiders that only have
<!-- l. 334 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math> or
<!-- l. 334 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>
phases, then we can represent precisely those linear maps that can be built by
post-selected quantum circuits consisting of Toffoli and Hadamard gates. It turns
out that Toffoli-Hadamard circuits are already enough to perform arbitrary
quantum computations (see Section* <a href='main_htmlch10.html#computational-universality-of-toffolihadamard'>10.7.4<!-- tex4ht:ref: sec:real-qc  --></a> for more details on that), and hence
this fragment of diagrams can represent many interesting maps. Proving that the
rules of Figures <a href='#the-basic-rules-for-hboxes-'>9.0<!-- tex4ht:ref: fig:zh-rules  --></a> and <a href='main_htmlch4.html#the-rules-of-the-phasefree-zx-calculus-the-spider-rules-sp-and-strong-complementarity-sc-note-the-righthandside-of-the-sc-rule-is-a-complete-bipartite-graph-of-m-z-spiders-and-n-x-spiders-with-a-normalisation-factor-mn-which-we-typically-drop-when-scalar-factors-are-irrelevant'>4.0<!-- tex4ht:ref: fig:pp-zx  --></a> are complete for this fragment is quite difficult (see
the References of this chapter for some notes), but let’s note that this
completeness does say something interesting on how to reason about quantum
computations: the ZX rules we have been using are complete for Clifford
diagrams (Theorem <a href='main_htmlch5.html#x7-124008r7'>5.5.7<!-- tex4ht:ref: thm:Clifford-completeness  --></a>), while the new rules for H-boxes of Figure <a href='#the-basic-rules-for-hboxes-'>9.0<!-- tex4ht:ref: fig:zh-rules  --></a>
are all directly related to Boolean identities. Hence, somehow ‘classical
logic’ plus ‘reasoning with Cliffords’ gives us the full power of quantum
computing.
</p>
   <h4 class='subsectionHead' id='constructing-controlled-unitaries-using-hboxes'><span class='titlemark'>9.2.3   </span> <a id='x11-2230009.2.3'></a>Constructing controlled unitaries using H-boxes</h4>
<!-- l. 337 --><p class='noindent'>A useful feature of the ZH-calculus is that it allows us to quite easily see how to
make a controlled-unitary out of a unitary given as a ZH-diagram. This is
perhaps most easily demonstrated by the difference between a CZ and a CCZ
gate in the ZH-calculus: </p><table class='equation'><tr><td>
<!-- l. 339 --><p class='indent'>
</p><!-- l. 339 --><object id='x11-223001r37' data="svgs/CZ-3.svg" alt="diagram of CZ-3" class="svg-diagram"></object></td><td class='eq-no'>(9.37)</td></tr></table>
<!-- l. 342 --><p class='indent'>   This suggests a general procedure for adding a control qubit: identify which
H-box ‘activates’ the application of your gate, and add another wire to it which
connects to a Z-spider on your control qubit. Sometimes, one has to work a bit to
                                                                     

                                                                     
uncover the correct H-box. For instance, to see how a Z gate relates to a CZ, we
unfuse its phase: </p><table class='equation'><tr><td>
<!-- l. 344 --><p class='indent'>
</p><!-- l. 344 --><object id='x11-223002r38' data="svgs/Z-to-CZ.svg" alt="diagram of Z-to-CZ" class="svg-diagram"></object></td><td class='eq-no'>(9.38)</td></tr></table>
<!-- l. 347 --><p class='indent'>   This procedure also works for making controlled-phase gates if the phase is something
other than <!-- l. 347 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>:
</p><table class='equation'><tr><td>
<!-- l. 348 --><p class='indent'>
</p><!-- l. 348 --><object id='x11-223003r39' data="svgs/eq-cz-alpha.svg" alt="diagram of eq:cz-alpha" class="svg-diagram"></object></td><td class='eq-no'>(9.39)</td></tr></table>
<!-- l. 351 --><p class='indent'>   For diagrams containing X-spiders we will usually have to convert these to Z-spiders
using <!-- l. 351 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='label' xlink:href='main_htmlch3.html#x5-580020' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'><mstyle mathvariant='bold'><mi>cc</mi></mstyle></mstyle><!-- endlabel --><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
in order to see where we should add the control wire. For instance, to go from a
CNOT to a CCNOT (Toffoli): </p><table class='equation'><tr><td>
<!-- l. 352 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 352 --><object id='x11-223004r40' data="svgs/CNOT-to-tof.svg" alt="diagram of CNOT-to-tof" class="svg-diagram"></object></td><td class='eq-no'>(9.40)</td></tr></table>
<!-- l. 355 --><p class='indent'>   Note that we here added a control wire to the ‘middle’ H-box, but
left the Hadamards on the qubit wire alone. This is a general rule for
constructing a controlled diagram. For instance, it might be tempting to define a
controlled-Hadamard as follows: </p><table class='equation'><tr><td>
<!-- l. 357 --><p class='indent'>
</p><!-- l. 357 --><object id='x11-223005r41' data="svgs/CHAD-fake.svg" alt="diagram of CHAD-fake" class="svg-diagram"></object></td><td class='eq-no'>(9.41)</td></tr></table>
<!-- l. 360 --><p class='indent'>   While this does indeed implement a Hadamard gate when the control qubit is in
the <!-- l. 360 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
state, it does not reduce to the identity when the control qubit is
<!-- l. 360 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>:
</p><table class='equation'><tr><td>
<!-- l. 361 --><p class='indent'>
</p><!-- l. 361 --><object id='x11-223006r42' data="svgs/CHAD-fake-pf.svg" alt="diagram of CHAD-fake-pf" class="svg-diagram"></object></td><td class='eq-no'>(9.42)</td></tr></table>
<!-- l. 364 --><p class='indent'>   To construct the actual controlled-Hadamard we need to find the ‘hidden’
H-boxes in the Hadamard gate. The way we do this is by using its decomposition
into Euler angles: </p><table class='equation'><tr><td>
<!-- l. 365 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 365 --><object id='x11-223007r43' data="svgs/eq-had-euler3.svg" alt="diagram of eq:had-euler3" class="svg-diagram"></object></td><td class='eq-no'>(9.43)</td></tr></table>
<!-- l. 368 --><p class='indent'>   We can now make each of these phase gates into controlled phase gate using (<a href='#x11-223003r39'>9.39<!-- tex4ht:ref: eq:cz-alpha  --></a>).
When transforming this Euler decomposition into its controlled version, the ignorable
global phase <!-- l. 369 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></msup></math>
becomes a local phase that must be taken into account. This is in fact another
instance of finding the hidden H-boxes of the diagram, as a scalar is just
an H-box with zero wires. We hence get the following transformation:
</p><table class='equation'><tr><td>
<!-- l. 371 --><p class='indent'>
</p><!-- l. 371 --><object id='x11-223008r44' data="svgs/eq-had-make-controlled.svg" alt="diagram of eq:had-make-controlled" class="svg-diagram"></object></td><td class='eq-no'>(9.44)</td></tr></table>
<!-- l. 374 --><p class='indent'>   Where in the last step we used the identity
<!-- l. 374 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> </mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>i</mi></mrow></math>. While
this procedure works and gives the correct diagram for a controlled-Hadamard,
it is not the most efficient implementation of a controlled-Hadamard.
A better version is realised by making the observation that if we only
control the middle phase-gate and the global phase of (<a href='#x11-223007r43'>9.43<!-- tex4ht:ref: eq:had-euler3  --></a>) that
we get a diagram that implements a Hadamard when the control is
<!-- l. 375 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>, and
implements an X gate otherwise: </p><table class='equation'><tr><td>
<!-- l. 376 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 376 --><object id='x11-223009r45' data="svgs/eq-had-controlled-attempt2.svg" alt="diagram of eq:had-controlled-attempt2" class="svg-diagram"></object></td><td class='eq-no'>(9.45)</td></tr></table>
<!-- l. 379 --><p class='indent'>   Hence, to make this a controlled-Hadamard, we need to add an X gate on
the target wire to cancel the already existing X gate, but doing this
will result in the wrong unitary being implemented when the control is
<!-- l. 379 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>. To
remedy this error we add another gate to the circuit: a CNOT (i.e. a
controlled-X gate). We hence arrive at the final controlled-Hadamard circuit:
</p><table class='equation'><tr><td>
<!-- l. 381 --><p class='indent'>
</p><!-- l. 381 --><object id='x11-223010r46' data="svgs/eq-CHAD.svg" alt="diagram of eq:CHAD" class="svg-diagram"></object></td><td class='eq-no'>(9.46)</td></tr></table>
<!-- l. 384 --><p class='indent'>   Note that we get the <!-- l. 384 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>
X-phase by combining the first <!-- l. 384 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>
phase of (<a href='#x11-223009r45'>9.45<!-- tex4ht:ref: eq:had-controlled-attempt2  --></a>) with the added <!-- l. 384 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>
phase coming from the <!-- l. 384 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>
gate. The gate (<a href='#x11-223010r46'>9.46<!-- tex4ht:ref: eq:CHAD  --></a>) is indeed what one would find for a controlled-Hadamard in a
standard textbook (although if one starts with a different Euler decomposition of
the Hadamard gate, one might get a CZ gate instead of a CX gate, along with
some other permutations of the gates). We can further decompose the
‘controlled-<!-- l. 385 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math>’
gate using what we have seen in Section <a href='#diagonal-controlled-gates-and-phase-polynomials'>9.1.2<!-- tex4ht:ref: sec:diagonal-controlled-gates  --></a>.
</p>
   <div class='newtheorem'>
<!-- l. 386 --><p class='noindent'><span class='head'>
<a id='x11-223011r6'></a>
<span class='cmbx-10x-x-109'>Exercise 9.6.</span>  </span>By  decomposing  and  simplifying  Eq. (<a href='#x11-223010r46'>9.46<!-- tex4ht:ref: eq:CHAD  --></a>)  even  further,
find an implementation of the controlled-Hadamard gate that requires just
two
<!-- l. 387 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
                                                                     

                                                                     
gates, and one CNOT gate.
</p>
   </div>
<!-- l. 388 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 396 --><p class='noindent'><span class='head'>
<a id='x11-223012r7'></a>
<span class='cmbx-10x-x-109'>Exercise 9.7.</span>  </span>Construct an implementation of the controlled-Hadamard
gate  using  just  one  controlled-phase  gate,  but  starting  with  the  Euler
Decomposition <img src="svgs/had-euler4.svg" alt="diagram of had-euler4" class="inline-diagram" /> , instead of with Eq. (<a href='#x11-223007r43'>9.43<!-- tex4ht:ref: eq:had-euler3  --></a>).
</p>
   </div>
<!-- l. 400 --><p class='indent'>    It is currently not clear how one would relate (<a href='#x11-223010r46'>9.46<!-- tex4ht:ref: eq:CHAD  --></a>) and the more
complicated (<a href='#x11-223008r44'>9.44<!-- tex4ht:ref: eq:had-make-controlled  --></a>) via an intuitive diagrammatic transformation (as the calculus
is complete, there is a set of graphical rewrites that transforms one into the
other, but this is likely to be a complicated affair). So how would one
find (<a href='#x11-223010r46'>9.46<!-- tex4ht:ref: eq:CHAD  --></a>)? The crucial observation is that only controlling a single phase
in the diagram, instead of all three, already resulted in a gate close to
the one we desired. The remainder of the construction was then to keep
adding simple gates until we get the exact gate we wanted. Experience
shows that this method of experimentation and trial-and-error is often
successful. Let’s demonstrate this with one more often-encountered controlled
unitary: the <span class='cmbx-10x-x-109'>controlled swap </span>(also sometimes called the <span class='cmbx-10x-x-109'>Fredkin gate</span>).
Our starting point is the implementation of a swap using three CNOTs:
</p><table class='equation'><tr><td>
<!-- l. 405 --><p class='indent'>
</p><!-- l. 405 --><object id='x11-223013r47' data="svgs/swap-three-cnots.svg" alt="diagram of swap-three-cnots" class="svg-diagram"></object></td><td class='eq-no'>(9.47)</td></tr></table>
<!-- l. 408 --><p class='indent'>   We could make this controlled by transforming each of the CNOTs
into a Toffoli. However, just as with the controlled-Hadamard, we realise
that if we ‘deactivate’ the middle CNOT, that the outer CNOTs cancel
                                                                     

                                                                     
each other, and hence it suffices to add a control to the middle CNOT:
</p><table class='equation-star'><tr><td>
<!-- l. 409 --><object data="svgs/CSWAP.svg" alt="diagram of CSWAP" class="svg-diagram"></object></td></tr></table>
<!-- l. 412 --><p class='noindent'>
</p>
   <h3 class='sectionHead' id='reversible-logic-synthesis'><span class='titlemark'>9.3   </span> <a id='x11-2240009.3'></a>Reversible Logic synthesis</h3>
<!-- l. 413 --><p class='noindent'>An important part of many quantum algorithms are <span class='cmbx-10x-x-109'>classical oracles</span>. These
are classical functions that are performed on a quantum state (a state
that is often in a superposition of many computational basis states).
For instance, Shor’s algorithm consists of two components: a classical
oracle performing modular exponentiation followed by a quantum Fourier
transform. In terms of gate cost, the classical oracle is by far the most
expensive part (the quantum Fourier transform can be implemented quite
efficiently as we saw in Section <a href='main_htmlch7.html#quantum-fourier-transform'>7.2.2<!-- tex4ht:ref: sec:QFT  --></a>). In Grover’s algorithm it is again the
classical oracle that pinpoints which elements we are interested in that
is the most expensive to implement. As classical oracles form such an
important part of these algorithms (and many others), we better understand
very well how to actually implement these on quantum computers. The
first step is to realise that usually the function we want to implement
is not reversible, so that we can’t implement it directly as a unitary.
We can however make it reversible by adding some additional scratch
space.
</p>
   <div class='newtheorem'>
<!-- l. 417 --><p class='noindent'><span class='head'>
<a id='x11-224001r1'></a>
<span class='cmbx-10x-x-109'>Definition 9.3.1.</span>  </span>Let <!-- l. 418 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi> <mo class='MathClass-punc' stretchy='false'>:</mo> <mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>→</mo> <mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>m</mi></mrow></msup></mrow></math>
be some classical function. Its <span class='cmbx-10x-x-109'>reversibilisation </span><!-- l. 418 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>f</mi></mrow><mrow><mi>r</mi></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo> <mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mi>m</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>→</mo> <mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mi>m</mi></mrow></msup></mrow></math>
                                                                     

                                                                     
is defined as <!-- l. 418 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>f</mi></mrow><mrow><mi>r</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-punc' stretchy='false'>,</mo><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-punc' stretchy='false'>,</mo><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
Here the XOR <!-- l. 418 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mo class='MathClass-bin' stretchy='false'>⊕</mo></math>
acts componentwise on the bit string.
</p>
   </div>
<!-- l. 419 --><p class='indent'>    It is clear that <!-- l. 420 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>f</mi></mrow><mrow><mi>r</mi></mrow></msub></math>
is always reversible, as it is its own inverse.
</p>
   <div class='newtheorem'>
<!-- l. 421 --><p class='noindent'><span class='head'>
<a id='x11-224002r2'></a>
<span class='cmbx-10x-x-109'>Definition 9.3.2.</span>  </span>A <span class='cmbx-10x-x-109'>classical oracle </span>for <!-- l. 422 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi> <mo class='MathClass-punc' stretchy='false'>:</mo> <mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>→</mo> <mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>m</mi></mrow></msup></mrow></math>
is an <!-- l. 422 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>m</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>-qubit
unitary <!-- l. 422 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>U</mi></mrow><mrow><mi>f</mi></mrow></msub></math>
given by <!-- l. 422 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>U</mi></mrow><mrow><mi>f</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-punc' stretchy='false'>,</mo><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>f</mi></mrow><mrow><mi>r</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-punc' stretchy='false'>,</mo><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-punc' stretchy='false'>,</mo><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
</p>
   </div>
<!-- l. 423 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 424 --><p class='noindent'><span class='head'>
<a id='x11-224003r3'></a>
<span class='cmbx-10x-x-109'>Example 9.3.3.</span>  </span>The classical oracle for the NOT operation is the CNOT
gate, and the classical oracle for the AND operation is the Toffoli gate.
</p>
   </div>
<!-- l. 426 --><p class='indent'>    So the question is: <span class='cmti-10x-x-109'>how do we efficiently construct reversible
functions using simple gates? </span>It turns out that this question has many
different answers depending on what your requirements are. The field of
reversible circuit synthesis is vast, and we will only be scratching the
surface in this section. Let’s suppose we have some classical function
<!-- l. 429 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi> <mo class='MathClass-punc' stretchy='false'>:</mo> <msup><mrow><mo class='MathClass-open' stretchy='false'>{</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>}</mo></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>→</mo><msup><mrow><mo class='MathClass-open' stretchy='false'>{</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>}</mo></mrow><mrow><mi>m</mi></mrow></msup></mrow></math> that we
want to implement. To simplify our life we will assume that we want the output
of <!-- l. 429 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math> to
appear on some additional bits. That is, we have our register of bits
<!-- l. 429 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></math> that
are our inputs, and then we also have a supply of bits given to us in the 0 state.
Some of these bits will be used to store intermediate computations, while others
                                                                     

                                                                     
will be used as the final output. So, in total, we are looking for a unitary
<!-- l. 430 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math> that
implements <!-- l. 430 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>U</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-punc' stretchy='false'>,</mo><mover accent='true'><mrow><mn>0</mn></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-punc' stretchy='false'>,</mo><mover accent='true'><mrow><mn>0</mn></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-punc' stretchy='false'>,</mo><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-punc' stretchy='false'>,</mo><mover accent='true'><mrow><mn>0</mn></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
Here the first additional register of bits stores the output, while the other register
was just used during the computation. Note that it is important that we
reset these ‘helper bits’ to 0 when we are done with them: as long as we
stick to classical computations their state doesn’t matter, but as soon
as superpositions of states are involved, they will cause interferences
that we don’t want. Let’s look at a small example to make this a bit
more concrete. Suppose we want to calculate the three-bit function
<!-- l. 431 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>∧</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>∧</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub></mrow></math>. We
can split this up into two operations acting on fewer bits, by first calculating
<!-- l. 431 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>z</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>∧</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></math>, and then
calculating <!-- l. 431 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>z</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>z</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>∧</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub></mrow></math>.
This final bit <!-- l. 431 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>z</mi></mrow><mrow><mn>2</mn></mrow></msub></math>
then carries our output. So this results in the following circuit: </p><table class='equation-star'><tr><td>
<!-- l. 432 --><object data="svgs/And-3-additional-bit.svg" alt="diagram of And-3-additional-bit" class="svg-diagram"></object></td></tr></table>
<!-- l. 435 --><p class='indent'>   Here we write <!-- l. 435 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></math>
for <!-- l. 435 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>∧</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></math> as
a shorthand. This indeed calculates the function we want, but we also have the
outcome <!-- l. 436 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>z</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></math>
still floating around. We get rid of this by ‘undoing’ the operations done to it. As
a Toffoli is its own inverse, this is easy enough: </p><table class='equation'><tr><td>
<!-- l. 437 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 437 --><object id='x11-224004r48' data="svgs/eq-And-3-additional-bit-cancel.svg" alt="diagram of eq:And-3-additional-bit-cancel" class="svg-diagram"></object></td><td class='eq-no'>(9.48)</td></tr></table>
<!-- l. 440 --><p class='indent'>   In general, let’s assume that <!-- l. 440 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math>
is given to us as a sequence of AND, OR and NOT operations since of course any
Boolean function can be decomposed into these operations. For simplicity we will assume
that <!-- l. 440 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>m</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>,
i.e. that <!-- l. 440 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math>
only has a single output we care about, although the constructions we will talk
about can be easily generalised to multiple outputs. We can then interpret
<!-- l. 441 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math> as a
DAG: a <span class='cmbx-10x-x-109'>directed acyclic graph</span>. In this graph, the input variables are the
vertices at the start, and all the other vertices correspond to operations done to
these variables or intermediate results. There is a directed edge from vertex
<!-- l. 441 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>v</mi></math> to
<!-- l. 441 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>w</mi></math> when the operation
<!-- l. 441 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>w</mi></math> uses the outcome
<!-- l. 441 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>v</mi></math>. For instance,
suppose that <!-- l. 441 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math>
is the MAJ function on 3 bits that calculates whether at least two of the bits (i.e. the
majority) are 1. One possible way we can decompose MAJ into more fundamental
operations is <!-- l. 441 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext>MAJ</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>∧</mo> <mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>∨</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>∨</mo> <mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>∧</mo> <mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>∨</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
The DAG corresponding to this decomposition is: </p><table class='equation-star'><tr><td>
<!-- l. 442 --><object data="svgs/MAJ-3-DAG.svg" alt="diagram of MAJ-3-DAG" class="svg-diagram"></object></td></tr></table>
<!-- l. 445 --><p class='indent'>   When we have this DAG, translating it to an implementation on a circuit is
straightforward. We allocate for each internal vertex a bit prepared in the
<!-- l. 445 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math> state,
we apply the operations in an order compatible with the DAG (that is, we only
apply an operation once we have done the operations associated to its parents
first), and at the end once we have calculated what we wanted to calculate, we
                                                                     

                                                                     
undo all the operations in the reverse order on all the extra bits we used. For
the DAG above this could for instance result in the following circuit:
</p><table class='equation'><tr><td>
<!-- l. 447 --><p class='indent'>
</p><!-- l. 447 --><object id='x11-224005r49' data="svgs/eq-MAJ-3-circuit.svg" alt="diagram of eq:MAJ-3-circuit" class="svg-diagram"></object></td><td class='eq-no'>(9.49)</td></tr></table>
<!-- l. 450 --><p class='indent'>   Note that the box with a <!-- l. 450 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mo class='MathClass-bin' stretchy='false'>∨</mo></math>
can be implemented using a Toffoli and some NOT gates using de Morgan’s rule.
We see that each operation is applied to a fresh 0 bit, before finally getting the
calculation we want in the final bit. We then repeat all the operations we have
done in reverse order to undo our temporary calculations. We don’t actually have
to wait until the end to undo operations. We can do this as soon as an
intermediate calculation is no longer needed. After this uncomputation this bit is
then put back into the 0 state, so that we can reuse it for additional
computations. This hence results in needing fewer additional bits. For instance:
</p><table class='equation'><tr><td>
<!-- l. 453 --><p class='indent'>
</p><!-- l. 453 --><object id='x11-224006r50' data="svgs/MAJ-3-circuit-fewer.svg" alt="diagram of MAJ-3-circuit-fewer" class="svg-diagram"></object></td><td class='eq-no'>(9.50)</td></tr></table>
<!-- l. 456 --><p class='indent'>   Here we could uncompute one intermediate calculation early in order to save
one bit in comparison to Eq. (<a href='#x11-224005r49'>9.49<!-- tex4ht:ref: eq:MAJ-3-circuit  --></a>). The number of additional bits we need to
calculate a function corresponding to a DAG hence doesn’t depend on the
number of vertices in the DAG, but rather on the amount of computations we
have to ‘keep in memory’. But suppose we want to reduce the number of
additional bits as much as possible, could we do even better? In order to do so,
we would need to free up memory that contains computations that we will need
                                                                     

                                                                     
later. This means that we will have to recompute these when needed. Finding
optimal trade-offs in uncomputing the right things and allocating the
bits you have smartly is an interesting problem, but also a bit beyond
what we can discuss in this book. See the References of this chapter
for some more pointers. But there is another trick we can exploit to
reduce the cost of implementation. This is based on the observation that
calculating XORs is much cheaper than calculating ANDs, since calculating an
AND requires a Toffoli, while calculating an XOR requires a CNOT. So
instead of allocating a new bit for every operation, we can decide to only
allocate a bit for every AND, and do all the XORs ‘in place’, uncomputing
these immediately after we are done using the outcome. This means we
will need to do more XOR operations, but will require less additional
bits. For example, another way we could write the MAJ function is as
</p><table class='equation'><tr><td>
<!-- l. 460 --><p class='indent'>
</p><!-- l. 460 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
             <mstyle class='label' id='x11-224007r51'></mstyle><!-- endlabel --><mstyle class='text'><mtext>MAJ</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>∧</mo> <mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo>
</mrow></math></td><td class='eq-no'>(9.51)</td></tr></table>
<!-- l. 463 --><p class='indent'>   (to see why this works, do a case distinction on
<!-- l. 463 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub></math>). We can
then store <!-- l. 463 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></math>
in the <!-- l. 463 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub></math> bit,
store <!-- l. 463 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub></mrow></math> in
the <!-- l. 463 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub></math> bit,
and apply a Toffoli to calculate their AND. Then undoing the XORs, we have the
<!-- l. 463 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub></math> value
available to do the final XOR: </p><table class='equation'><tr><td>
<!-- l. 464 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 464 --><object id='x11-224008r52' data="svgs/MAJ-3-circuit-XORs.svg" alt="diagram of MAJ-3-circuit-XORs" class="svg-diagram"></object></td><td class='eq-no'>(9.52)</td></tr></table>
<!-- l. 467 --><p class='indent'>   Well this circuit is certainly a lot smaller! It only requires one Toffoli gate and
one additional bit. In fact, using this trick, the cost of implementing a classical
function depends on its <span class='cmbx-10x-x-109'>multiplicative complexity</span>, the number of
AND operations needed to write it down. But what if we <span class='cmti-10x-x-109'>really </span>don’t
want to use additional bits? What can we do in just the space of the
inputs? As it turns out, quite a lot. It turns out that we can decompose
any classical reversible function into just many-controlled Toffoli gates
without using <span class='cmti-10x-x-109'>any </span>ancillae. The details are a little technical, and the result
actually not that practically useful, so we refer to Section* <a href='#from-truth-tables-to-toffolis'>9.7.1<!-- tex4ht:ref: sec:reversible-cycles  --></a> for the
details.
</p>
   <h3 class='sectionHead' id='constructing-toffoli-gates-with-many-controls'><span class='titlemark'>9.4   </span> <a id='x11-2250009.4'></a>Constructing Toffoli gates with many controls</h3>
<!-- l. 471 --><p class='noindent'>Toffoli gates with many controls form a core part of many algorithms, and as we
saw in the previous section, they are also essential in constructing arbitrary
classical reversible circuits. In this section we will study several ways in which we
can decompose Toffoli gates with many controls into Toffoli gates with fewer
controls. This is necessary to do, because most physical architectures do not have
many-controlled Toffoli gates as native operations, and so they must be
decomposed into more elementary building blocks. We could do this directly
using the results from Sections <a href='#diagonal-controlled-gates-and-phase-polynomials'>9.1.2<!-- tex4ht:ref: sec:diagonal-controlled-gates  --></a> and <a href='#fourier-transforming-diagonal-unitaries'>9.1.3<!-- tex4ht:ref: sec:graphical-ft  --></a>, but these require an exponential
number of gates in the number of controls, and so this is not efficient. In this
section we will work through several ways to decompose a Toffoli with
<!-- l. 473 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
controls into a circuit consisting of a polynomial number of regular Toffolis with
2 controls. These Toffolis can then further be decomposed into CNOTs and
single-qubit unitaries. It turns out that to do this we need to have at least one
ancilla available (the proof for this you can find in Section* <a href='#from-truth-tables-to-toffolis'>9.7.1<!-- tex4ht:ref: sec:reversible-cycles  --></a>). So let’s
assume we have an additional bit available. For concreteness, suppose we wish to
construct the Toffoli gate with 3 controls: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 476 --><object data="svgs/Tof-3-additional-bit.svg" alt="diagram of Tof-3-additional-bit" class="svg-diagram"></object></td></tr></table>
<!-- l. 479 --><p class='indent'>   This actually calculates a function very similar to Eq. (<a href='#x11-224004r48'>9.48<!-- tex4ht:ref: eq:And-3-additional-bit-cancel  --></a>), but let’s think
through it again how to construct this. First, suppose for simplicity that we knew
the extra bit was supplied to us in the 0 state. Then we can use it to
store an intermediate result, which we can then use in a later operation:
</p><table class='equation'><tr><td>
<!-- l. 481 --><p class='indent'>
</p><!-- l. 481 --><object id='x11-225001r53' data="svgs/Tof-3-burnable-bit.svg" alt="diagram of Tof-3-burnable-bit" class="svg-diagram"></object></td><td class='eq-no'>(9.53)</td></tr></table>
<!-- l. 484 --><p class='indent'>   We indeed get the correct result on the target bit! Unfortunately, we have
now polluted the state of our extra bit, so we wouldn’t be able to apply this trick
again. We have ‘burned’ this resource. We can fix this issue by cleaning up after
ourselves. Luckily, a Toffoli is self-inverse and we haven’t changed the state of the
<!-- l. 485 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>x</mi></math> and
<!-- l. 485 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>y</mi></math> bits,
so this clean-up is easy: </p><table class='equation'><tr><td>
<!-- l. 486 --><p class='indent'>
</p><!-- l. 486 --><object id='x11-225002r54' data="svgs/eq-tof-3-zeroed.svg" alt="diagram of eq:tof-3-zeroed" class="svg-diagram"></object></td><td class='eq-no'>(9.54)</td></tr></table>
                                                                     

                                                                     
<!-- l. 489 --><p class='indent'>   But suppose we didn’t know that the bit was supplied to us in the 0
state (maybe because we aren’t sure the previous person cleaned up after
themselves...), how do we implement the gate we want? In this case, a picture is
worth more than a thousand words: </p><table class='equation'><tr><td>
<!-- l. 490 --><p class='indent'>
</p><!-- l. 490 --><object id='x11-225003r55' data="svgs/eq-tof-3-garbage.svg" alt="diagram of eq:tof-3-garbage" class="svg-diagram"></object></td><td class='eq-no'>(9.55)</td></tr></table>
<!-- l. 493 --><p class='indent'>   Here <!-- l. 493 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>t</mi></mrow><mrow><mi>′</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>t</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi mathvariant='italic'>zb</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>b</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi mathvariant='italic'>xy</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>t</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi mathvariant='italic'>zb</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi mathvariant='italic'>zb</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi mathvariant='italic'>zxy</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>t</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi mathvariant='italic'>xyz</mi></mrow></math> is
exactly what we want. The reason this works is because we apply the operation to the target
<!-- l. 494 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>t</mi></math> twice, so that the
dependency on <!-- l. 494 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>b</mi></math>
disappears: the first Toffoli puts the information about
<!-- l. 494 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>b</mi></math> into
<!-- l. 494 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>t</mi></math>,
the second Toffoli changes the information in
<!-- l. 494 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>b</mi></math>, and then the final Toffoli
cancels the value of <!-- l. 494 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>b</mi></math>
in <!-- l. 494 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>t</mi></math>,
leaving only the information we wanted to put into it. This
construction didn’t clean up after itself though, as it left the value in
<!-- l. 495 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>b</mi></math>
changed, so lets add an additional Toffoli to get the construction we want:
</p><table class='equation'><tr><td>
<!-- l. 496 --><p class='indent'>
</p><!-- l. 496 --><object id='x11-225004r56' data="svgs/eq-Tof-3-borrowed.svg" alt="diagram of eq:Tof-3-borrowed" class="svg-diagram"></object></td><td class='eq-no'>(9.56)</td></tr></table>
                                                                     

                                                                     
<!-- l. 499 --><p class='indent'>   So we have constructed a 3-controlled Toffoli using 4 regular Toffoli gates and
one additional bit. This additional bit was provided to us in an unknown state,
and was left at the end in that same unknown state, so on the right-hand side of
Eq. (<a href='#x11-225004r56'>9.56<!-- tex4ht:ref: eq:Tof-3-borrowed  --></a>) it looks like we haven’t even touched this bit. Its presence was
however crucial to the success of this procedure as the argument of the previous
section on the impossibility of realising many-controlled Toffolis from
regular ones showed. We will call such a bit a <span class='cmbx-10x-x-109'>borrowed bit</span>. While the
state of borrowed bits is not changed, their presence can serve as an
important catalyst for certain constructions (as Eq. (<a href='#x11-225004r56'>9.56<!-- tex4ht:ref: eq:Tof-3-borrowed  --></a>) shows). The
constructions above are not reserved to just regular 2-controlled Toffoli gates.
They in fact work for Toffoli gates with an arbitrary number of controls:
</p><table class='equation'><tr><td>
<!-- l. 503 --><p class='indent'>
</p><!-- l. 503 --><object id='x11-225005r57' data="svgs/eq-Tof-n-borrowed.svg" alt="diagram of eq:Tof-n-borrowed" class="svg-diagram"></object></td><td class='eq-no'>(9.57)</td></tr></table>
   <div class='newtheorem'>
<!-- l. 506 --><p class='noindent'><span class='head'>
<a id='x11-225006r8'></a>
<span class='cmbx-10x-x-109'>Exercise 9.8.</span>  </span>Prove   Eq. (<a href='#x11-225005r57'>9.57<!-- tex4ht:ref: eq:Tof-n-borrowed  --></a>)   using   the   rules   for   H-boxes   of
Section <a href='#rules-for-the-hbox'>9.2.2<!-- tex4ht:ref: sec:zh  --></a>.
</p>
   </div>
<!-- l. 508 --><p class='indent'>    We can iterate this procedure. For instance, starting with a Toffoli with 5
controls, we use Eq. (<a href='#x11-225005r57'>9.57<!-- tex4ht:ref: eq:Tof-n-borrowed  --></a>) to decompose it into four Toffoli gates with 3 controls each
(pick <!-- l. 509 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>3</mn></mrow></math>
and <!-- l. 509 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>m</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>2</mn></mrow></math>).
Then each of those we decompose into four standard Toffoli’s each: </p><table class='equation'><tr><td>
<!-- l. 510 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 510 --><object id='x11-225007r58' data="svgs/Tof-5-decomposed.svg" alt="diagram of Tof-5-decomposed" class="svg-diagram"></object></td><td class='eq-no'>(9.58)</td></tr></table>
<!-- l. 513 --><p class='indent'>   We have marked the places were a bit has been borrowed with a dashed box
on the right-hand side. Note that we constantly switch which bit is borrowed.
That’s the beauty of this system: since the borrowed bit can be in any state and
is returned to the same state, we can pick any bit to be the borrowed
one. You might have noticed that the number of Toffolis required blows
up quite a lot as the number of controls increases. In fact, if we have
<!-- l. 515 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> controls
(assuming <!-- l. 515 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
is odd for simplicity) then this splits into four gates with
<!-- l. 515 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>k</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn></mrow></math> controls. So
if we take <!-- l. 516 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn></mrow></math>,
then after the first step we have Toffolis with
<!-- l. 516 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn></mrow></math> controls. So doing
this <!-- l. 516 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math> times we are left
with <!-- l. 516 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mn>4</mn></mrow><mrow><mi>n</mi></mrow></msup></math> regular Toffolis.
As <!-- l. 516 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mn>4</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>≤</mo> <msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>k</mi></mrow><mrow><mn>2</mn></mrow></msup></mrow></math>, we see that in
general we require <!-- l. 516 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>k</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
Toffolis. It turns out we can do better than an
<!-- l. 517 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>k</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> scaling
in the number of controls. To do this we need the observation that after the first
split in Eq. (<a href='#x11-225005r57'>9.57<!-- tex4ht:ref: eq:Tof-n-borrowed  --></a>) we have many more borrowed bits available. So let’s try to use
them! To see how this works we will again first look at a construction where the
additional bits are supplied in the 0 state and we don’t care in which state we
leave them. It turns out that to apply this trick to decompose a Toffoli with
<!-- l. 518 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> controls,
we need <!-- l. 518 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>2</mn></mrow></math>
additional bits. Let’s look at the simplest example:
<!-- l. 518 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>4</mn></mrow></math>.
</p><table class='equation'><tr><td>
<!-- l. 519 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 519 --><object id='x11-225008r59' data="svgs/Tof-4-burnable.svg" alt="diagram of Tof-4-burnable" class="svg-diagram"></object></td><td class='eq-no'>(9.59)</td></tr></table>
<!-- l. 522 --><p class='indent'>   We have interspersed the 0 bits throughout the circuit, to make it look a bit
nicer. We see that we can simply build a larger and larger product of bits by
storing the intermediate results in these additional bits we have lying
around. If we wanted to return the bits to their zero state, we can just
add another staircase of Toffoli gates to undo the action done to them:
</p><table class='equation'><tr><td>
<!-- l. 525 --><p class='indent'>
</p><!-- l. 525 --><object id='x11-225009r60' data="svgs/eq-Tof-4-zeroed.svg" alt="diagram of eq:Tof-4-zeroed" class="svg-diagram"></object></td><td class='eq-no'>(9.60)</td></tr></table>
<!-- l. 528 --><p class='indent'>   But what if we didn’t know that the bits were 0. Then we can apply a similar
trick to what we did in Eq. (<a href='#x11-225003r55'>9.55<!-- tex4ht:ref: eq:tof-3-garbage  --></a>): we reverse the direction of the staircase
(compare Eq. (<a href='#x11-225003r55'>9.55<!-- tex4ht:ref: eq:tof-3-garbage  --></a>) with Eq. (<a href='#x11-225002r54'>9.54<!-- tex4ht:ref: eq:tof-3-zeroed  --></a>) where the order of the Toffoli gates was also
reversed): </p><table class='equation'><tr><td>
<!-- l. 529 --><p class='indent'>
</p><!-- l. 529 --><object id='x11-225010r61' data="svgs/Tof-4-garbage.svg" alt="diagram of Tof-4-garbage" class="svg-diagram"></object></td><td class='eq-no'>(9.61)</td></tr></table>
<!-- l. 532 --><p class='indent'>   Note that the last two Toffoli gates cancel out respectively the
<!-- l. 532 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>az</mi></mrow></math> and
<!-- l. 532 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>bw</mi></mrow></math> term.
Finally, if we want to make these bits borrowed, then we need to undo the Toffoli
gates that affect them, which means we need to add another staircase:
                                                                     

                                                                     
</p><table class='equation'><tr><td>
<!-- l. 534 --><p class='indent'>
</p><!-- l. 534 --><object id='x11-225011r62' data="svgs/eq-Tof-4-borrowed.svg" alt="diagram of eq:Tof-4-borrowed" class="svg-diagram"></object></td><td class='eq-no'>(9.62)</td></tr></table>
<!-- l. 537 --><p class='indent'>   If instead of 4 controls and 2 borrowed bits we had
<!-- l. 537 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mn>4</mn></mrow></math> controls
and <!-- l. 537 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>2</mn></mrow></math> bits,
then we could simply make the staircases longer. The first staircase ’going up’ has
<!-- l. 537 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math> gates, then the one going
down has <!-- l. 537 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>2</mn></mrow></math> gates, the second
going up also has <!-- l. 537 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>2</mn></mrow></math> gates, and
the final going down has <!-- l. 537 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>3</mn></mrow></math>
gates, for a total of <!-- l. 537 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>4</mn><mi>k</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>8</mn></mrow></math>
Toffoli gates. If we had this many borrowed bits lying around we can hence decompose a
<!-- l. 538 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>-controlled
Toffoli in <!-- l. 538 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>k</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
regular Toffoli gates! So let’s get back to the case where we start out with a single
borrowed bit. Then we can apply the trick of Eq. (<a href='#x11-225005r57'>9.57<!-- tex4ht:ref: eq:Tof-n-borrowed  --></a>) once to decompose our
<!-- l. 539 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>-controlled Toffoli into smaller
Toffoli gates. If <!-- l. 539 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> is odd, we
split it into four <!-- l. 539 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>k</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mn>1</mn></mrow>
  <mrow><mn>2</mn></mrow></mfrac>  </mrow></math>-controlled
Toffoli gates. We then have <!-- l. 539 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>k</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mn>1</mn></mrow>
  <mrow><mn>2</mn></mrow></mfrac>  </mrow></math>
borrowed bits available for each of these Toffoli gates. If instead
<!-- l. 539 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
is even, then we split into two Toffoli gates with
<!-- l. 539 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mfrac><mrow><mi>k</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac></math> controls and two with
<!-- l. 539 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>k</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn></mrow></math> controls. In this case
we will have at least <!-- l. 539 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mfrac><mrow><mi>k</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac></math>
borrowed bits available. In both cases this is enough space to apply the
construction of Eq. (<a href='#x11-225011r62'>9.62<!-- tex4ht:ref: eq:Tof-4-borrowed  --></a>). Each of those Toffoli gates can then be decomposed
into <!-- l. 539 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-rel' stretchy='false'>≈</mo> <mn>4</mn> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>k</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>2</mn><mi>k</mi></mrow></math>
gates. As we have four of them, the final cost is then
<!-- l. 539 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>8</mn><mi>k</mi></mrow></math>
Toffoli gates.
</p>
                                                                     

                                                                     
   <div class='newtheorem'>
<!-- l. 540 --><p class='noindent'><span class='head'>
<a id='x11-225012r1'></a>
<span class='cmbx-10x-x-109'>Proposition 9.4.1.</span>  </span>A single <!-- l. 541 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>-controlled
Toffoli can be decomposed into a circuit of fewer than <!-- l. 541 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>8</mn><mi>k</mi></mrow></math>
regular Toffoli gates as long as we have a single borrowed bit available.
</p>
   </div>
<!-- l. 542 --><p class='indent'>    While it might be possible to improve the constants, this is asymptotically optimal,
as we certainly need to at least touch every qubit involved with a Toffoli, and this
requires <!-- l. 543 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>k</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
gates.
</p>
   <div class='newtheorem'>
<!-- l. 544 --><p class='noindent'><span class='head'>
<a id='x11-225013r9'></a>
<span class='cmbx-10x-x-109'>Exercise 9.9.</span>  </span>In Eq. (<a href='#x11-225009r60'>9.60<!-- tex4ht:ref: eq:Tof-4-zeroed  --></a>) each of the Toffoli gates used a qubit that the
previous gate also used so that its circuit depth is also linear in the number
of controls of the Toffoli we are constructing. But it is possible to do it more
efficiently. Show that we can implement the <!-- l. 545 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>-controlled
Toffoli in logarithmic depth using <!-- l. 545 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>k</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
regular Toffoli gates if we are supplied <!-- l. 545 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>2</mn></mrow></math>
bits in the 0 state, and make sure the ancilla bits are returned to the 0 state at
the end. You may restrict to <!-- l. 545 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mn>2</mn></mrow><mrow><mi>m</mi></mrow></msup></mrow></math>
for simplicity.
</p>
   </div>
<!-- l. 546 --><p class='indent'>
</p>
   <h4 class='subsectionHead' id='quantum-tricks-for-optimising-toffoli-gates'><span class='titlemark'>9.4.1   </span> <a id='x11-2260009.4.1'></a>Quantum tricks for optimising Toffoli gates</h4>
<!-- l. 551 --><p class='noindent'>So far we have only studied classical functions using classical means. But
this is of course a book about quantum computing, so let’s see what
we can do once we’re allowed to use quantum gates and techniques to
construct these classical functions. In this section we will find better
ways to decompose certain combinations of Toffoli gates, so that we
can implement these more cheaply as quantum circuits. First, recall
                                                                     

                                                                     
that we could decompose the Toffoli gate into a combination of seven
<!-- l. 553 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates
and phase gadgets: </p><table class='equation'><tr><td>
<!-- l. 554 --><p class='indent'>
</p><!-- l. 554 --><object id='x11-226001r63' data="svgs/Tof-circ.svg" alt="diagram of Tof-circ" class="svg-diagram"></object></td><td class='eq-no'>(9.63)</td></tr></table>
<!-- l. 557 --><p class='indent'>   We have here grouped the gates in a suggestive way, with all the gates on the
control qubits together. We can then recognise this as the shape of a
<!-- l. 557 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>CZ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> <mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi mathvariant='italic'>CS</mi></mrow></math>
gate; see Eq. (<a href='#x11-218003r4'>9.4<!-- tex4ht:ref: eq:cz-alpha-decomposed  --></a>). Hence, while a Toffoli gate requires 7
<!-- l. 558 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates, if we can somehow
combine this with a <!-- l. 558 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>C</mi><msup><mrow><mi>S</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi mathvariant='italic'>CZ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> <mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
gate, then 3 of those <!-- l. 558 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates cancel and we only require four of them: </p><table class='equation'><tr><td>
<!-- l. 559 --><p class='indent'>
</p><!-- l. 559 --><object id='x11-226002r64' data="svgs/eq-Tof-reduced.svg" alt="diagram of eq:Tof-reduced" class="svg-diagram"></object></td><td class='eq-no'>(9.64)</td></tr></table>
<!-- l. 562 --><p class='indent'>   As we will see in Chapter <a href='main_htmlch11.html#quantum-error-correction'>11<!-- tex4ht:ref: ch:qec  --></a>, <!-- l. 562 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates are actually quite expensive to implement in the
fault-tolerant setting, and so finding ways to reduce the
<!-- l. 562 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>-count is an
important thing to try to do (and we will find more advanced ways to do so in Chapter <a href='main_htmlch10.html#cliffordt'>10<!-- tex4ht:ref: ch:clifford-t  --></a>.
But even without this consideration, getting rid of this additional phase gadget needed
for the <!-- l. 562 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>CS</mi></mrow></math>
gate means fewer entangling gates are needed. Now, usually we don’t have spare
<!-- l. 563 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>CS</mi></mrow></math> gates lying
                                                                     

                                                                     
around to cancel <!-- l. 563 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates with, but we can introduce them in pairs at the cost of a Clifford:
<!-- l. 563 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>I</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>C</mi><msup><mrow><mi>S</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mo class='MathClass-bin' stretchy='false'>∘</mo> <mi mathvariant='italic'>CZ</mi> <mo class='MathClass-bin' stretchy='false'>∘</mo> <mi>C</mi><msup><mrow><mi>S</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup></mrow></math>. This
means that whenever we have a pair of Toffoli gates that have the same two
control wires and nothing acting in between them on those wires, that we can use
this trick to reduce the T-count. In the previous section we saw many examples
of such a pair of Toffoli gates. For instance, we can use it to reduce the cost of
Eq. (<a href='#x11-225002r54'>9.54<!-- tex4ht:ref: eq:tof-3-zeroed  --></a>): </p><table class='equation'><tr><td>
<!-- l. 565 --><p class='indent'>
</p><!-- l. 565 --><object id='x11-226003r65' data="svgs/eq-matching-Tof-T-reduce.svg" alt="diagram of eq:matching-Tof-T-reduce" class="svg-diagram"></object></td><td class='eq-no'>(9.65)</td></tr></table>
<!-- l. 568 --><p class='indent'>   Now instead of the construction costing
<!-- l. 568 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>3</mn> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mn>7</mn> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>21</mn></mrow></math>
<!-- l. 568 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates, it
costs <!-- l. 568 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>2</mn> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mn>4</mn> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>7</mn> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>15</mn></mrow></math>
<!-- l. 568 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates! Additionally, since we have to synthesise fewer phase gadgets, the
construction will also require less two-qubit gates. Note that this trick is
not reserved to just the Toffoli gates that share two controls. Sharing a
control and a target also works. For instance, starting with Eq. (<a href='#x11-225003r55'>9.55<!-- tex4ht:ref: eq:tof-3-garbage  --></a>):
</p><table class='equation'><tr><td>
<!-- l. 571 --><p class='indent'>
</p><!-- l. 571 --><object id='x11-226004r66' data="svgs/Tof-3-garbage-CS-reduce.svg" alt="diagram of Tof-3-garbage-CS-reduce" class="svg-diagram"></object></td><td class='eq-no'>(9.66)</td></tr></table>
<!-- l. 574 --><p class='indent'>   Now we have a pair of Toffoli’s sharing two controls and we can apply the trick
as before. But what if we don’t have a pair of Toffoli gates with matching controls or
                                                                     

                                                                     
targets, what can we do then? Is there any way we can reduce the number of
<!-- l. 575 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates we need?
Well, there is some good news and some bad news. The bad news is that all possible three-qubit
Clifford+<!-- l. 576 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> circuits
with up to six <!-- l. 576 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates have been enumerated by brute force methods, and none of those
circuits were equal to a Toffoli. So there is no circuit with fewer than seven
<!-- l. 576 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates
that implements a Toffoli. So what is the good news? Well, this enumeration only
looked at <span class='cmti-10x-x-109'>unitary </span>circuits. It doesn’t say anything about circuits involving
ancillae and measurements. It turns out that if we do allow non-unitary
constructions that we can do better. To see how we can do this, let’s take another
look at Eq. (<a href='#x11-226002r64'>9.64<!-- tex4ht:ref: eq:Tof-reduced  --></a>), but now using H-boxes. To simplify the presentation a
little, we will be working with a CCZ gate instead of a Toffoli, and a
<!-- l. 578 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>CS</mi></mrow></math> gate
instead of a <!-- l. 578 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>C</mi><msup><mrow><mi>S</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup></mrow></math>
gate. So let’s see how we could rewrite this construction: </p><table class='equation'><tr><td>
<!-- l. 579 --><p class='indent'>
</p><!-- l. 579 --><object id='x11-226005r67' data="svgs/CCZ-CS-absorb.svg" alt="diagram of CCZ-CS-absorb" class="svg-diagram"></object></td><td class='eq-no'>(9.67)</td></tr></table>
<!-- l. 582 --><p class='indent'>   Okay, this first step was obvious: there are spiders of the same colour
connected to each other, so we should fuse them. But now it is a little
less obvious. However, note that we now have two H-boxes that share
two Z-spiders. This looks a lot like the right-hand side of Eq. (<a href='#x11-222010r30'>9.30<!-- tex4ht:ref: eq:ZH-bialgebra  --></a>). In
fact, by doing some clever unfusion, we can actually apply this rule:
</p><table class='equation'><tr><td>
<!-- l. 583 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 583 --><object id='x11-226006r68' data="svgs/eq-CCZ-CS-absorb2.svg" alt="diagram of eq:CCZ-CS-absorb2" class="svg-diagram"></object></td><td class='eq-no'>(9.68)</td></tr></table>
<!-- l. 586 --><p class='indent'>   Here in the last step we used the the fact that an H-box with
a single wire and a complex phase is just a spider (Eq. (<a href='#x11-222001r21'>9.21<!-- tex4ht:ref: eq:H-state-as-Z  --></a>)):
<!-- l. 586 --><img src="svgs/H-a-state.svg" alt="diagram of H-a-state" class="inline-diagram" /> (and of
course <!-- l. 588 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>i</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iπ</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn></mrow></msup></mrow></math>).
Okay, this looks promising! A CCZ followed by a CS, which
is cheaper than just a CCZ, corresponds to a CCZ with this
<!-- l. 589 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>X</mi><mo class='MathClass-open' stretchy='false'>(</mo><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> <mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
on one of its legs. So how do we transform this into something that
looks more like a circuit? The answer is that we have to view the
<!-- l. 590 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>X</mi><mo class='MathClass-open' stretchy='false'>(</mo><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> <mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>-phase
as happening on its own ancilla qubit. We do this by introducing some identity
spiders and unfusing: </p><table class='equation'><tr><td>
<!-- l. 591 --><p class='indent'>
</p><!-- l. 591 --><object id='x11-226007r69' data="svgs/CCZ-CS-absorb3.svg" alt="diagram of CCZ-CS-absorb3" class="svg-diagram"></object></td><td class='eq-no'>(9.69)</td></tr></table>
<!-- l. 594 --><p class='indent'>   This is now a post-selected circuit (we’ll get to how to deal with the ‘wrong’
measurement outcome later), where the only non-Clifford gate is the CCZ. So we
have managed to get rid of the CS gate! But of course we want to go the other
way: instead of removing a CS gate, we want to introduce one. We can however
do this procedure in the opposite direction quite easily. The crucial step
happened in Eq. (<a href='#x11-226006r68'>9.68<!-- tex4ht:ref: eq:CCZ-CS-absorb2  --></a>) where we transformed the CS gate into an X-phase on
the other side of the H-box. It turns out that it is often useful to apply this
rewrite rule in the opposite direction, so let’s write it down explicitly:
</p><table class='equation'><tr><td>
<!-- l. 597 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 597 --><object id='x11-226008r70' data="svgs/eq-had-phase-commute.svg" alt="diagram of eq:had-phase-commute" class="svg-diagram"></object></td><td class='eq-no'>(9.70)</td></tr></table>
<!-- l. 600 --><p class='indent'>   So now, starting with a CCZ, let’s introduce some X-phases, so that we
can push one of them through the H-box to make a CS gate appear:
</p><table class='equation'><tr><td>
<!-- l. 601 --><p class='indent'>
</p><!-- l. 601 --><object id='x11-226009r71' data="svgs/eq-CCZ-generate-CS.svg" alt="diagram of eq:CCZ-generate-CS" class="svg-diagram"></object></td><td class='eq-no'>(9.71)</td></tr></table>
<!-- l. 604 --><p class='indent'>   Now we could decompose the combined CCZ and CS gate using just 4
<!-- l. 604 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates. So by
introducing an ancilla, we can make a post-selected circuit that implements a CCZ gate
using fewer <!-- l. 604 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates than is possible with any unitary circuit. It turns out we can get rid of the
post-selection as well. If we get the wrong measurement outcome, then we can
push the resulting NOT gate back through the CCZ using Eq. (<a href='#x11-226008r70'>9.70<!-- tex4ht:ref: eq:had-phase-commute  --></a>):
</p><table class='equation'><tr><td>
<!-- l. 606 --><p class='indent'>
</p><!-- l. 606 --><object id='x11-226010r72' data="svgs/CCZ-postselect-correct.svg" alt="diagram of CCZ-postselect-correct" class="svg-diagram"></object></td><td class='eq-no'>(9.72)</td></tr></table>
<!-- l. 609 --><p class='indent'>   So the wrong measurement outcome leads to an additional CZ gate applied
after the circuit. Since we know the measurement outcome, we can correct
for this by applying the inverse of a CZ gate. This inverse is of course
also a CZ gate. As this is Clifford, this does not increase the number of
                                                                     

                                                                     
<!-- l. 609 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates
we need. So we can indeed deterministically implement a CCZ gate using four
<!-- l. 609 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates.
It turns out we can do something similar, when we have a ‘compute-uncompute’
pair of Toffoli gates. That is, a pair of Toffoli gates that undo each others action,
such that the target is not changed in the mean time. Let’s use Eq. (<a href='#x11-225002r54'>9.54<!-- tex4ht:ref: eq:tof-3-zeroed  --></a>) again
as an example, but with the qubits rearranged to make the presentation a bit
nicer: </p><table class='equation'><tr><td>
<!-- l. 612 --><p class='indent'>
</p><!-- l. 612 --><object id='x11-226011r73' data="svgs/eq-Tof-3-Gidney.svg" alt="diagram of eq:Tof-3-Gidney" class="svg-diagram"></object></td><td class='eq-no'>(9.73)</td></tr></table>
<!-- l. 615 --><p class='indent'>   We see that whereas we had three Toffoli gates in the start, we ended
up with just two of them in the end, as the pair that computed and
uncomputed the AND of two bits was ‘fused’ together. This unitary
is again post-selected, but on the wrong outcome we can push out the
<!-- l. 615 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math> phase outwards to
become a CZ and <!-- l. 615 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math>
correction.
</p>
   <div class='newtheorem'>
<!-- l. 616 --><p class='noindent'><span class='head'>
<a id='x11-226012r10'></a>
<span class='cmbx-10x-x-109'>Exercise 9.10.</span>  </span>Prove that the correction operator of Eq. (<a href='#x11-226011r73'>9.73<!-- tex4ht:ref: eq:Tof-3-Gidney  --></a>) for the
<!-- l. 617 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext class='MathClass-open' stretchy='false'>⟨−|</mtext></mrow></math>
measurement outcome is indeed <!-- l. 617 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext>CZ</mtext></mstyle> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>Z</mi></mrow></math>.
</p>
   </div>
<!-- l. 618 --><p class='indent'>    So while Eq. (<a href='#x11-226003r65'>9.65<!-- tex4ht:ref: eq:matching-Tof-T-reduce  --></a>) allowed us to reduce the cost of a matching
pair of Toffoli gates from 14 to 8, with Eq. (<a href='#x11-226011r73'>9.73<!-- tex4ht:ref: eq:Tof-3-Gidney  --></a>) we can reduce it even
further to just 4! But even if we don’t care about decomposing into
<!-- l. 619 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates,
we see that this construction requires just a single Toffoli per compute-uncompute
                                                                     

                                                                     
pair, as the uncomputation can instead be done by a measurement and a
correction. Note that this form of an optimised compute-uncompute
pair of Toffolis is often used in the context where they are targetting
a zeroed ancilla which is ‘cleaned up’ at the end. In that case we can
simplify the expression a bit more, and for concreteness we will add in the
<!-- l. 620 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>X</mi><mo class='MathClass-open' stretchy='false'>(</mo><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> <mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
phases to make it clear that this construction indeed only requires 4
<!-- l. 620 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates:
</p><table class='equation'><tr><td>
<!-- l. 621 --><p class='indent'>
</p><!-- l. 621 --><object id='x11-226013r74' data="svgs/eq-Tof-Gidney-zeroed.svg" alt="diagram of eq:Tof-Gidney-zeroed" class="svg-diagram"></object></td><td class='eq-no'>(9.74)</td></tr></table>
   <div class='newtheorem'>
<!-- l. 624 --><p class='noindent'><span class='head'>
<a id='x11-226014r11'></a>
<span class='cmbx-10x-x-109'>Exercise 9.11.</span>  </span> Prove a version of Eq. (<a href='#x11-226013r74'>9.74<!-- tex4ht:ref: eq:Tof-Gidney-zeroed  --></a>), but where there are is an
additional pair of CNOTs involved in the computation-uncomputation:
</p><table class='equation'><tr><td>
<!-- l. 626 --><p class='indent'>
</p><!-- l. 626 --><object id='x11-226015r75' data="svgs/Gidneyed-carry.svg" alt="diagram of Gidneyed-carry" class="svg-diagram"></object></td><td class='eq-no'>(9.75)</td></tr></table>
<!-- l. 629 --><p class='indent'>   What is the correction operation for the post-selected ancilla?
                                                                     

                                                                     
</p>
   </div>
<!-- l. 630 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 631 --><p class='noindent'><span class='head'>
<a id='x11-226016r12'></a>
<span class='cmbx-10x-x-109'>Exercise 9.12.</span>  </span>Show that we can implement a CS gate using a single Toffoli
and
<!-- l. 632 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
gate, where we measure an ancilla and perform a CZ correction:
</p>
<div class='center'>
<!-- l. 634 --><p class='noindent'>
</p><!-- l. 635 --><p class='noindent'><object data="svgs/Gidneyed-CS.svg" alt="diagram of Gidneyed-CS" class="svg-diagram"></object> </p></div>
<!-- l. 638 --><p class='indent'>   Does a construction like this also work for any other controlled-phase gates
apart from CS?
</p>
   </div>
<!-- l. 639 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 640 --><p class='noindent'><span class='head'>
<a id='x11-226017r13'></a>
<span class='cmbx-10x-x-109'>Exercise 9.13.</span>  </span> In this exercise we will show that we can construct the CCCZ gate (i.e. the
3-controlled <!-- l. 641 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math>
gate) using 6 <!-- l. 641 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates.
   </p><dl class='enumerate'><dt class='enumerate'>
a) </dt><dd class='enumerate'>
   <!-- l. 643 --><p class='noindent'>Prove using the ZH-calculus that the following post-selected circuit
   implements a CCCZ gate: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
   <!-- l. 644 --><object data="svgs/CCCZ-Gidney.svg" alt="diagram of CCCZ-Gidney" class="svg-diagram"></object></td></tr></table>
   <!-- l. 647 --><p class='noindent'><span class='cmti-10x-x-109'>Hint: Use Eq. </span>(<a href='#x11-226008r70'>9.70<!-- tex4ht:ref: eq:had-phase-commute  --></a>) <span class='cmti-10x-x-109'>to bring the CS gates into the H-box, and then
   combine the </span><!-- l. 647 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>π</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn></mrow></math>
   <span class='cmti-10x-x-109'>phases using an appropriate Euler decomposition of the Hadamard.</span>
   </p></dd><dt class='enumerate'>
b) </dt><dd class='enumerate'>
   <!-- l. 648 --><p class='noindent'>Find  the  correction  operator  for  if  the  measurement  got  the  wrong
   outcome instead.
   </p></dd><dt class='enumerate'>
c) </dt><dd class='enumerate'>
   <!-- l. 649 --><p class='noindent'>Conclude that we can hence deterministically implement the CCCZ gate
   using 6 <!-- l. 649 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
   gates. Hint: use Eq. (<a href='#x11-226002r64'>9.64<!-- tex4ht:ref: eq:Tof-reduced  --></a>). </p></dd></dl>
<!-- l. 651 --><p class='noindent'>Note: There is also a different way to see that this construction works. We can decompose the
phase function <!-- l. 651 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi mathvariant='italic'>xyzw</mi></mrow></msup></math>
of the CCCZ as <!-- l. 651 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iπ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi mathvariant='italic'>xy</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-open' stretchy='false'>(</mo><mi mathvariant='italic'>zw</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> <mo class='MathClass-open' stretchy='false'>(</mo><mi mathvariant='italic'>xy</mi><mo class='MathClass-bin' stretchy='false'>⊕</mo><mi mathvariant='italic'>zw</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>xy</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>zw</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup></mrow></math>
and these three phase terms correspond to the two CS gates and the
<!-- l. 651 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
gate on the ancilla (the two Toffoli gates precisely prepare the
<!-- l. 651 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>xy</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi mathvariant='italic'>zw</mi></mrow></math> state
on the ancilla).
</p>
   </div>
<!-- l. 652 --><p class='indent'>
</p>
   <h4 class='subsectionHead' id='adding-controls-to-other-quantum-gates'><span class='titlemark'>9.4.2   </span> <a id='x11-2270009.4.2'></a>Adding controls to other quantum gates</h4>
<!-- l. 654 --><p class='noindent'>Using what we’ve learned about Toffoli gates, we can also start to construct other
unitaries with many controls. The easiest construction for a many-controlled unitary
<!-- l. 655 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>,
                                                                     

                                                                     
which requires one clean ancilla, and the ability to construct a singly-controlled
<!-- l. 655 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>, is
the following: </p><table class='equation'><tr><td>
<!-- l. 656 --><p class='indent'>
</p><!-- l. 656 --><object id='x11-227001r76' data="svgs/eq-many-controlled-U-ancilla.svg" alt="diagram of eq:many-controlled-U-ancilla" class="svg-diagram"></object></td><td class='eq-no'>(9.76)</td></tr></table>
<!-- l. 659 --><p class='indent'>   We have drawn <!-- l. 659 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
here as a single-qubit unitary, but this of course works when
<!-- l. 659 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math> targets
multiple qubits as well. This is nice and all, but it still means we need to know how to
construct <!-- l. 660 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
with a single control. This might be problematic if we want to restrict our gates
to be from a particular gate set. For instance, it is not possible to construct a
controlled-<!-- l. 661 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gate without ancillae
and using only Clifford+<!-- l. 661 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates. Luckily, in this case, we can adapt Eq. (<a href='#x11-227001r76'>9.76<!-- tex4ht:ref: eq:many-controlled-U-ancilla  --></a>) for the special case of
<!-- l. 662 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>U</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>:
</p><table class='equation'><tr><td>
<!-- l. 663 --><p class='indent'>
</p><!-- l. 663 --><object id='x11-227002r77' data="svgs/eq-many-controlled-phase-ancilla.svg" alt="diagram of eq:many-controlled-phase-ancilla" class="svg-diagram"></object></td><td class='eq-no'>(9.77)</td></tr></table>
<!-- l. 666 --><p class='indent'>   The reason this works is because
<!-- l. 666 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> acts as the identity
when the input is <!-- l. 666 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>,
so that it only fires when the first Toffoli puts the ancilla into the
<!-- l. 666 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> state. Another way to look
                                                                     

                                                                     
at it, is that a <!-- l. 666 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> phase gate
is like a ‘controlled global <!-- l. 666 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iα</mi></mrow></msup></math>
phase’ gate, which applies a global phase of
<!-- l. 666 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iα</mi></mrow></msup></math>
iff its control wire (the qubit it acts on) is in the
<!-- l. 666 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> state.
Hence, Eq. (<a href='#x11-227002r77'>9.77<!-- tex4ht:ref: eq:many-controlled-phase-ancilla  --></a>) is just a special case of Eq. (<a href='#x11-227001r76'>9.76<!-- tex4ht:ref: eq:many-controlled-U-ancilla  --></a>) where the control wire <span class='cmti-10x-x-109'>is</span>
the target wire.
</p>
   <div class='newtheorem'>
<!-- l. 667 --><p class='noindent'><span class='head'>
<a id='x11-227003r14'></a>
<span class='cmbx-10x-x-109'>Exercise 9.14.</span>  </span>Prove Eq. (<a href='#x11-227002r77'>9.77<!-- tex4ht:ref: eq:many-controlled-phase-ancilla  --></a>) using the ZH-calculus.
</p>
   </div>
<!-- l. 669 --><p class='indent'>    If we want to implement a many-controlled
<!-- l. 670 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>X</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> gate, we can
realise that <!-- l. 670 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>X</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi mathvariant='italic'>HZ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi>H</mi></mrow></math>,
and that these conjugations by a unitary (like
<!-- l. 670 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math>)
commute with controls: </p><table class='equation'><tr><td>
<!-- l. 671 --><p class='indent'>
</p><!-- l. 671 --><object id='x11-227004r78' data="svgs/many-controlled-X-ancilla.svg" alt="diagram of many-controlled-X-ancilla" class="svg-diagram"></object></td><td class='eq-no'>(9.78)</td></tr></table>
<!-- l. 674 --><p class='indent'>   So now we know how to implement
<!-- l. 674 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math> and
<!-- l. 674 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>
rotations with an arbitrary number of controls. By taking the Euler decomposition
of a unitary, we can hence implement arbitrary many-controlled single-qubit
unitaries.
</p>
   <div class='newtheorem'>
                                                                     

                                                                     
<!-- l. 675 --><p class='noindent'><span class='head'>
<a id='x11-227005r2'></a>
<span class='cmbx-10x-x-109'>Proposition 9.4.2.</span>  </span>Let <!-- l. 676 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
be an <!-- l. 676 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit
unitary implemented by a circuit of <!-- l. 676 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>m</mi></math>
CNOT, <!-- l. 676 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
and <!-- l. 676 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>X</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
phase gates. Then we can construct a circuit for a <!-- l. 676 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
with <!-- l. 676 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
controls using <!-- l. 676 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi mathvariant='italic'>km</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
gates and one additional zeroed ancilla.
</p>
   </div>
<!-- l. 677 --><p class='indent'>     In Section* <a href='#level-operators'>9.7.2<!-- tex4ht:ref: sec:2-level-op  --></a> we look at <span class='cmti-10x-x-109'>2-level operators</span>, which are a class of
‘maximally controlled’ unitaries that are a useful primitive when thinking about
exact synthesis of unitaries.
</p>
   <h3 class='sectionHead' id='adders'><span class='titlemark'>9.5   </span> <a id='x11-2280009.5'></a>Adders</h3>
<!-- l. 681 --><p class='noindent'>Let’s put all we’ve learned to the test and build an efficient quantum
circuit for a certain primitive that is an important component of
many quantum algorithms: addition. Recall that we can interpret an
<!-- l. 682 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-bit number
<!-- l. 682 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℕ</mi></mrow></math> as a
<!-- l. 682 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit quantum
state <!-- l. 682 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>a</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>a</mi></mrow><mrow><mi>n</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msub><msub><mrow><mi>a</mi></mrow><mrow><mi>n</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>2</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>a</mi></mrow><mrow><mn>0</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> where the
<!-- l. 682 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>a</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> are just computational
basis states and <!-- l. 682 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup><msub><mrow><mi>a</mi></mrow><mrow><mi>n</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>2</mn></mrow></msup><msub><mrow><mi>a</mi></mrow><mrow><mi>n</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-rel' stretchy='false'>⋯</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mn>2</mn></mrow><mrow><mn>0</mn></mrow></msup><msub><mrow><mi>a</mi></mrow><mrow><mn>0</mn></mrow></msub></mrow></math>. Our goal
then now is to build a <!-- l. 682 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mn>2</mn><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>-qubit
quantum circuit we will call Add that acts as
<!-- l. 682 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext>Add</mtext></mstyle><mo class='MathClass-rel' stretchy='false'>|</mo><mi>a</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>b</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mi>a</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>a</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>b</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>. Note that here
<!-- l. 682 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>b</mi></mrow></math> is addition
of natural numbers, and not componentwise addition of bit strings! This circuit requires
<!-- l. 682 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>2</mn><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn></mrow></math> qubits because
the sum of two <!-- l. 682 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-bit
numbers requires <!-- l. 682 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn></mrow></math>
bits to write down, and hence the register containing
<!-- l. 682 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>b</mi></mrow></math> consists
of <!-- l. 682 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn></mrow></math>
qubits. We will build the circuit for Add by mimicking how you would add together
                                                                     

                                                                     
numbers by hand: by starting at the least significant digit and proceeding
upwards while keeping track of the carry. Let’s call the outcome of the addition
<!-- l. 683 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>s</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>a</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>b</mi></mrow></math>,
for sum. Calculating the least significant bit
<!-- l. 683 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>s</mi></mrow><mrow><mn>0</mn></mrow></msub></math> is very simple: it
is just <!-- l. 683 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>a</mi></mrow><mrow><mn>0</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>b</mi></mrow><mrow><mn>0</mn></mrow></msub></mrow></math>. But now
for the second bit <!-- l. 683 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>s</mi></mrow><mrow><mn>1</mn></mrow></msub></math>
we care about the carry value of the first bit. This carry bit is
<!-- l. 683 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>c</mi></mrow><mrow><mn>0</mn></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>a</mi></mrow><mrow><mn>0</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <msub><mrow><mi>b</mi></mrow><mrow><mn>0</mn></mrow></msub></mrow></math>, since it is only
non-zero if both <!-- l. 683 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>a</mi></mrow><mrow><mn>0</mn></mrow></msub></math>
and <!-- l. 683 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>b</mi></mrow><mrow><mn>0</mn></mrow></msub></math> are
<!-- l. 683 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>. The value
of <!-- l. 683 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>s</mi></mrow><mrow><mn>1</mn></mrow></msub></math> is then
the sum of <!-- l. 683 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>a</mi></mrow><mrow><mn>1</mn></mrow></msub></math>,
<!-- l. 683 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>b</mi></mrow><mrow><mn>1</mn></mrow></msub></math> and the
carry <!-- l. 683 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>c</mi></mrow><mrow><mn>0</mn></mrow></msub></math>
modulo 2: <!-- l. 683 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>s</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>a</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>b</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>c</mi></mrow><mrow><mn>0</mn></mrow></msub></mrow></math>.
That still isn’t too bad, but now we need to calculate the carry of this second bit
<!-- l. 683 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>s</mi></mrow><mrow><mn>1</mn></mrow></msub></math>, and this is
a bit more complicated, because now there are multiple ways in which the carry can be
<!-- l. 683 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>: we can either
have both <!-- l. 683 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>a</mi></mrow><mrow><mn>1</mn></mrow></msub></math>
and <!-- l. 683 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>b</mi></mrow><mrow><mn>1</mn></mrow></msub></math> be
<!-- l. 683 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>, or one of these
values and the carry <!-- l. 683 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>c</mi></mrow><mrow><mn>0</mn></mrow></msub></math>,
or all three of these values. We can however capture this in a nice
symmetric function that we have already seen: the MAJ function that
calculates whether the majority of values (in this case 2 out of 3) are
<!-- l. 683 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>. Recall from Eq. (<a href='#x11-224007r51'>9.51<!-- tex4ht:ref: eq:MAJ-XORs  --></a>)
that we have <!-- l. 684 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext>MAJ</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>∧</mo> <mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
Hence, setting <!-- l. 684 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>a</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></math>,
<!-- l. 684 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>s</mi></mrow><mrow><mn>0</mn></mrow></msub></mrow></math> and
<!-- l. 684 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>b</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></math>, we
see that we can calculate the carry bit using the circuit: </p><table class='equation'><tr><td>
<!-- l. 685 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 685 --><object id='x11-228001r79' data="svgs/eq-adder-carry-MAJ.svg" alt="diagram of eq:adder-carry-MAJ" class="svg-diagram"></object></td><td class='eq-no'>(9.79)</td></tr></table>
<!-- l. 688 --><p class='indent'>   Calculating all the other bits now follows similarly: we set
<!-- l. 688 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>s</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>a</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>b</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>c</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></math> and
<!-- l. 688 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>c</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mstyle class='text'><mtext>MAJ</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>a</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>b</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>c</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>. Or in general,
for the <!-- l. 688 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>th
bit we have <!-- l. 688 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>s</mi></mrow><mrow><mi>k</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>a</mi></mrow><mrow><mi>k</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>b</mi></mrow><mrow><mi>k</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>c</mi></mrow><mrow><mi>k</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msub></mrow></math>
where <!-- l. 688 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>c</mi></mrow><mrow><mi>k</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mstyle class='text'><mtext>MAJ</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>a</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>b</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>c</mi></mrow><mrow><mi>k</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
Putting this all together, we can then write down a circuit for the adder, for instance
for <!-- l. 689 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>3</mn></mrow></math>
we have: </p><table class='equation'><tr><td>
<!-- l. 690 --><p class='indent'>
</p><!-- l. 690 --><object id='x11-228002r80' data="svgs/adder-3-bits.svg" alt="diagram of adder-3-bits" class="svg-diagram"></object></td><td class='eq-no'>(9.80)</td></tr></table>
<!-- l. 693 --><p class='indent'>   Here we have drawn a dashed box around the calculation of the MAJ function
for the second and third carry bits. There are a couple of issues with this
construction of the adder right now. First, it obviously contains some CNOT
gates that can be cancelled against each other, and hence can be made a bit more
efficient. But more importantly: we are not yet uncomputing the carry bits,
which is important if we wish to use this Adder in superposition, so let’s do that:
</p><table class='equation'><tr><td>
<!-- l. 695 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 695 --><object id='x11-228003r81' data="svgs/adder-3-bits-uncompute.svg" alt="diagram of adder-3-bits-uncompute" class="svg-diagram"></object></td><td class='eq-no'>(9.81)</td></tr></table>
<!-- l. 698 --><p class='indent'>   Let’s cancel some matching CNOTs: </p><table class='equation'><tr><td>
<!-- l. 699 --><p class='indent'>
</p><!-- l. 699 --><object id='x11-228004r82' data="svgs/eq-adder-3-bits-opt.svg" alt="diagram of eq:adder-3-bits-opt" class="svg-diagram"></object></td><td class='eq-no'>(9.82)</td></tr></table>
<!-- l. 702 --><p class='indent'>   Here we have grouped together the different components
that make up the computation: the calculation of first
<!-- l. 702 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>c</mi></mrow><mrow><mn>0</mn></mrow></msub></math>,
<!-- l. 702 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>c</mi></mrow><mrow><mn>1</mn></mrow></msub></math>,
<!-- l. 702 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>c</mi></mrow><mrow><mn>2</mn></mrow></msub></math> and
<!-- l. 702 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>s</mi></mrow><mrow><mn>2</mn></mrow></msub></math>, followed by the
uncomputation of <!-- l. 702 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>c</mi></mrow><mrow><mn>1</mn></mrow></msub></math>, the
computation of <!-- l. 702 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>s</mi></mrow><mrow><mn>1</mn></mrow></msub></math>, the
uncomputation of <!-- l. 702 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>c</mi></mrow><mrow><mn>0</mn></mrow></msub></math> and
finally the computation of <!-- l. 702 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>s</mi></mrow><mrow><mn>0</mn></mrow></msub></math>.
This pattern extends to the addition of an arbitrary number of bits: first
calculate all the carries, and then alternate calculating the sum of a bit and
uncomputing the matching carry. We see then that the total cost consists of
<!-- l. 702 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math> zeroed
ancillae and <!-- l. 702 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>2</mn><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math>
Toffoli gates: 1 each for the computation of a carry and 1 each for the
uncomputation of all the carries except for the last one. Using the quantum tricks
we have seen, we can however halve the cost of this addition circuit. In the
circuit (<a href='#x11-228004r82'>9.82<!-- tex4ht:ref: eq:adder-3-bits-opt  --></a>) we have connected together the matching compute and uncompute
pairs by dashed lines. These compute-uncompute pair Toffolis can be replaced by
just a single Toffoli using the constructions of Eq. (<a href='#x11-226013r74'>9.74<!-- tex4ht:ref: eq:Tof-Gidney-zeroed  --></a>) (in the case of
<!-- l. 703 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>c</mi></mrow><mrow><mn>0</mn></mrow></msub></math>
which is computing with just a Toffoli) and Exercise <a href='#x11-226014r11'>9.11<!-- tex4ht:ref: exer:Gidneyed-carry  --></a> (for
<!-- l. 703 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>c</mi></mrow><mrow><mn>1</mn></mrow></msub></math>, as this
involves both a CNOT and a Toffoli). The final carry does not have to be uncomputed
                                                                     

                                                                     
and hence uses a single Toffoli regardless. The total number of Toffoli gates is then
just <!-- l. 703 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
instead of <!-- l. 703 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>2</mn><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math>,
and furthermore, each Toffoli can be implemented using just 4
<!-- l. 703 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates
instead of <!-- l. 703 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>7</mn></math>.
Putting these optimisations together we see that we have reduced the original
<!-- l. 704 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> count
of <!-- l. 704 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>7</mn> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mn>2</mn><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>14</mn><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>7</mn></mrow></math> to
<!-- l. 704 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>4</mn><mi>n</mi></mrow></math>.
</p>
   <div class='newtheorem'>
<!-- l. 705 --><p class='noindent'><span class='head'>
<a id='x11-228005r15'></a>
<span class='cmbx-10x-x-109'>Exercise 9.15.</span>  </span> The construction of the adder described above is
very efficient in the number of (Toffoli) gates, but it does require
<!-- l. 706 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
ancillae, one for each of the carry bits. We can also construct an adder without
using any ancillae, but using more gates.
     </p><dl class='enumerate'><dt class='enumerate'>
  1.. </dt><dd class='enumerate'>
     <!-- l. 708 --><p class='noindent'>Argue that the following circuit implements a ‘decrement by
     <!-- l. 708 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>’
     operation: </p><table class='equation'><tr><td>
     <!-- l. 709 --><p class='noindent'>
     </p><!-- l. 709 --><object id='x11-228007r83' data="svgs/eq-decrementer.svg" alt="diagram of eq:decrementer" class="svg-diagram"></object></td><td class='eq-no'>(9.83)</td></tr></table>
     <!-- l. 712 --><p class='noindent'>That is, given a computational basis input
     <!-- l. 712 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> encoding a
     number <!-- l. 712 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>b</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <msub><mrow><mi>ℤ</mi></mrow><mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></msub></mrow></math>, it
     produces <!-- l. 712 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>b</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math>
     modulo <!-- l. 712 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></math>.
                                                                     

                                                                     
     </p></dd><dt class='enumerate'>
  2.. </dt><dd class='enumerate'>
     <!-- l. 713 --><p class='noindent'>Argue that the following circuit of cascading ‘controlled
     decrementers’ implements the subtract operation
     <!-- l. 713 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>a</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>b</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>↦</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mi>a</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>b</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>a</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>:
     </p><table class='equation'><tr><td>
     <!-- l. 714 --><p class='noindent'>
     </p><!-- l. 714 --><object id='x11-228009r84' data="svgs/eq-subtracter-circuit.svg" alt="diagram of eq:subtracter-circuit" class="svg-diagram"></object></td><td class='eq-no'>(9.84)</td></tr></table>
     </dd><dt class='enumerate'>
  3.. </dt><dd class='enumerate'>
     <!-- l. 717 --><p class='noindent'>Argue that the adjoint of the above circuit hence implements an
     adder.
     </p></dd><dt class='enumerate'>
  4.. </dt><dd class='enumerate'>
     <!-- l. 718 --><p class='noindent'>What is the cost in the number of standard 2-controlled Toffoli gates of this
     construction? You can use any decomposition of the many-controlled Toffoli
     gates that we have seen in this chapter (that fits in the available number of
     qubits). </p></dd></dl>
   </div>
<!-- l. 720 --><p class='indent'>
</p>
   <h3 class='sectionHead' id='summary-what-to-remember7'><span class='titlemark'>9.6   </span> <a id='x11-2290009.6'></a>Summary: what to remember</h3>
<!-- l. 723 --><p class='noindent'>
     </p><dl class='enumerate'><dt class='enumerate'>
  1.. </dt><dd class='enumerate'>
     <!-- l. 723 --><p class='noindent'>There is a Boolean Fourier transform from an XOR of bits, to an AND
     of bits. This allows us to relate phase gadgets (which are based on
     XOR), to diagonal controlled-unitaries (which are based on AND).
                                                                     

                                                                     
     </p></dd><dt class='enumerate'>
  2.. </dt><dd class='enumerate'>
     <!-- l. 724 --><p class='noindent'>The H-box is a spider-like linear map that allows us to more compactly
     represent  controlled  unitaries.  There  are  a  variety  of  rewrite  rules
     involving H-boxes that correspond to useful identities involving Toffoli
     gates and the Boolean AND. See Figure <a href='#the-basic-rules-for-hboxes-'>9.0<!-- tex4ht:ref: fig:zh-rules  --></a>.
     </p></dd><dt class='enumerate'>
  3.. </dt><dd class='enumerate'>
     <!-- l. 725 --><p class='noindent'>If we are given a Boolean formula, then we can implement it as a
     quantum circuit by storing intermediate computations on additional
     bits.  By  representing  a  classical  reversible  function  directly  as  a
     truth table we can instead decompose it in terms of 2-cycles, which
     correspond to many-controlled Toffoli gates.
     </p></dd><dt class='enumerate'>
  4.. </dt><dd class='enumerate'>
     <!-- l. 726 --><p class='noindent'>We can implement a <!-- l. 726 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>-controlled
     Toffoli gate with <!-- l. 726 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>k</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
     regular Toffoli gates with the help of a single borrowed ancilla.
     </p></dd><dt class='enumerate'>
  5.. </dt><dd class='enumerate'>
     <!-- l. 727 --><p class='noindent'>By introducing, measuring and correcting an ancilla, we can implement
     a Toffoli using 4 instead of 7 <!-- l. 727 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
     gates. We can even implement a compute-uncompute pair of a Toffoli
     using a single ancilla and just 4 <!-- l. 727 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
     gates.
     </p></dd><dt class='enumerate'>
  6.. </dt><dd class='enumerate'>
     <!-- l. 728 --><p class='noindent'>Putting these tricks together allows us to create an <!-- l. 728 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit
     adder circuit that uses just <!-- l. 728 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
     Toffoli gates, or <!-- l. 728 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>4</mn><mi>n</mi></mrow></math>
     <!-- l. 728 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
     gates. </p></dd></dl>
<!-- l. 730 --><p class='noindent'>
</p>
   <h3 class='sectionHead' id='advanced-material4'><span class='titlemark'>9.7   </span> <a id='x11-2300009.7'></a>Advanced Material*</h3>
                                                                     

                                                                     
<!-- l. 731 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='from-truth-tables-to-toffolis'><span class='titlemark'>9.7.1   </span> <a id='x11-2310009.7.1'></a>From truth tables to Toffolis*</h4>
<!-- l. 732 --><p class='noindent'>Instead of being given a concrete specification of a classical function as a
collection of simple operations performed in sequence, we can also consider it as
just a truth table that tells us where every bit string is mapped to. In this section
we will see how we can decompose such functions into <span class='cmti-10x-x-109'>cycles </span>and how each
cycle can be implemented using Toffoli gates. In this way we will also
be able to prove that certain functions, like a generalised Toffoli with
<!-- l. 733 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math>
controls, requires at least one additional ancilla to be constructed using gates
acting on fewer qubits. So let us suppose we are given a reversible function
<!-- l. 734 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi> <mo class='MathClass-punc' stretchy='false'>:</mo> <mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>→</mo> <mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></math>. As
<!-- l. 734 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math> is
a bijection, we can see this as a <span class='cmti-10x-x-109'>permutation </span>on the set of bit strings
<!-- l. 734 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mo class='MathClass-open' stretchy='false'>{</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>}</mo></mrow><mrow><mi>n</mi></mrow></msup></math>. The set
of <!-- l. 735 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-bit
reversible functions hence forms the <span class='cmbx-10x-x-109'>permutation group </span>on
<!-- l. 735 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></math>
elements. Now, if you know a little bit of group theory, then you will know
that a permutation group is generated by <span class='cmti-10x-x-109'>cycles</span>, or more specifically,
<span class='cmti-10x-x-109'>2-cycles</span>.
</p>
   <div class='newtheorem'>
<!-- l. 737 --><p class='noindent'><span class='head'>
<a id='x11-231001r1'></a>
<span class='cmbx-10x-x-109'>Definition 9.7.1.</span>  </span>Let <!-- l. 738 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>G</mi></math> be a
permutation group on some set <!-- l. 738 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
(like the set length-<!-- l. 738 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
bit strings). A <!-- l. 738 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math><span class='cmbx-10x-x-109'>-cycle</span>
<!-- l. 738 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>σ</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>G</mi></mrow></math> is a permutation
where there are <!-- l. 738 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
distinct elements <!-- l. 738 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>S</mi></mrow></math>
such that </p>
     <ul class='itemize1'>
     <li class='itemize'><!-- l. 740 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>σ</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>x</mi></mrow><mrow><mi>i</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mn>1</mn></mrow></msub></mrow></math>
     (and we set <!-- l. 740 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mn>1</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></math>),
     </li>
     <li class='itemize'><!-- l. 741 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>σ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>y</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>y</mi></mrow></math>
     for any <!-- l. 741 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>y</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>S</mi></mrow></math>
     not equal to one of the <!-- l. 741 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mi>i</mi></mrow></msub></math>,
     </li>
     <li class='itemize'>and there is no smaller <!-- l. 742 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
     with the above two properties. </li></ul>
<!-- l. 744 --><p class='noindent'>We say two cycles are <span class='cmti-10x-x-109'>disjoint </span>when they don’t have any elements they act non-trivially on in
common (for <!-- l. 744 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>σ</mi></math>
and <!-- l. 744 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>σ</mi></mrow><mrow><mi>′</mi></mrow></msup></math>
that are not equal, this is equivalent to them commuting). We denote a
<!-- l. 745 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>-cycle
on <!-- l. 745 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub></mrow></math> by
<!-- l. 745 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mi> </mi><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mi> </mi><mo class='MathClass-rel' stretchy='false'>⋯</mo><mi> </mi><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
</p>
   </div>
<!-- l. 746 --><p class='indent'>    So a <!-- l. 747 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>-cycle is a permutation
that <span class='cmti-10x-x-109'>cycles </span>the value of <!-- l. 747 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub></math>
to <!-- l. 747 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub></math> to
<!-- l. 747 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub></math>, and so on,
to <!-- l. 747 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub></math> and then
back to <!-- l. 747 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub></math>.
It acts as the identity on all the other elements. A standard result from group
theory is that any permutation can be written as a composition of disjoint
cycles.
</p>
   <div class='newtheorem'>
<!-- l. 749 --><p class='noindent'><span class='head'>
<a id='x11-231002r16'></a>
<span class='cmbx-10x-x-109'>Exercise 9.16.</span>  </span> Let <!-- l. 750 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>G</mi></math>
be a permutation group on some set <!-- l. 750 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
and let <!-- l. 750 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>σ</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>G</mi></mrow></math>
be any permutation. Then <!-- l. 750 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>σ</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>σ</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>σ</mi></mrow><mrow><mi>l</mi></mrow></msub></mrow></math>
for some disjoint cycles <!-- l. 750 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>σ</mi></mrow><mrow><mi>j</mi></mrow></msub></math>.
</p>
   </div>
<!-- l. 751 --><p class='indent'>
</p>
   <div class='newtheorem'>
                                                                     

                                                                     
<!-- l. 756 --><p class='noindent'><span class='head'>
<a id='x11-231003r2'></a>
<span class='cmbx-10x-x-109'>Lemma 9.7.2.</span>  </span>Let <!-- l. 757 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>G</mi></math>
be a permutation group on some set <!-- l. 757 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>.
Then <!-- l. 757 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>G</mi></math>
is generated by 2-cycles.
</p>
   </div>
<!-- l. 758 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 760 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>Exercise <a href='#x11-231002r16'>9.16<!-- tex4ht:ref: exer:permutation-group-cycles  --></a> shows that <!-- l. 760 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>G</mi></math>
is generated by cycles, so it suffices to show that each cycle can be built out of
2-cycles. This is easily done: <!-- l. 760 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mi> </mi><mo>…</mo><mi> </mi><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mi> </mi><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>∘</mo> <mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mi> </mi><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>∘</mo><mo>…</mo> <mo class='MathClass-bin' stretchy='false'>∘</mo> <mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msub><mi> </mi><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
For each <!-- l. 760 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mi>i</mi></mrow></msub></math>
with <!-- l. 760 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>i</mi> <mo class='MathClass-rel' stretchy='false'>&lt;</mo> <mi>k</mi></mrow></math>
we can easily check that only exactly one of these 2-cycles does something
non-trivial to it, and maps it to <!-- l. 760 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mi>i</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mn>1</mn></mrow></msub></math>.
For <!-- l. 760 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub></math>,
instead all the 2-cycles apply, mapping it first to <!-- l. 760 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msub></math>,
then to <!-- l. 760 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>2</mn></mrow></msub></math>,
and so on, until it is finally mapped to <!-- l. 760 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub></math>.
                                                                   □
</p>
   </div>
<!-- l. 762 --><p class='indent'>   Okay, so any permutation can be built out of 2-cycles. So if we want
to know how we can construct an arbitrary reversible function, it
suffices to show how we can construct an arbitrary 2-cycle on bit
strings. That is, we need to construct for any choice of bit strings
<!-- l. 762 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></math> and
<!-- l. 762 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></math>, the
function <!-- l. 762 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>P</mi></mrow><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-punc' stretchy='false'>,</mo><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub></math>
that maps <!-- l. 762 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></math>
to <!-- l. 762 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></math>
and vice versa, and acts as the identity on all other bit strings. So let’s suppose
<!-- l. 763 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></math> and
<!-- l. 763 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></math>
                                                                     

                                                                     
given. We will first simplify our lives somewhat by taking
<!-- l. 763 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></math> to be equal
to the all <!-- l. 763 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>
bit string. We can do this by using the following identity for permutation groups
(convince yourself that this works): </p><table class='equation'><tr><td>
<!-- l. 764 --><p class='indent'>
</p><!-- l. 764 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                     <mstyle class='label' id='x11-231004r85'></mstyle><!-- endlabel --><mi>σ</mi> <mo class='MathClass-bin' stretchy='false'>∘</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi mathvariant='italic'>x y</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>∘</mo> <msup><mrow><mi>σ</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup><mspace class='nbsp' width='0.33em'></mspace><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-open' stretchy='false'>(</mo><mi>σ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi mathvariant='italic'> σ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>y</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo>
</mrow></math></td><td class='eq-no'>(9.85)</td></tr></table>
<!-- l. 767 --><p class='indent'>   In this case we will take <!-- l. 767 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>σ</mi></math>
to be the bit string function
<!-- tex4ht:inline --></p><!-- l. 768 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                    <mover accent='true'><mrow><mi>z</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>↦</mo><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>z</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>z</mi></mrow><mrow><mi>n</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-punc' stretchy='false'>,</mo>
</mrow></math>
<!-- l. 768 --><p class='nopar'> which indeed maps <!-- l. 769 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></math>
to <!-- l. 769 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mn>1</mn></mrow><mo accent='true'>→</mo></mover></math>.
Note that this function is implemented by applying a NOT gate on the indices
<!-- l. 769 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math> where
<!-- l. 769 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>. Hence,
<!-- l. 769 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>P</mi></mrow><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-punc' stretchy='false'>,</mo><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow></msub></math> is equivalent
to <!-- l. 769 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>P</mi></mrow><mrow><mover accent='true'><mrow><mn>1</mn></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>′</mi></mrow></msup></mrow></msub></math>
up to some NOT gates. Note that because we started with
<!-- l. 769 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>≠</mo><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow></math>, that we
now have <!-- l. 769 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>≠</mo><mover accent='true'><mrow><mn>1</mn></mrow><mo accent='true'>→</mo></mover></mrow></math>.
Furthermore, by rearranging bits (for instance by applying some swap
gates before and after the desired operations), we may assume that
<!-- l. 770 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>′</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>10</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn></mrow></math>. That is,
                                                                     

                                                                     
<!-- l. 770 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>′</mi></mrow></msup></math> is a series of
<!-- l. 770 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>’s followed by a
series of <!-- l. 770 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math>’s So let’s
suppose that <!-- l. 771 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>′</mi></mrow></msup></math>
consists of <!-- l. 771 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
0’s and <!-- l. 771 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>k</mi></mrow></math> 1’s.
Note that <!-- l. 771 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>&gt;</mo> <mn>0</mn></mrow></math> as
otherwise <!-- l. 771 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>′</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='true'><mrow><mn>1</mn></mrow><mo accent='true'>→</mo></mover></mrow></math>.
We can now easily write down the required circuit: </p><table class='equation'><tr><td>
<!-- l. 773 --><p class='indent'>
</p><!-- l. 773 --><object id='x11-231005r86' data="svgs/eq-circuit-two-cycle.svg" alt="diagram of eq:circuit-two-cycle" class="svg-diagram"></object></td><td class='eq-no'>(9.86)</td></tr></table>
<!-- l. 776 --><p class='indent'>   We can check that is correct by verifying the three possibilities for the input:
<!-- l. 776 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mn>1</mn></mrow><mo accent='true'>→</mo></mover></math>,
<!-- l. 776 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>′</mi></mrow></msup></math>,
or some other bit string. First, the case where all the inputs are
<!-- l. 776 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mn>1</mn></mrow><mo accent='true'>→</mo></mover></math>:
</p><table class='equation-star'><tr><td>
<!-- l. 777 --><object data="svgs/circuit-two-cycle-ones.svg" alt="diagram of circuit-two-cycle-ones" class="svg-diagram"></object></td></tr></table>
<!-- l. 780 --><p class='indent'>   This output indeed matches <!-- l. 780 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>′</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>10</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn></mrow></math>.
Let’s check what happens when we input
<!-- l. 781 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>′</mi></mrow></msup></math>
instead: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 782 --><object data="svgs/circuit-two-cycle-second.svg" alt="diagram of circuit-two-cycle-second" class="svg-diagram"></object></td></tr></table>
<!-- l. 785 --><p class='indent'>   We also get the correct output of
<!-- l. 785 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mn>1</mn></mrow><mo accent='true'>→</mo></mover></math>! We
just need to check that this circuit does not do anything when we input any other
state.
</p>
   <div class='newtheorem'>
<!-- l. 787 --><p class='noindent'><span class='head'>
<a id='x11-231006r17'></a>
<span class='cmbx-10x-x-109'>Exercise 9.17.</span>  </span>Prove, by doing smart case distinctions, that the circuit of
Eq. (<a href='#x11-231005r86'>9.86<!-- tex4ht:ref: eq:circuit-two-cycle  --></a>) acts as the identity when the input bit string is not <!-- l. 788 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mn>1</mn></mrow><mo accent='true'>→</mo></mover></math>
or <!-- l. 788 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>′</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>10</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn></mrow></math>.
Hint: if the input is such that the Toffoli does not fire, then the CNOT and
NOT gates cancel each other out. In which situations can the Toffoli gate
fire?
</p>
   </div>
<!-- l. 790 --><p class='indent'>     We hence have the following.
</p>
   <div class='newtheorem'>
<!-- l. 796 --><p class='noindent'><span class='head'>
<a id='x11-231007r3'></a>
<span class='cmbx-10x-x-109'>Proposition 9.7.3.</span>  </span>We can implement any 2-cycle on <!-- l. 797 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
bits using a single <!-- l. 797 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>-controlled
Toffoli and <!-- l. 797 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
CNOT and NOT gates.
</p>
   </div>
<!-- l. 798 --><p class='indent'>
</p>
                                                                     

                                                                     
   <div class='newtheorem'>
<!-- l. 799 --><p class='noindent'><span class='head'>
<a id='x11-231008r4'></a>
<span class='cmbx-10x-x-109'>Theorem 9.7.4.</span>  </span>Any <!-- l. 800 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-bit
reversible function can be implemented using <!-- l. 800 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
<!-- l. 800 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>-controlled
Toffoli, CNOT, and NOT gates.
</p>
   </div>
<!-- l. 801 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 803 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>A      reversible      function      can      be      decomposed      into
<!-- l. 803 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></math>
disjoint   2-cycles,   and   each   2-cycle   can   be   implemented   using
<!-- l. 803 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
gates,                 requiring                 a                 total                 of
<!-- l. 803 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
gates.                                                                                          □
</p>
   </div>
<!-- l. 805 --><p class='indent'>   Now, it might seem like this procedure is very inefficient. After all, we first
decompose the permutation down into 2-cycles, and then painstakingly construct
each of these 2-cycles. Surely there must be a more efficient way, using
<!-- l. 805 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>-cycles
or some other trick, in order to use less than
<!-- l. 805 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> gates.
While yes, there are clever ways to reduce the constants and to do better, on an
asymptotic level, this construction is already close to optimal: we could only
improve it up to a logarithmic factor.
</p>
   <div class='newtheorem'>
<!-- l. 807 --><p class='noindent'><span class='head'>
<a id='x11-231009r5'></a>
                                                                     

                                                                     
<span class='cmbx-10x-x-109'>Proposition 9.7.5.</span>  </span>There exist reversible functions on <!-- l. 808 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mn>2</mn></mrow></math>
bits that require at least <!-- l. 808 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>cn</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup><mo class='MathClass-bin' stretchy='false'>∕</mo><mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --><mi>n</mi></mrow></math>
Toffoli, CNOT and NOT gates for <!-- l. 808 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>c</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>6</mn></mrow></mfrac></mrow></math>
(assuming that <!-- l. 808 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --> <mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow><mstyle> <mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo></mstyle><!-- nolimits --></mrow><mrow><mn>2</mn></mrow></msub></mrow></math>).
</p>
   </div>
<!-- l. 809 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 811 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>Counting the placement of gates on different bits as distinct, there are
<!-- l. 811 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
different Toffoli gates with <!-- l. 811 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math>
controls, <!-- l. 811 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
different NOT gates, and <!-- l. 811 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
different CNOTs. Hence, <!-- l. 811 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>n</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>n</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>n</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>n</mi></mrow></math>
different 1 gate circuits. Using <!-- l. 811 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>N</mi></math>
gates we can hence construct at most <!-- l. 811 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>n</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>n</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi>N</mi></mrow></msup></math>
different maps. There are <!-- l. 811 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-punc' stretchy='false'>!</mo></mrow></math>
different reversible functions on <!-- l. 811 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
bits (where <!-- l. 811 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi><mo class='MathClass-punc' stretchy='false'>!</mo></mrow></math>
represents the factorial function <!-- l. 811 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi><mo class='MathClass-punc' stretchy='false'>!</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>k</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>k</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>2</mn> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mn>1</mn></mrow></math>).
In order to write down all reversible functions we hence need a number of
gates <!-- l. 811 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>N</mi></math>
such that <!-- l. 811 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>n</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>n</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi>N</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-punc' stretchy='false'>!</mo></mrow></math>.
Stirling’s formula for the factorial gives us <!-- l. 811 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><mi>k</mi><mo class='MathClass-punc' stretchy='false'>!</mo><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><mi>k</mi><mstyle><mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo></mstyle><!-- nolimits --><mi>k</mi></mrow></math>.
So by taking logarithms on both sides we get the inequality <!-- l. 811 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>N</mi><mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>n</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>n</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup><mstyle> <mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo></mstyle><!-- nolimits --><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><mi>n</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup><mstyle> <mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo></mstyle><!-- nolimits --><mn>2</mn></mrow></math>.
Assuming <!-- l. 812 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mn>2</mn></mrow></math>
and using <!-- l. 812 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>n</mi></mrow><mrow><mn>3</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>≥</mo> <msup><mrow><mi>n</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>n</mi></mrow></math>
we get <!-- l. 812 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>3</mn><mi>N</mi><mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --><mi>n</mi> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mfrac><mrow><mstyle><mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo></mstyle><!-- nolimits --> <mn>2</mn></mrow> 
  <mrow><mn>2</mn></mrow></mfrac>   <mi>n</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></math>
and hence <!-- l. 812 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>N</mi> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mi mathvariant='italic'>cn</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup><mo class='MathClass-bin' stretchy='false'>∕</mo><mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --><mi>n</mi></mrow></math>
for <!-- l. 812 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>c</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mfrac><mrow><mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --> <mn>2</mn></mrow> 
  <mrow><mn>6</mn></mrow></mfrac>    <mo class='MathClass-rel' stretchy='false'>=</mo> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>6</mn></mrow></mfrac></mrow></math>
(using <!-- l. 812 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --><mn>2</mn> <mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow><mstyle> <mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo></mstyle><!-- nolimits --></mrow><mrow><mn>2</mn></mrow></msub><mn>2</mn> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>).
                                                                   □
</p>
   </div>
<!-- l. 814 --><p class='indent'>   At this point you might wonder if we really need a Toffoli gate with this many
controls. Couldn’t we make do with just a regular Toffoli with two control wires?
The answer is <span class='cmti-10x-x-109'>no</span>. We cannot decompose such a Toffoli into gates acting on fewer
                                                                     

                                                                     
bits, at least in the current setting. To understand this limitation, we need to know
the concept of the <span class='cmbx-10x-x-109'>parity </span>of a permutation. We write the parity of a permutation
<!-- l. 815 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>σ</mi></math> as
<!-- l. 815 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext>sgn</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mi>σ</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> and
we define this inductively by setting the parity of each 2-cycle to be
<!-- l. 815 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math>:
<!-- l. 815 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext>sgn</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-open' stretchy='false'>(</mo><mi mathvariant='italic'>x y</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></math>, and making it
respect composition: <!-- l. 815 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext>sgn</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>σ</mi></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mi>σ</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mstyle class='text'><mtext>sgn</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>σ</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mstyle class='text'><mtext>sgn</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>σ</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
Hence the parity of a permutation captures whether we need an even
or odd number of 2-cycles to write it down (it is a bit non-trivial
to see that this is actually well-defined). We call a permutation
<!-- l. 815 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>σ</mi></math> <span class='cmti-10x-x-109'>even </span>when
<!-- l. 815 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext>sgn</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mi>σ</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math> and <span class='cmti-10x-x-109'>odd</span>
when <!-- l. 815 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext>sgn</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mi>σ</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></math>. Now
comes the catch: from the definition of parity we immediately see that when we compose
even permutations, we get another even permutation. It just so happens to be that an
<!-- l. 816 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>-controlled
Toffoli acting on <!-- l. 816 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
bits is an odd permutation, while any gate acting on fewer bits is even.
This means there is no way we can combine these gates to construct the
<!-- l. 816 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>-controlled
Toffoli. To see these gates indeed have these parities, first note that a
<!-- l. 817 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>-controlled Toffoli acting
on <!-- l. 817 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math> bits is a 2-cycle that
maps the bit string <!-- l. 817 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>1</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>11</mn></mrow></math>
to <!-- l. 817 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>1</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>10</mn></mrow></math> and
vice versa, so that it is indeed an odd permutation. Suppose instead we have a gate
that does not act on at least one bit. Denote its corresponding permutation by
<!-- l. 818 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>σ</mi></math>, and let
<!-- l. 818 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>σ</mi></mrow><mrow><mi>′</mi></mrow></msup></math> denote
the permutation where we have chopped of the last bit (the one it doesn’t act on). Let
<!-- l. 819 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>σ</mi></mrow><mrow><mi>′</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msup><mi> </mi><msup><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>⋯</mo><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>k</mi></mrow></msup><mi> </mi><msup><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>k</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> be a decomposition of
<!-- l. 819 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>σ</mi></mrow><mrow><mi>′</mi></mrow></msup></math> into 2-cycles. Then in
the decomposition of <!-- l. 819 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>σ</mi></math>,
each of these 2-cycles must occur twice, one for each possible value of the last bit. That is, a
decomposition of <!-- l. 820 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>σ</mi></math>
is given by <!-- l. 820 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>σ</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msup><mn>0</mn><mi> </mi><msup><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msup><mn>0</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msup><mn>1</mn><mi> </mi><msup><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msup><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>⋯</mo><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>k</mi></mrow></msup><mn>0</mn><mi> </mi><msup><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>k</mi></mrow></msup><mn>0</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>k</mi></mrow></msup><mn>1</mn><mi> </mi><msup><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>k</mi></mrow></msup><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
Since the permutation then consists of an even number of 2-cycles, it is an even
permutation. There are two ways around this issue: use non-classical,
i.e. quantum, gates, or use additional bits as ‘scratch space’.
</p>
                                                                     

                                                                     
   <h4 class='subsectionHead' id='level-operators'><span class='titlemark'>9.7.2   </span> <a id='x11-2320009.7.2'></a>2-level operators*</h4>
<!-- l. 823 --><p class='noindent'>Let <!-- l. 823 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
be a single-qubit unitary. If we consider an
<!-- l. 823 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit circuit containing
just a <!-- l. 823 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>-controlled
<!-- l. 823 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math> gate,
its matrix has a very particular shape: </p><table class='equation'><tr><td>
<!-- l. 824 --><p class='indent'>
</p><!-- l. 824 --><object id='x11-232001r87' data="svgs/eq-many-controlled-U.svg" alt="diagram of eq:many-controlled-U" class="svg-diagram"></object></td><td class='eq-no'>(9.87)</td></tr></table>
<!-- l. 827 --><p class='indent'>   Here all the empty spots in the matrix are zeroes. This shape comes from the
fact that this gate only does something non-trivial on the basis states
<!-- l. 828 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>10</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> and
<!-- l. 828 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>11</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>, since the first
<!-- l. 828 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math> wires have
to be in the <!-- l. 828 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
state for it to fire. This unitary is a special case of a <span class='cmbx-10x-x-109'>2-level operator</span>, a unitary
that acts non-trivially on just 2 basis states. To make this more clear, instead of
labelling all our basis states as bit strings, we will label them as numbers
<!-- l. 829 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>2</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>3</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></math>. Denoting
<!-- l. 829 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>i</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math> and
<!-- l. 829 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>j</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></math>, we will call the
above controlled gate <!-- l. 829 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mi mathvariant='italic'>ij</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></msub></math>,
and it acts as follows: </p><table class='equation'><tr><td>
<!-- l. 830 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 830 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mstyle class='label' id='x11-232002r88'></mstyle><!-- endlabel --><msub><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mi mathvariant='italic'>ij</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></msub> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'>   <msub><mrow><mi>ψ</mi></mrow><mrow><mn>0</mn></mrow></msub>   </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'>    <mi>⋮</mi>  </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <msub><mrow><mi>ψ</mi></mrow><mrow><msup><mrow>
<mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></msub>  </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                                         </mrow><mo fence='true' form='postfix'>)</mo></mrow> <mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <msubsup><mrow><mi>ψ</mi></mrow><mrow><mn>0</mn></mrow><mrow><mi>′</mi></mrow></msubsup> </mtd>
</mtr><mtr class='array-row'><mtd class='array-td' columnalign='center'>  <mi>⋮</mi>   </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <msubsup><mrow><mi>ψ</mi></mrow><mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow><mrow><mi>′</mi></mrow></msubsup> </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                 </mrow><mo fence='true' form='postfix'>)</mo></mrow><mstyle class='text'><mtext> where </mtext></mstyle> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'>  <msubsup><mrow><mi>ψ</mi></mrow><mrow><mi>i</mi></mrow><mrow><mi>′</mi></mrow></msubsup> </mtd>
</mtr><mtr class='array-row'><mtd class='array-td' columnalign='center'> <msubsup><mrow><mi>ψ</mi></mrow><mrow><mi>j</mi></mrow><mrow><mi>′</mi></mrow></msubsup> </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                  </mrow><mo fence='true' form='postfix'>)</mo></mrow><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mi>U</mi> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <msub><mrow><mi>ψ</mi></mrow><mrow><mi>i</mi></mrow></msub>  </mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <msub><mrow><mi>ψ</mi></mrow><mrow><mi>j</mi></mrow></msub> </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                                                  </mrow><mo fence='true' form='postfix'>)</mo></mrow> <mstyle class='text'><mtext> and for </mtext></mstyle><mi>k</mi><mo class='MathClass-rel' stretchy='false'>≠</mo><mi>i</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>j</mi> <mo class='MathClass-punc' stretchy='false'>:</mo> <msubsup><mrow><mi>ψ</mi></mrow><mrow><mi>k</mi></mrow><mrow><mi>′</mi></mrow></msubsup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>ψ</mi></mrow><mrow>
<mi>k</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td><td class='eq-no'>(9.88)</td></tr></table>
<!-- l. 835 --><p class='indent'>   A general 2-level operator is defined the same, but then
<!-- l. 835 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math> and
<!-- l. 835 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>j</mi></math> are allowed to be arbitrary
values (as long as <!-- l. 835 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>i</mi><mo class='MathClass-rel' stretchy='false'>≠</mo><mi>j</mi></mrow></math>
of course). We have in fact already seen other examples of 2-level
operators: the 2-cycles that swap just two basis states and leave
every other one invariant. A 2-cycle that swaps the basis states
<!-- l. 835 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>k</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> and
<!-- l. 835 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>l</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> is just the
2-level <!-- l. 835 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>X</mi></mrow><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mi mathvariant='italic'>kl</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></msub></math>
gate. Because we know how to construct these 2-cycles and the
<!-- l. 835 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>-controlled
<!-- l. 835 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>, we have in
fact all we need to construct arbitrary 2-level operators. This is because we have the
relation <!-- l. 836 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>X</mi></mrow><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mi mathvariant='italic'>kj</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></msub><msub><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mi mathvariant='italic'>ij</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></msub><msub><mrow><mi>X</mi></mrow><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mi mathvariant='italic'>kj</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mi mathvariant='italic'>ik</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></msub></mrow></math>
as long as <!-- l. 836 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi><mo class='MathClass-rel' stretchy='false'>≠</mo><mi>i</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>j</mi></mrow></math>:
The first <!-- l. 836 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>X</mi></mrow><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mi mathvariant='italic'>kj</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></msub></math>
moves <!-- l. 836 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>k</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
to <!-- l. 836 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>j</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>, so
that the <!-- l. 836 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mi mathvariant='italic'>ij</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></msub></math>
can apply to it, and then we move it back to the
<!-- l. 836 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>k</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> spot by another
application of <!-- l. 836 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>X</mi></mrow><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mi mathvariant='italic'>kj</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></msub></math>.
So with 2-cycle gates we can move the places where a 2-level operator acts non-trivially.
A 2-level operator acts non-trivially on two different basis states, but we also have
<span class='cmbx-10x-x-109'>1-level operators </span>that act just on a single basis state. An example of this is the
<!-- l. 837 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>-controlled
<!-- l. 837 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> gate.
The <!-- l. 837 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
gate only fires when all the controls are in the
<!-- l. 837 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> state, but
additionally the <!-- l. 837 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
only does something non-trivial when its target is also in the
<!-- l. 837 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> state;
the <!-- l. 837 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
state is left alone. We could hence call this gate
<!-- l. 837 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><msub><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mi>j</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></msub></mrow></math> where
<!-- l. 837 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>j</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></math>. By conjugating
                                                                     

                                                                     
by <!-- l. 837 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>X</mi></mrow><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mi mathvariant='italic'>kj</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></msub></math> we can change
this gate to <!-- l. 837 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><msub><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mi>k</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></msub></mrow></math>,
which acts as <!-- l. 837 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><msub><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mi>k</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><mi>j</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iα</mi><msub><mrow><mi>δ</mi></mrow><mrow><mi mathvariant='italic'>jk</mi></mrow></msub></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>j</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>,
where <!-- l. 837 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>δ</mi></mrow><mrow><mi mathvariant='italic'>jk</mi></mrow></msub></math>
is the Kronecker delta. There is a little bit of a subtlety around
constructing these 1-level and 2-level operators: we saw in the previous
section that in general we need to have a zeroed ancilla in order to
construct unitaries with many controls. We hence can’t easily make
<!-- l. 838 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>-controlled single-qubit
unitaries on a <!-- l. 838 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit
circuit, since we need to have the additional space for an ancilla available to
us. But then the gate is no longer controlled on all the values, and it
stops being a 2-level operator (it will instead be a 4-level operator, since
it acts non-trivially on its states regardless of the state of the ancilla).
This will usually not be a problem however if we are assuming that the
ancilla is zeroed, since it ends up back in the zeroed state. Since the
<!-- l. 838 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> state
of the ancilla doesn’t come into play, the unitary will ‘effectively’ be a 2-level
operator. We will need these 2-level and 1-level operators when we talk about
which unitaries we can exactly write down using Clifford+T gates in Chapter <a href='main_htmlch10.html#cliffordt'>10<!-- tex4ht:ref: ch:clifford-t  --></a>,
specifically in Section*<a href='main_htmlch10.html#exact-synthesis-of-cliffordt-states'>10.7.1<!-- tex4ht:ref: sec:synthesis-exact-clifford-t  --></a>.
</p>
   <h4 class='subsectionHead' id='more-rules-for-the-hbox'><span class='titlemark'>9.7.3   </span> <a id='x11-2330009.7.3'></a>More rules for the H-box*</h4>
<!-- l. 841 --><p class='noindent'>In Section <a href='#rules-for-the-hbox'>9.2.2<!-- tex4ht:ref: sec:zh  --></a> we covered the rules involving H-boxes that come up the most
often, which are summarised in Figure <a href='#the-basic-rules-for-hboxes-'>9.0<!-- tex4ht:ref: fig:zh-rules  --></a>. But there is another set of
rewrite rules that deal specifically with H-boxes that are not labelled by
<!-- l. 841 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math>, but
instead can be labelled by arbitrary complex numbers. Whereas those rules of
Figure <a href='#the-basic-rules-for-hboxes-'>9.0<!-- tex4ht:ref: fig:zh-rules  --></a> give us completeness of the phase-free fragment of H-boxes when
combined with the phase-free ZX rules of Figure <a href='main_htmlch4.html#the-rules-of-the-phasefree-zx-calculus-the-spider-rules-sp-and-strong-complementarity-sc-note-the-righthandside-of-the-sc-rule-is-a-complete-bipartite-graph-of-m-z-spiders-and-n-x-spiders-with-a-normalisation-factor-mn-which-we-typically-drop-when-scalar-factors-are-irrelevant'>4.0<!-- tex4ht:ref: fig:pp-zx  --></a>, adding the rules we will see
in these sections give us completeness for the <span class='cmti-10x-x-109'>universal </span>fragment where
we can represent arbitrary linear maps over the complex numbers. The
first two of the new rules allow us to perform arithmetic with H-boxes:
</p><table class='equation'><tr><td>
<!-- l. 843 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 843 --><object id='x11-233001r89' data="svgs/eq-multiply-average.svg" alt="diagram of eq:multiply-average" class="svg-diagram"></object></td><td class='eq-no'>(9.89)</td></tr></table>
<!-- l. 846 --><p class='indent'>   We call these the <span class='cmbx-10x-x-109'>multiply rule </span>and the <span class='cmbx-10x-x-109'>average rule</span>. When
<!-- l. 847 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>a</mi></math> and
<!-- l. 847 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>b</mi></math> are
complex phases, the multiply rule is just an instance of the adding of phases
when spiders fuse, cf. (<a href='#x11-222001r21'>9.21<!-- tex4ht:ref: eq:H-state-as-Z  --></a>) and (<a href='main_htmlch3.html#x5-59002r35'>3.35<!-- tex4ht:ref: eq:phases-add  --></a>). The average rule has no counterpart in
the standard ZX-calculus. The multiply rule can be generalised to H-boxes of
arbitrary arity: </p><table class='equation'><tr><td>
<!-- l. 850 --><p class='indent'>
</p><!-- l. 850 --><object id='x11-233002r90' data="svgs/eq-mult-rule-many.svg" alt="diagram of eq:mult-rule-many" class="svg-diagram"></object></td><td class='eq-no'>(9.90)</td></tr></table>
<!-- l. 853 --><p class='indent'>   I.e. when two H-boxes are connected to exactly the same set of Z-spiders,
then we can fuse the H-boxes together. With the rules we have seen before, the
proof of this generalisation is straightforward: </p><table class='equation'><tr><td>
<!-- l. 855 --><p class='indent'>
</p><!-- l. 855 --><object id='x11-233003r91' data="svgs/multiply-rule-many-pf.svg" alt="diagram of multiply-rule-many-pf" class="svg-diagram"></object></td><td class='eq-no'>(9.91)</td></tr></table>
<!-- l. 858 --><p class='indent'>   Using this rule we can prove that two controlled-phase gates combine
together: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 859 --><object data="svgs/CCZ-alpha-combine.svg" alt="diagram of CCZ-alpha-combine" class="svg-diagram"></object></td></tr></table>
<!-- l. 862 --><p class='indent'>   This should all look quite familiar: Eq. (<a href='#x11-233002r90'>9.90<!-- tex4ht:ref: eq:mult-rule-many  --></a>) is like the phase gadget fusion
rule of Section <a href='main_htmlch7.html#phase-gadgets'>7.1.2<!-- tex4ht:ref: sec:phase-gadgets  --></a>. While a phase gadget adds a phase depending on the XOR
of the inputs, a controlled-phase gate build using an H-box adds a phase based
on the AND of the inputs. Then there is only one more rule we will need, the
<span class='cmbx-10x-x-109'>introduction rule</span>: </p><table class='equation'><tr><td>
<!-- l. 864 --><p class='indent'>
</p><!-- l. 864 --><object id='x11-233004r92' data="svgs/eq-intro-rule.svg" alt="diagram of eq:intro-rule" class="svg-diagram"></object></td><td class='eq-no'>(9.92)</td></tr></table>
<!-- l. 867 --><p class='indent'>   We call it the introduction rule, because it allows us to introduce additional
edges to an H-box (at the cost of copying the H-box). As do many of the
previously introduced rules, it has a generalisation to H-boxes of arbitrary arity:
</p><table class='equation'><tr><td>
<!-- l. 868 --><p class='indent'>
</p><!-- l. 868 --><object id='x11-233005r93' data="svgs/eq-intro-rule-many.svg" alt="diagram of eq:intro-rule-many" class="svg-diagram"></object></td><td class='eq-no'>(9.93)</td></tr></table>
   <div class='newtheorem'>
                                                                     

                                                                     
<!-- l. 871 --><p class='noindent'><span class='head'>
<a id='x11-233006r18'></a>
<span class='cmbx-10x-x-109'>Exercise 9.18.</span>  </span>Prove  Eq. (<a href='#x11-233005r93'>9.93<!-- tex4ht:ref: eq:intro-rule-many  --></a>),  using  Eq. (<a href='#x11-233004r92'>9.92<!-- tex4ht:ref: eq:intro-rule  --></a>)  and  the  previously
introduced H-box and ZX rules.
</p>
   </div>
<!-- l. 873 --><p class='indent'>    Most of the use-cases of this rule are when it is applied from right-to-left.
Indeed, it is a close cousin of the multiply rule (<a href='#x11-233002r90'>9.90<!-- tex4ht:ref: eq:mult-rule-many  --></a>). Both rules target pairs of
H-boxes connected to the same set of Z-spiders, although in the case of the
introduction rule, they must also differ by a NOT gate on one of the
connections, and have the same label. As an example, we can use the
introduction rule to prove that if we apply both a controlled-phase gate, and a
NOT-conjugated controlled-phase gate that this reduces to just a simple phase
gate: </p><table class='equation'><tr><td>
<!-- l. 876 --><p class='indent'>
</p><!-- l. 876 --><object id='x11-233007r94' data="svgs/control-phase-intro-reduce.svg" alt="diagram of control-phase-intro-reduce" class="svg-diagram"></object></td><td class='eq-no'>(9.94)</td></tr></table>
<!-- l. 879 --><p class='indent'>   As noted above, the ‘AND inspired’ rules together with the ZX-calculus rules
are complete for diagrams generated by Toffoli and Hadamard gates. When we
add these three additional rules, multiply, average and introduction, we get a rule
set that is complete for <span class='cmti-10x-x-109'>all </span>diagrams. Hence, we can, in principle, replace all
reasoning about qubit linear maps with diagrammatic reasoning. Whether
it is beneficial to do so of course depends on the situation. Note that
in Section <a href='main_htmlch10.html#catalysing-completeness'>10.5.3<!-- tex4ht:ref: sec:catalysing-completeness  --></a> we will see a different way in which we can extend
the fragment of phase-free H-boxes to larger fragments while retaining
completeness.
</p>
   <div class='newtheorem'>
<!-- l. 882 --><p class='noindent'><span class='head'>
<a id='x11-233008r19'></a>
                                                                     

                                                                     
<span class='cmbx-10x-x-109'>Exercise* 9.19.</span>  </span> We allowed H-boxes to be labelled by an arbitrary complex
number, but it turns out that we can represent all of these using just H-boxes
which are labelled by a complex phase. You may ignore scalar factors in this
exercise.
   </p><dl class='enumerate'><dt class='enumerate'>
a) </dt><dd class='enumerate'>
   <!-- l. 885 --><p class='noindent'>Show that <img src="svgs/Hbox-zero-is-X.svg" alt="diagram of Hbox-zero-is-X" class="inline-diagram" /> . Hint: Use the average rule with
   <!-- l. 887 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>,
   <!-- l. 887 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>b</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></math>.
   </p></dd><dt class='enumerate'>
b) </dt><dd class='enumerate'>
   <!-- l. 888 --><p class='noindent'>Show that for any <!-- l. 888 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>0</mn> <mo class='MathClass-rel' stretchy='false'>≤</mo> <mi>r</mi> <mo class='MathClass-rel' stretchy='false'>≤</mo> <mn>1</mn></mrow></math>
   we can find an <!-- l. 888 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>α</mi></math>
   such that we can represent the <!-- l. 888 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>r</mi></math>-labelled
   H-box using an <!-- l. 888 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iα</mi></mrow></msup></math>-labelled
   H-box and an <!-- l. 888 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>iα</mi></mrow></msup></math>-labelled
   H-box.
   </p></dd><dt class='enumerate'>
c) </dt><dd class='enumerate'>
   <!-- l. 889 --><p class='noindent'>Show that <img src="svgs/Hbox-inverses-with-X.svg" alt="diagram of Hbox-inverses-with-X" class="inline-diagram" /> . Hint: use the multiply rule
   and the ‘zero wire version‘ of Eq. (<a href='#x11-233005r93'>9.93<!-- tex4ht:ref: eq:intro-rule-many  --></a>).
   </p></dd><dt class='enumerate'>
d) </dt><dd class='enumerate'>
   <!-- l. 892 --><p class='noindent'>Show that we can represent (up to non-zero scalar) an arbitrary <!-- l. 892 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>a</mi></math>-labelled
   H-box using spiders and complex-phase labelled H-boxes. Hint: first write
   <!-- l. 892 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>a</mi></math>
   in the polar decomposition <!-- l. 892 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>r</mi><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>i𝜃</mi></mrow></msup></mrow></math>
   for some <!-- l. 892 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>r</mi> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mn>0</mn></mrow></math>
   and <!-- l. 892 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝜃</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℝ</mi></mrow></math>.
   Then make a case distinction based on whether <!-- l. 892 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>r</mi> <mo class='MathClass-rel' stretchy='false'>&gt;</mo> <mn>1</mn></mrow></math>
   or not. </p></dd></dl>
   </div>
<!-- l. 894 --><p class='indent'>
</p>
   <h4 class='subsectionHead' id='wspiders'><span class='titlemark'>9.7.4   </span> <a id='x11-2340009.7.4'></a>W-spiders*</h4>
                                                                     

                                                                     
<!-- l. 896 --><p class='noindent'>In this chapter we introduced the H-box to help us reason about Toffoli-like
gates. The H-box is nice to work with, because it acts like a spider (Eq. (<a href='#x11-222005r25'>9.25<!-- tex4ht:ref: eq:Hbox-spider  --></a>)),
and it interacts via a bialgebra rule with the Z-spider, as we saw in (<a href='#x11-222009r29'>9.29<!-- tex4ht:ref: eq:ZH-bialgebra-AND  --></a>):
</p><table class='equation'><tr><td>
<!-- l. 897 --><p class='indent'>
</p><!-- l. 897 --><object id='x11-234001r95' data="svgs/eq-ZH-bialgebra-AND2.svg" alt="diagram of eq:ZH-bialgebra-AND2" class="svg-diagram"></object></td><td class='eq-no'>(9.95)</td></tr></table>
<!-- l. 900 --><p class='indent'>   This works because an H-box followed by a Hadamard is equal to the
classical AND operation acting on computational basis states. In the same
way, the X-spider has a bialgebra rule with the Z-spider, because the
X-spider is equal to the classical XOR. It turns out that up to some trivial
modifications, there is exactly one other spider-like map that interacts
with the Z-spider via a bialgebra rule, and that is the partial map Add:
</p><table class='equation-star'><tr><td>
<!-- l. 902 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mstyle class='text'><mtext>Add</mtext></mstyle><mo class='MathClass-rel' stretchy='false'>|</mo><mi>x</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mrow class='cases'> <mrow><mo fence='true' form='prefix'>{</mo><mrow> <mtable align='axis' class='array' columnlines='none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='left'><mo class='MathClass-rel' stretchy='false'>|</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>y</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='quad' width='1em'></mspace></mtd><mtd class='array-td' columnalign='left'><mstyle class='text'><mtext>if </mtext></mstyle><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>y</mi><mo class='MathClass-rel' stretchy='false'>≠</mo><mn>1</mn> </mtd></mtr>  <mtr class='array-row'><mtd class='array-td' columnalign='left'><mn>0</mn> <mspace class='quad' width='1em'></mspace> </mtd> <mtd class='array-td' columnalign='left'><mstyle class='text'><mtext>otherwise</mtext></mstyle></mtd></mtr> <!-- @{}l@{\quad }l@{} --></mtable>                                                                            </mrow><mo fence='true' form='postfix'></mo></mrow></mrow>
</mrow></math></td></tr></table>
<!-- l. 909 --><p class='indent'>   That is: it adds together the value of the two basis states, <span class='cmti-10x-x-109'>as long as </span>their sum is not greater
than 1. If both <!-- l. 909 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>x</mi></math>
and <!-- l. 909 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>y</mi></math>
are 1, then their sum should be 2, but this doesn’t ‘fit’ into a single qubit, and so
it is sent to the scalar zero. It is hence quite similar to the XOR, except that the
<!-- l. 909 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>11</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> input
is sent to zero. As matrices: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 910 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mstyle class='text'><mtext>XOR</mtext></mstyle><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn></mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                               </mrow><mo fence='true' form='postfix'>)</mo></mrow><mspace class='qquad' width='2em'></mspace><mspace class='quad' width='1em'></mspace><mstyle class='text'><mtext>Add</mtext></mstyle><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace> <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn></mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                                               </mrow><mo fence='true' form='postfix'>)</mo></mrow>
</mrow></math></td></tr></table>
<!-- l. 923 --><p class='indent'>   We saw in Section <a href='#and-gates'>9.2.1<!-- tex4ht:ref: sec:AND-gates  --></a> that the reason we work with H-boxes
instead of AND gates directly, is because H-boxes have <span class='cmbx-10x-x-109'>flexsymmetry</span>,
meaning we can treat inputs and outputs on the same footing and
bend wires as we wish. To make the AND flexsymmetric, we had to
compose it with a Hadamard. In an analogous way, the Add map, and its
<!-- l. 923 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit
input generalisation, is not flexsymmetric, but we can make it flexsymmetric by
composing it with a NOT. We can easily see this when we write Add in terms of
kets and bras: </p><table class='equation-star'><tr><td>
<!-- l. 924 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
 <mstyle class='text'><mtext>Add</mtext></mstyle><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mn>00</mn><mo class='MathClass-rel' stretchy='false'>|</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mn>01</mn><mo class='MathClass-rel' stretchy='false'>|</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mn>10</mn><mo class='MathClass-rel' stretchy='false'>|</mo><mspace class='qquad' width='2em'></mspace><mspace class='quad' width='1em'></mspace><mstyle class='text'><mtext>NOT</mtext></mstyle> <mo class='MathClass-bin' stretchy='false'>∘</mo><mstyle class='text'><mtext>Add</mtext></mstyle><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mn>00</mn><mo class='MathClass-rel' stretchy='false'>|</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mn>01</mn><mo class='MathClass-rel' stretchy='false'>|</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mn>10</mn><mo class='MathClass-rel' stretchy='false'>|</mo>
</mrow></math></td></tr></table>
<!-- l. 927 --><p class='indent'>   This ‘flexsymmetrised’ Add consists of all ket-bra pairs that have exactly one
<!-- l. 927 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>, with
the same role being played by inputs and outputs. Hence, when we bend the
wires so that it is a state, we get the following: </p><table class='equation'><tr><td>
<!-- l. 928 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 928 --><object id='x11-234002r96' data="svgs/W-from-Add.svg" alt="diagram of W-from-Add" class="svg-diagram"></object></td><td class='eq-no'>(9.96)</td></tr></table>
<!-- l. 931 --><p class='indent'>   where <!-- l. 931 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>
is the <span class='cmbx-10x-x-109'>Hamming weight </span>of the bitstring
<!-- l. 931 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></math>, i.e. the number of
1s that appear in <!-- l. 931 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></math>.
This state is known as the <span class='cmbx-10x-x-109'>W-state</span>. The W-state is important in entanglement
theory as it is a nice representative of a certain type of genuine three-party
entanglement, where one party can do a measurement, and the other two parties
are still left with a maximally entangled state (compare this to the GHZ state
<!-- l. 932 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>000</mn><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mn>111</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
where when someone does a measurement, the state completely disconnects). But
for us that is all not important, except that it motivates the name for the
<span class='cmbx-10x-x-109'>W-spider</span>: </p><table class='equation'><tr><td>
<!-- l. 934 --><p class='indent'>
</p><!-- l. 934 --><object id='x11-234003r97' data="svgs/eq-W-spider.svg" alt="diagram of eq:W-spider" class="svg-diagram"></object></td><td class='eq-no'>(9.97)</td></tr></table>
<!-- l. 937 --><p class='indent'>   The 0-input 3-output W-spider is the W-state, while with a single input and
output we get the NOT gate: </p><table class='equation'><tr><td>
<!-- l. 938 --><p class='indent'>
</p><!-- l. 938 --><object id='x11-234004r98' data="svgs/W-not.svg" alt="diagram of W-not" class="svg-diagram"></object></td><td class='eq-no'>(9.98)</td></tr></table>
                                                                     

                                                                     
<!-- l. 941 --><p class='indent'>   The W-spider (<a href='#x11-234003r97'>9.97<!-- tex4ht:ref: eq:W-spider  --></a>) has all the same symmetries that Z- and X-spiders have:
we can permute inputs and outputs freely, and we can interchange inputs with
outputs using cups and caps. However, just as with H-boxes, it has a modified
spider-fusion rule, which requires a 2-ary spider to be in the middle (cf. (<a href='#x11-222005r25'>9.25<!-- tex4ht:ref: eq:Hbox-spider  --></a>)):
</p><table class='equation'><tr><td>
<!-- l. 943 --><p class='indent'>
</p><!-- l. 943 --><object id='x11-234005r99' data="svgs/eq-W-spider-rule.svg" alt="diagram of eq:W-spider-rule" class="svg-diagram"></object></td><td class='eq-no'>(9.99)</td></tr></table>
<!-- l. 946 --><p class='indent'>   For the H-box we needed something in the middle, as the H-box followed by a
Hadamard was the AND map, which could fuse together due to its associativity.
We have the same situation with the W-spider, but now using the associativity of
Add: </p><table class='equation'><tr><td>
<!-- l. 947 --><p class='indent'>
</p><!-- l. 947 --><object id='x11-234006r100' data="svgs/W-as-Add.svg" alt="diagram of W-as-Add" class="svg-diagram"></object></td><td class='eq-no'>(9.100)</td></tr></table>
<!-- l. 950 --><p class='indent'>   As promised, this relation to Add means that the W-spider interacts with the
Z-spider via a bialgebra rule: </p><table class='equation'><tr><td>
<!-- l. 951 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 951 --><object id='x11-234007r101' data="svgs/W-bialgebra.svg" alt="diagram of W-bialgebra" class="svg-diagram"></object></td><td class='eq-no'>(9.101)</td></tr></table>
<!-- l. 954 --><p class='indent'>   There are a number of other rules governing the interaction between the Z-
and W-spider: </p><table class='equation'><tr><td>
<!-- l. 955 --><p class='indent'>
</p><!-- l. 955 --><object id='x11-234008r102' data="svgs/W-rules.svg" alt="diagram of W-rules" class="svg-diagram"></object></td><td class='eq-no'>(9.102)</td></tr></table>
<!-- l. 958 --><p class='indent'>   In fact, we could build a whole calculus to rival the ZX-calculus using just the
Z- and W-spider, which is called the <span class='cmbx-10x-x-109'>ZW-calculus</span>. We didn’t really give it a
name before, but just thinking about Z-spiders and H-boxes, and viewing the
X-spiders as derived from their interactions, we can call this the <span class='cmbx-10x-x-109'>ZH-calculus</span>.
Note however that these calculi—ZX, ZW, ZH—can represent the same
linear maps, and hence have the same expressive power. However, certain
constructions will look more natural using one type of generator versus
another. Using Z- and X-spiders we can easily reason about Cliffords and
phase gates, with XOR-like phases captured with phase gadgets. Instead
using Z-spider and H-boxes we can easily represent controlled gates and
multiplicative phases. Using W-spiders we can easily represent additive structure,
which is not very prominent in quantum circuits, but is useful when
thinking about more general linear maps, and for proving completeness. For
instance, we can use a W-spider to represent the ‘addition’ of two H-boxes:
</p><table class='equation'><tr><td>
<!-- l. 961 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 961 --><object id='x11-234009r103' data="svgs/W-H-add.svg" alt="diagram of W-H-add" class="svg-diagram"></object></td><td class='eq-no'>(9.103)</td></tr></table>
<!-- l. 964 --><p class='indent'>   Note that a 3-ary W-spider can be decomposed into the ZH-calculus quite
easily: </p><table class='equation'><tr><td>
<!-- l. 965 --><p class='indent'>
</p><!-- l. 965 --><object id='x11-234010r104' data="svgs/W-as-Hbox.svg" alt="diagram of W-as-Hbox" class="svg-diagram"></object></td><td class='eq-no'>(9.104)</td></tr></table>
<!-- l. 968 --><p class='indent'>   This works because the W-spider is almost the Add, which is just the XOR with
the <!-- l. 968 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>11</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
output projected away. That projection is done by the H-box gadget in front of
the X-spider: </p><table class='equation'><tr><td>
<!-- l. 969 --><p class='indent'>
</p><!-- l. 969 --><object id='x11-234011r105' data="svgs/H0-gadget.svg" alt="diagram of H0-gadget" class="svg-diagram"></object></td><td class='eq-no'>(9.105)</td></tr></table>
<!-- l. 972 --><p class='indent'>   We won’t be using the W-spider in this book, but it would be remiss of us
to not mention it in a book that is all about graphical reasoning. The
W-spider and the ZW-calculus has played a crucial role in the history of the
ZX-calculus and its completeness. See the References for more pointers on
this.
                                                                     

                                                                     
</p>
   <h3 class='sectionHead' id='references-and-further-reading7'><span class='titlemark'>9.8   </span> <a id='x11-2350009.8'></a>References and further reading</h3>
<!-- l. 976 --><p class='noindent'><span class='paragraphHead' id='reversible-circuit-synthesis'><a id='x11-236000'></a><span class='cmbx-10x-x-109'>Reversible circuit synthesis</span></span>
   The relation between Boolean functions and DAGs was taken from [<a href='main_htmlli2.html#Xmeuli2019reversible'>176</a>].
They also introduce a ‘pebbling’ strategy that we alluded to, where values are
uncomputed and recomputed in order to stay under a circuit budget of
additional memory bits. They do this by encoding the synthesis as a
SAT instance and then SAT solving it, increasing the number of allowed
gates and memory bits until they find a satisfying solution. The trick to
reduce the number of bits needed by always computing and uncomputing
XORs was taken from [<a href='main_htmlli2.html#XMeuli2019Multplicative'>175</a>]. See also [<a href='main_htmlli2.html#XEPTCS318.8'>177</a>]. Both these papers also use a
pebbling strategy, but one that takes into account the fact that XORs are
cheap.
</p>
<!-- l. 979 --><p class='noindent'><span class='paragraphHead' id='hboxes1'><a id='x11-237000'></a><span class='cmbx-10x-x-109'>H-boxes</span></span>
   The H-box was introduced by [<a href='main_htmlli2.html#Xbackens2018zhcalculus'>21</a>], which proved completeness of the calculus
in the universal fragment. This was followed up by [<a href='main_htmlli2.html#Xzhcompleteness2020'>22</a>] which proved
that the phase-free fragment could also be made complete. The Fourier
decomposition of an H-box is from [<a href='main_htmlli2.html#XGraphicalFourier2019'>159</a>]. The term ‘flexsymmetry’ was coined
in [<a href='main_htmlli2.html#Xcarette2021when'>48</a>].
</p>
<!-- l. 981 --><p class='noindent'><span class='paragraphHead' id='decomposing-toffoli-gates'><a id='x11-238000'></a><span class='cmbx-10x-x-109'>Decomposing Toffoli gates</span></span>
   Section <a href='#constructing-toffoli-gates-with-many-controls'>9.4<!-- tex4ht:ref: sec:Toffoli-decompositions  --></a> on how to decompose many-controlled Toffoli’s into smaller
Toffoli’s was heavily inspired by a blogpost by Craig Gidney [<a href='main_htmlli2.html#XGidneyToffoliBlog'>102</a>], from
which we have also taken the term ‘borrowed bit’. That at least 7
<!-- l. 983 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates are necessary to implement a Toffoli or CCZ when restricting to
unitary circuits was shown in [<a href='main_htmlli2.html#Xmeet-in-the-middle2013'>10</a>, <a href='main_htmlli2.html#Xdi2016parallelizing'>85</a>]. That a Toffoli gate combined with
a CS gate is cheaper was first realised by Selinger [<a href='main_htmlli2.html#Xselinger2013quantum'>206</a>]. Jones came
up with the trick to use an ancilla to reduce the cost [<a href='main_htmlli2.html#Xjones2013low'>137</a>] to four
<!-- l. 983 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates. The
‘compute-uncompute’ construction that reduces the cost of a pair of Toffoli gates to
just four <!-- l. 984 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates was found by Gidney [<a href='main_htmlli2.html#XGidney2018halvingcostof'>103</a>]. This paper also gives the
description of the adder circuit we use in Section <a href='#adders'>9.5<!-- tex4ht:ref: sec:adders  --></a>. The graphical
approach to deriving these identities was developed in [<a href='main_htmlli2.html#XGraphicalFourier2019'>159</a>]. The 6
<!-- l. 986 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
construction of the CCCZ in Exercise <a href='#x11-226017r13'>9.13<!-- tex4ht:ref: exer:CCCZ-Gidney  --></a> is from [<a href='main_htmlli2.html#Xgidney2021cccz'>106</a>]. A structured approach
                                                                     

                                                                     
to finding these types of decompositions is given in [<a href='main_htmlli2.html#XPhysRevA.104.052602'>17</a>].
</p>
<!-- l. 988 --><p class='noindent'><span class='paragraphHead' id='wspiders1'><a id='x11-239000'></a><span class='cmbx-10x-x-109'>W-spiders</span></span>
   The W-spider was introduced in [<a href='main_htmlli2.html#XCoeckeKissinger2010compositional'>61</a>]. This was extended to a complete
ZW-calculus by [<a href='main_htmlli2.html#Xhadzihasanovic2015diagrammatic'>122</a>]. It was this ZW-calculus that formed the basis for the first
completeness results of a universal fragment of the ZX-calculus [<a href='main_htmlli2.html#XHarnyAmarCompleteness'>123</a>, <a href='main_htmlli2.html#XSimonCompleteness'>136</a>]. That
ZX, ZW, and ZH are essentially the only three possible graphical calculi for
qubits was shown in [<a href='main_htmlli2.html#Xcarette2020recipe'>50</a>]. Using W-spiders to represent arithmetic was first done
in [<a href='main_htmlli2.html#XCKMR'>54</a>], and then developed much further in [<a href='main_htmlli2.html#Xwang2022differentiating'>232</a>], where they show how to
represent the sum of two diagrams as a single diagram. This was done
independently in [<a href='main_htmlli2.html#Xjeandel2022addition'>135</a>], although there the W-spiders are a bit more hidden by
the use of the ‘triangle generator’. For more details on how these different
generators of H-boxes, W-spiders and triangles relate to each other, we
refer the reader to [<a href='main_htmlli2.html#Xvandewetering2020zxcalculus'>222</a>, Section 9].    </p><!-- l. 7 --><div class='crosslinks'><p class='noindent'>[<a href='main_htmlch10.html'>next</a>] [<a href='main_htmlch8.html'>prev</a>] [<a href='main_htmlch8.html#tailmain_htmlch8.html'>prev-tail</a>] [<a href='main_htmlch9.html'>front</a>] [<a href='main_html.html#main_htmlch9.html'>up</a>]
</p></div>
<!-- l. 7 --><p class='indent'>   <a id='tailmain_htmlch9.html'></a></p> 
<script type="text/javascript" src="proof_collapse.js"></script> 
<script type="text/javascript" src="navigation_menu.js"></script> </body> 
</html>