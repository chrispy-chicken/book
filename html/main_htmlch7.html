<!DOCTYPE html> 
<html lang='en-US' xml:lang='en-US'> 
<head><title>7 Universal circuits</title> 
<meta charset='utf-8' /> 
<meta content='TeX4ht (https://tug.org/tex4ht/)' name='generator' /> 
<meta content='width=device-width,initial-scale=1' name='viewport' /> 
<link href='main_html.css' rel='stylesheet' type='text/css' /> 
<meta content='main_html.tex' name='src' /> 
 <script async='async' id='MathJax-script' src='https://cdn.jsdelivr.net/npm/mathjax@3/es5/mml-chtml.js' type='text/javascript'></script>  
</head><body>
   <!-- l. 7 --><div class='crosslinks'><p class='noindent'>[<a href='main_htmlch8.html'>next</a>] [<a href='main_htmlch6.html'>prev</a>] [<a href='main_htmlch6.html#tailmain_htmlch6.html'>prev-tail</a>] [<a href='#tailmain_htmlch7.html'>tail</a>] [<a href='main_html.html#main_htmlch7.html'>up</a>] </p></div>
   <h2 class='chapterHead' id='universal-circuits'><span class='titlemark'>Chapter 7</span><br /><a id='x9-1550007'></a>Universal circuits</h2>
<!-- l. 9 --><p class='noindent'>We will now turn from studying Clifford circuits to universal ones.
Whereas the Clifford circuits were generated from CNOT, H, and S
gates, we can obtain an exactly universal set of gates by replacing the
<!-- l. 9 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>S</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi>Z</mi><mo class='MathClass-open' stretchy='false'>[</mo><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> <mo class='MathClass-close' stretchy='false'>]</mo></mrow></math> gate with the
family of <!-- l. 9 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math> gates for
arbitrary angles <!-- l. 9 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>α</mi></math>.
Perhaps more miraculously, we can obtain an approximately universal set of gates by replacing
<!-- l. 10 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math> with some fixed
phase gate <!-- l. 10 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>𝜃</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math> for <span class='cmti-10x-x-109'>any</span>
<!-- l. 10 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>𝜃</mi></math> that isn’t a multiple
of <!-- l. 10 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>π</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn></mrow></math>, the most popular
choice being <!-- l. 10 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>T</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msqrt><mrow><mi>S</mi></mrow></msqrt> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>Z</mi><mo class='MathClass-open' stretchy='false'>[</mo><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> <mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>.
This tiny tweak takes us from the safe, efficient world of Clifford circuits to
the wild and wonderful world of full-powered quantum computation.
Given we can no longer efficiently compute the outputs of a universal
quantum circuit with a classical computer, one might wonder how much we
<span class='cmti-10x-x-109'>can </span>still reason about these circuits. In this chapter we’ll see that the
answer is, perhaps surprisingly, quite a lot! In this chapter we will see
two different ways to think of universal circuits: <span class='cmbx-10x-x-109'>path sums </span>and <span class='cmbx-10x-x-109'>Pauli
exponentials</span>. Path sums are an extension of the idea of phase polynomials.
We already briefly encountered phase polynomials in Chapter <a href='main_htmlch5.html#clifford-circuits-and-diagrams'>5<!-- tex4ht:ref: ch:clifford  --></a> when
discussing the AP normal form. In the same way that we could fully
characterise a CNOT circuit as a parity matrix in Chapter <a href='main_htmlch4.html#cnot-circuits-and-phasefree-zxdiagrams'>4<!-- tex4ht:ref: ch:phasefree  --></a>, it turns out
we can fully characterise a circuit consisting of CNOT gates and phase
gates as a phase polynomial together with a parity matrix. However, this
representation only deals with Hadamard-free circuits. To also work with
Hadamards we need path sums. We can write the action of a Hadamard as
<!-- l. 14 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><msub><mrow><mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>y</mi></mrow></msub><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi>x</mi><mo class='MathClass-bin' stretchy='false'>⋅</mo><mi>y</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>y</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
In a path sum we interpret this as introducing a new variable
<!-- l. 14 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>y</mi></math> on your qubit,
and adding a term <!-- l. 14 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi>x</mi><mo class='MathClass-bin' stretchy='false'>⋅</mo><mi>y</mi></mrow></msup></math>
to your phase polynomial. The final expression for your circuit then contains a
sum <!-- l. 14 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>y</mi></mrow></msub></math>
over all the different ‘paths’ a computational basis state can take trough your
circuit. On the other hand, Pauli exponentials offer quite a different perspective
on universal circuits. We have seen in the previous chapters that there is a whole
lot to be said about the Pauli gates. They allow us to define stabiliser theory and
Pauli projections, which lead to the idea of stabiliser states and Cliffords, which
have a rich rewrite theory and will allow us to define quantum error correction in
Chapter <a href='main_htmlch11.html#quantum-error-correction'>11<!-- tex4ht:ref: ch:qec  --></a>. But on the other hand the Clifford computation we have seen is
                                                                     

                                                                     
efficiently classically simulable, so if we want to get our money’s worth
with a real quantum computer, we had better do something more than
just Cliffords. Luckily we don’t have to look far, we can still work with
Paulis, but just in a slightly modified form. It turns out that for any Pauli
<!-- l. 17 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></math> we
can construct a family of unitaries out of it by considering the matrix exponential
<!-- l. 17 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>i𝜃</mi><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow></msup></math> for
phases <!-- l. 17 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝜃</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℝ</mi></mrow></math>.
The resulting <span class='cmbx-10x-x-109'>Pauli exponentials </span>form a universal gate set for quantum
computing. Certain Pauli exponentials also correspond to the native gate set of
several types of quantum computers, like ion traps and superconducting quantum
computers. In fact, Pauli exponentials form arguably <span class='cmti-10x-x-109'>the </span>native gate set to
understand quantum computation. They have a natural relation to Clifford
computation; the number of them in a circuit directly corresponds to the cost of
classically simulating a quantum computation; Hamiltonian simulation can be
directly understood in terms of Pauli exponentials; Pauli exponentials can be
readily understood in certain quantum error correcting codes like the surface
code; and finally, which is important for us, Pauli exponentials have a very
natural representation in the ZX-calculus.
</p>
   <h3 class='sectionHead' id='path-sums'><span class='titlemark'>7.1   </span> <a id='x9-1560007.1'></a>Path sums</h3>
<!-- l. 20 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='phase-polynomials'><span class='titlemark'>7.1.1   </span> <a id='x9-1570007.1.1'></a>Phase polynomials</h4>
<!-- l. 21 --><p class='noindent'>First, let us recap what we know about phase polynomials. Lets begin with a
neat trick that works for any circuit built only out of CNOT and Z-phase gates.
We already learned back in Chapter <a href='main_htmlch4.html#cnot-circuits-and-phasefree-zxdiagrams'>4<!-- tex4ht:ref: ch:phasefree  --></a> that CNOT circuits correspond to parity
maps, i.e. linear maps which send basis states to other basis states that
can be described as the parities of input variables. We also saw that a
convenient way to compute the parity map is to label each input wire with a
distinct variable and simply push those variables through the circuit:
</p><table class='equation'><tr><td>
<!-- l. 23 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 23 --><object id='x9-157001r1' data="svgs/eq-cnot-parities-2.svg" alt="diagram of eq:cnot-parities-2" class="svg-diagram"></object></td><td class='eq-no'>(7.1)</td></tr></table>
<!-- l. 26 --><p class='indent'>   That is, we start with only the input wires labelled and work from left to
right. When a CNOT is encountered, we label the output of the control qubit
with the same label as the input of the control qubit and label the output of the
target qubit with the XOR of the labels on the two input qubits. In fact, this is
the same as computing the overall parity matrix by doing one primitive row
operation (i.e. CNOT gate) at a time. Indeed if we look at the action of the unitary
<!-- l. 27 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
described in (<a href='main_htmlch4.html#x6-90001r1'>4.1<!-- tex4ht:ref: eq:cnot-parities  --></a>), it maps basis states to an XOR of basis states given by the
expression on the output wires: </p><table class='equation'><tr><td>
<!-- l. 28 --><p class='indent'>
</p><!-- l. 28 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                    <mstyle class='label' id='x9-157002r2'></mstyle><!-- endlabel --><mi>U</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-punc' stretchy='false'>:</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>↦</mo><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo>
</mrow></math></td><td class='eq-no'>(7.2)</td></tr></table>
<!-- l. 31 --><p class='indent'>   We also saw in Chapter <a href='main_htmlch4.html#cnot-circuits-and-phasefree-zxdiagrams'>4<!-- tex4ht:ref: ch:phasefree  --></a> that any two CNOT circuits computing the
same parity function are equal. By re-synthesising a circuit according
to its parity function, we can often find a much more efficient
implementation. In the example above, we can implement the unitary
<!-- l. 31 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math> with
just one CNOT gate: </p><table class='equation'><tr><td>
<!-- l. 32 --><p class='indent'>
</p><!-- l. 32 --><object id='x9-157003r3' data="svgs/eq-cnot-parities-simp-2.svg" alt="diagram of eq:cnot-parities-simp-2" class="svg-diagram"></object></td><td class='eq-no'>(7.3)</td></tr></table>
                                                                     

                                                                     
<!-- l. 35 --><p class='indent'>   Now, lets sprinkle some Z-phase gates into the circuit (<a href='main_htmlch4.html#x6-90001r1'>4.1<!-- tex4ht:ref: eq:cnot-parities  --></a>) above:
</p><table class='equation'><tr><td>
<!-- l. 36 --><p class='indent'>
</p><!-- l. 36 --><object id='x9-157004r4' data="svgs/eq-cnot-phase-parities.svg" alt="diagram of eq:cnot-phase-parities" class="svg-diagram"></object></td><td class='eq-no'>(7.4)</td></tr></table>
<!-- l. 39 --><p class='indent'>   Note that we left the parity labels on the wires. Why are we justified in
doing that? Z-phase gates are diagonal in the Z basis, so they preserve
basis elements, up to a phase which depends on the basis element
<!-- l. 39 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>:
</p><table class='equation-star'><tr><td>
<!-- l. 40 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                          <mi>Z</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>]</mo> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-punc' stretchy='false'>:</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>↦</mo><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iα</mi><mo class='MathClass-bin' stretchy='false'>⋅</mo><mi>x</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>⟩</mo>
</mrow></math></td></tr></table>
<!-- l. 41 --><p class='indent'>   We can now plug a single computational basis element
<!-- l. 41 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
into (<a href='#x9-157004r4'>7.4<!-- tex4ht:ref: eq:cnot-phase-parities  --></a>) and track its progress through the circuit. Applying the first
two gates, we see the CNOT first updates the variables in the ket, then
the Z-phase gate introduces a new phase, which depends on whether
<!-- l. 41 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub></mrow></math> is
<!-- l. 41 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math> or
<!-- l. 41 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>:
                                                                     

                                                                     
</p><!-- tex4ht:inline --><!-- l. 46 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mtable class='align-star' columnalign='left' displaystyle='true'>
                <mtr><mtd class='align-odd' columnalign='right'><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo></mtd>                <mtd class='align-even'><mo class='MathClass-rel' stretchy='false'>↦</mo><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace width='2em'></mspace></mtd>                         <mtd class='align-label' columnalign='right'></mtd>                <mtd class='align-label'>
                <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>                          <mtd class='align-even'><mo class='MathClass-rel' stretchy='false'>↦</mo><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iα</mi><mo class='MathClass-bin' stretchy='false'>⋅</mo><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>⊕</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow>
<mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace width='2em'></mspace></mtd>                <mtd class='align-label' columnalign='right'></mtd>                <mtd class='align-label'>
   <mspace width='2em'></mspace></mtd></mtr></mtable></math>
<!-- l. 47 --><p class='noindent'>Continuing this through the rest of the circuit, the overall expression we get for the
unitary <!-- l. 47 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> </mrow></math>
described by circuit (<a href='#x9-157004r4'>7.4<!-- tex4ht:ref: eq:cnot-phase-parities  --></a>) is: </p><table class='equation'><tr><td>
<!-- l. 48 --><p class='indent'>
</p><!-- l. 48 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
       <mstyle class='label' id='x9-157005r5'></mstyle><!-- endlabel --><mi>V</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-punc' stretchy='false'>:</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>↦</mo><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mi>γ</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>⋅</mo><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>⊕</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>+</mo><mi>β</mi><mo class='MathClass-bin' stretchy='false'>⋅</mo><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>⊕</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>+</mo><mi>𝜃</mi><mo class='MathClass-bin' stretchy='false'>⋅</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>]</mo></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow>
<mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo>
</mrow></math></td><td class='eq-no'>(7.5)</td></tr></table>
<!-- l. 53 --><p class='indent'>   More generally, <span class='cmti-10x-x-109'>any </span>CNOT+phase circuit yields a unitary of the form:
</p><table class='equation-star'><tr><td>
<!-- l. 54 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                        <mi>U</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-punc' stretchy='false'>:</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>↦</mo><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iϕ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>L</mi><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo>
</mrow></math></td></tr></table>
<!-- l. 57 --><p class='indent'>   for some <!-- l. 57 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math> matrix
<!-- l. 57 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>L</mi></math> and function
<!-- l. 57 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ϕ</mi> <mo class='MathClass-punc' stretchy='false'>:</mo> <msubsup><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msubsup> <mo class='MathClass-rel' stretchy='false'>→</mo> <mi>ℝ</mi></mrow></math>. We already met the
parity matrix <!-- l. 57 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>L</mi></math>, which
describes <!-- l. 57 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>’s action on
basis vectors as an <!-- l. 57 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>-linear
map. To this we add <!-- l. 57 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ϕ</mi></math>,
which is called the <span class='cmbx-10x-x-109'>phase polynomial</span>. This describes the phase
associated with each input as a polynomial over XOR’s of the input
                                                                     

                                                                     
bits. Just as we could read the parity map off the labelled CNOT
circuit (<a href='main_htmlch4.html#x6-90001r1'>4.1<!-- tex4ht:ref: eq:cnot-parities  --></a>), we can read both the parity map and the phase polynomial
off of the labelled circuit (<a href='#x9-157004r4'>7.4<!-- tex4ht:ref: eq:cnot-phase-parities  --></a>). As before, we can read the parity map
off the output wires. For the phase polynomial, we introduce a term of
<!-- l. 58 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>α</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><msub><mrow><mi>j</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo><mo>…</mo> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><msub><mrow><mi>j</mi></mrow><mrow><mi>k</mi></mrow></msub></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> for each Z-phase
gate <!-- l. 58 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math> occurring on
a wire labelled <!-- l. 58 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><msub><mrow><mi>j</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo><mo>…</mo> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><msub><mrow><mi>j</mi></mrow><mrow><mi>k</mi></mrow></msub></mrow></msub></mrow></math>.
We can now come up with a new circuit that implements the same parity map
and phase polynomial. We will give a reasonably efficient, general-purpose circuit
synthesis algorithm for this in Section <a href='#circuit-synthesis-and-path-sums'>7.2<!-- tex4ht:ref: sec:synthesis  --></a>, but for now lets just focus
on our example. We already saw that, by ignoring the phase gates, we
could produce a very efficient circuit (<a href='main_htmlch4.html#x6-90005r3'>4.3<!-- tex4ht:ref: eq:cnot-parities-simp  --></a>) to implement the parity map
<!-- l. 59 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>↦</mo><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> of the
unitary <!-- l. 59 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> </mrow></math>.
In order to get the full unitary, we should inspect the phase polynomial of
<!-- l. 59 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> </mrow></math>:
</p><table class='equation-star'><tr><td>
<!-- l. 60 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
         <mi>ϕ</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>γ</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>β</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>𝜃</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub>
</mrow></math></td></tr></table>
<!-- l. 63 --><p class='indent'>   Going term-by-term, it looks like we need to place Z-phase gates on wires labelled with
the expressions <!-- l. 63 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub></mrow></math>,
<!-- l. 63 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></math>, and
<!-- l. 63 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub></math>.
Inspecting the circuit in (<a href='main_htmlch4.html#x6-90005r3'>4.3<!-- tex4ht:ref: eq:cnot-parities-simp  --></a>), we see that we already have wires labelled by
<!-- l. 63 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub></mrow></math> and
<!-- l. 63 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub></math>.
Unfortunately, <!-- l. 63 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></math>
is missing. However, we can temporarily make this parity available by
introducing a redundant pair of CNOT gates: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 64 --><object data="svgs/cnot-parities-simp.svg" alt="diagram of cnot-parities-simp" class="svg-diagram"></object></td></tr></table>
<!-- l. 67 --><p class='indent'>   We can then recover the full circuit for
<!-- l. 67 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> </mrow></math> by placing
Z-phase gates <!-- l. 67 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>α</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>γ</mi></mrow></math> on
any wire labelled <!-- l. 67 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub></mrow></math>,
<!-- l. 67 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>β</mi></math> on
<!-- l. 67 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></math> and
<!-- l. 67 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>𝜃</mi></math> on
<!-- l. 67 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub></math>:
</p><table class='equation'><tr><td>
<!-- l. 68 --><p class='indent'>
</p><!-- l. 68 --><object id='x9-157006r6' data="svgs/eq-cnot-phase-parities-simp.svg" alt="diagram of eq:cnot-phase-parities-simp" class="svg-diagram"></object></td><td class='eq-no'>(7.6)</td></tr></table>
<!-- l. 71 --><p class='indent'>   By computing the phase polynomial and re-synthesising, we reduced the circuit
(<a href='#x9-157004r4'>7.4<!-- tex4ht:ref: eq:cnot-phase-parities  --></a>), which had 6 CNOT gates and 4 Z-phase gates to (<a href='#x9-157006r6'>7.6<!-- tex4ht:ref: eq:cnot-phase-parities-simp  --></a>), which has 3 CNOT
gates and 3 Z-phase gates, giving a significant savings. Notably, if two phases
occur at the <span class='cmti-10x-x-109'>same </span>parity, even in totally different parts of the circuit, their angles
add in the phase polynomial. Hence they can always be re-synthesised into the
same phase gate. This phenomenon is called <span class='cmbx-10x-x-109'>phase-folding</span>, and is one of the
major advantages of the phase polynomial approach. For example, two
phase gates in different parts of circuit (<a href='#x9-157004r4'>7.4<!-- tex4ht:ref: eq:cnot-phase-parities  --></a>) contributed a single term
<!-- l. 71 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>γ</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> to
the phase polynomial in (<a href='#x9-157005r5'>7.5<!-- tex4ht:ref: eq:phase-poly-ex  --></a>). When we re-synthesised the circuit in (<a href='main_htmlch4.html#x6-90005r3'>4.3<!-- tex4ht:ref: eq:cnot-parities-simp  --></a>), they
became a single phase gate.
</p>
   <div class='newtheorem'>
<!-- l. 72 --><p class='noindent'><span class='head'>
<a id='x9-157007r1'></a>
                                                                     

                                                                     
<span class='cmbx-10x-x-109'>Exercise 7.1.</span>  </span> Show that the phase polynomial representation also works
for circuits made of CNOT, Z-phase, and X gates, using the fact that an X
gate updates wire labels as follows:
</p>
<div class='center'>
<!-- l. 75 --><p class='noindent'>
</p><!-- l. 76 --><p class='noindent'><object data="svgs/x-gate-labels.svg" alt="diagram of x-gate-labels" class="svg-diagram"></object> </p></div>
<!-- l. 79 --><p class='indent'>   More specifically, give an example circuit, compute its parity map and phase
polynomial by wire-labelling, and re-synthesise a smaller circuit. Finally, show
that further simplifications are possible: namely expressions of the form
<!-- l. 80 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>α</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>y</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>β</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi>y</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>, where
<!-- l. 80 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>y</mi></math> is
some XOR of input variables, can be simplified in the phase polynomial, up to
global phases.
</p>
   </div>
<!-- l. 81 --><p class='indent'>
</p>
   <h4 class='subsectionHead' id='phase-gadgets'><span class='titlemark'>7.1.2   </span> <a id='x9-1580007.1.2'></a>Phase gadgets</h4>
<!-- l. 88 --><p class='noindent'>Phase polynomials give a very powerful, efficient way to manipulate CNOT+phase
circuits. Some might even (blasphemously!) suggest that they are more effective
than graphical techniques for many applications. However, it is nevertheless
useful to see how these structures are reflected in the ZX-calculus. Along the way,
we will meet certain little ZX diagrams called <span class='cmbx-10x-x-109'>phase gadgets</span>, which correspond
exactly to the terms in a phase polynomial. We’ll meet phase gadgets a lot in the
coming chapters, as they are really useful tools for lots of different applications,
so it is worth spending some time now getting a handle on how and why they
work. In this section, we’ll see how phase polynomials and in particular
phase-folding show up graphically. Note that in some cases phase folding
follows trivially from an application of spider fusion. For example, this
circuit:
</p>
<div class='center'>
<!-- l. 92 --><p class='noindent'>
</p><!-- l. 93 --><p class='noindent'><object data="svgs/phase-fold-trivial.svg" alt="diagram of phase-fold-trivial" class="svg-diagram"></object> </p></div>
                                                                     

                                                                     
<!-- l. 96 --><p class='indent'>   gives the following unitary: </p><table class='equation-star'><tr><td>
<!-- l. 97 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                 <mi>U</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-punc' stretchy='false'>:</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>↦</mo><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mi>β</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>⋅</mo><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>⊕</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow>
<mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo>
</mrow></math></td></tr></table>
<!-- l. 100 --><p class='indent'>   We see that the phases <!-- l. 100 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>α</mi></math>
and <!-- l. 100 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>β</mi></math>
combine in the phase polynomial. This can also be seen by commuting the
<!-- l. 100 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>α</mi></math>
phase gate through the control wire of the last CNOT gate via spider
fusion:
</p>
<div class='center'>
<!-- l. 102 --><p class='noindent'>
</p><!-- l. 103 --><p class='noindent'><object data="svgs/phase-fold-trivial-pf.svg" alt="diagram of phase-fold-trivial-pf" class="svg-diagram"></object> </p></div>
<!-- l. 106 --><p class='indent'>   However, as we saw in the last section, phases can merge together even in
completely different parts of the circuit. In this case, there is no obvious way to
apply spider fusion to merge them. Hence, we’ll need to develop a generalisation
of spider fusion, which allows distant phases in a CNOT+phase circuit to find
each other. Let’s start with a slight variation on the example from the previous
section: </p><table class='equation'><tr><td>
<!-- l. 108 --><p class='indent'>
</p><!-- l. 108 --><object id='x9-158001r7' data="svgs/eq-cnot-phase-diag.svg" alt="diagram of eq:cnot-phase-diag" class="svg-diagram"></object></td><td class='eq-no'>(7.7)</td></tr></table>
                                                                     

                                                                     
<!-- l. 111 --><p class='indent'>   All we’ve done is add one more CNOT gate at the end to make the overall parity
map <!-- l. 111 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>L</mi></math>
trivial. This unitary is now diagonal in the computational basis. That is, if we
wrote down its matrix, it would only have a bunch of phases down the diagonal,
as described by the phase polynomial. Explicitly, the circuit above implements
the following unitary: </p><table class='equation'><tr><td>
<!-- l. 112 --><p class='indent'>
</p><!-- l. 112 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
         <mstyle class='label' id='x9-158002r8'></mstyle><!-- endlabel --><mi>U</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-punc' stretchy='false'>:</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>↦</mo><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mi>γ</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>⋅</mo><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>⊕</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>+</mo><mi>β</mi><mo class='MathClass-bin' stretchy='false'>⋅</mo><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>⊕</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>+</mo><mi>𝜃</mi><mo class='MathClass-bin' stretchy='false'>⋅</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>]</mo></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow>
<mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo>
</mrow></math></td><td class='eq-no'>(7.8)</td></tr></table>
<!-- l. 117 --><p class='indent'>   This circuit has 4 unknown, possibly non-Clifford phases in it, so none of the
strategies we’ve studied so far let us reduce the whole circuit to any
kind of normal form. However, what we can do is unfuse the unknown
phases:
</p>
<div class='center'>
<!-- l. 119 --><p class='noindent'>
</p><!-- l. 120 --><p class='noindent'><object data="svgs/phase-gadget-ex.svg" alt="diagram of phase-gadget-ex" class="svg-diagram"></object> </p></div>
<!-- l. 123 --><p class='indent'>   Now, we can treat the 4 wires connecting to unknown phases as outputs of
the diagram and apply the simplification strategy we used back in Chapter <a href='main_htmlch4.html#cnot-circuits-and-phasefree-zxdiagrams'>4<!-- tex4ht:ref: ch:phasefree  --></a> for
CNOT circuits to the rest of the (phase-free) ZX-diagram. This diagram where
we treat the phases as additional outputs is an isometry, and so after simplifying,
we’ll get a parity normal form which only has Z spiders adjacent to inputs and
only has X spiders adjacent to outputs and our 4 phases. Here’s what this gives:
</p><table class='equation'><tr><td>
<!-- l. 124 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 124 --><object id='x9-158003r9' data="svgs/eq-phase-gadget-ex1.svg" alt="diagram of eq:phase-gadget-ex1" class="svg-diagram"></object></td><td class='eq-no'>(7.9)</td></tr></table>
<!-- l. 127 --><p class='indent'>   Here, the actual output wires have all ended up with a 2-legged X spider,
i.e. an identity map. This corresponds to the fact that the parity map
<!-- l. 127 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>L</mi></math> is
trivial. We will refer to this reduced form as the <span class='cmbx-10x-x-109'>phase gadget form </span>of a ZX
diagram. These are so named after <span class='cmbx-10x-x-109'>phase gadgets</span>, which are little compound
creatures consisting of a Z phase spider connected to a phase-free X spider with
<!-- l. 127 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
additional legs: </p><table class='equation'><tr><td>
<!-- l. 128 --><p class='indent'>
</p><!-- l. 128 --><object id='x9-158004r10' data="svgs/eq-phase-gadget.svg" alt="diagram of eq:phase-gadget" class="svg-diagram"></object></td><td class='eq-no'>(7.10)</td></tr></table>
<!-- l. 131 --><p class='indent'>   We will often treat these two spiders together as a single node in our diagram. Seen as
a map with <!-- l. 131 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
inputs and 0 outputs, a phase gadget takes a computational basis state to its
XOR, then depending on whether the XOR is 0 or 1, this produces a scalar of
either <!-- l. 131 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>
or <!-- l. 131 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iα</mi></mrow></msup></math>.
To see this, lets first think about a 1-legged Z spider as a map from 1 qubit to 0
qubits, i.e. it sends a single-qubit state to a number. On the computational basis,
it acts as follows: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 132 --><object data="svgs/Za-effect.svg" alt="diagram of Za-effect" class="svg-diagram"></object></td></tr></table>
<!-- l. 135 --><p class='indent'>   We can summarise this using a very simple phase polynomial: </p><table class='equation-star'><tr><td>
<!-- l. 136 --><object data="svgs/Za-effect-1.svg" alt="diagram of Za-effect-1" class="svg-diagram"></object></td></tr></table>
<!-- l. 139 --><p class='indent'>   Recall from Section <a href='main_htmlch3.html#spiders'>3.1.1<!-- tex4ht:ref: sec:spiders  --></a> that X spiders act like XORs on computational
basis states, up to a scalar factor: </p><table class='equation-star'><tr><td>
<!-- l. 140 --><object data="svgs/X-xor.svg" alt="diagram of X-xor" class="svg-diagram"></object></td></tr></table>
<!-- l. 143 --><p class='indent'>   Putting these two together, we see that the phase gadget itself does this:
</p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 144 --><object data="svgs/phase-gadget-1.svg" alt="diagram of phase-gadget-1" class="svg-diagram"></object></td></tr></table>
<!-- l. 147 --><p class='indent'>   In order to get a unitary map from a phase gadget, we can use a bunch of Z
spiders to make a copy of the basis state. One copy is sent to the phase gadget
and one copy is output. This results in the following diagonal unitary:
</p><table class='equation'><tr><td>
<!-- l. 148 --><p class='indent'>
</p><!-- l. 148 --><object id='x9-158005r11' data="svgs/eq-phase-gadget-unitary.svg" alt="diagram of eq:phase-gadget-unitary" class="svg-diagram"></object></td><td class='eq-no'>(7.11)</td></tr></table>
<!-- l. 151 --><p class='indent'>   Note that we have suppressed a <!-- l. 151 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi>k</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup></math>
scalar factor. Since we’ll be working with unitaries in the rest of this section, we’ll
just assume the overall scalar is chosen to make everything unitary. Returning to
(<a href='#x9-158003r9'>7.9<!-- tex4ht:ref: eq:phase-gadget-ex1  --></a>), we can see that this diagram can be seen as a composition of unitaries of
the form of (<a href='#x9-158005r11'>7.11<!-- tex4ht:ref: eq:phase-gadget-unitary  --></a>):
</p>
<div class='center'>
<!-- l. 154 --><p class='noindent'>
</p><!-- l. 155 --><p class='noindent'><object data="svgs/phase-gadget-unitary-decomp.svg" alt="diagram of phase-gadget-unitary-decomp" class="svg-diagram"></object> </p></div>
<!-- l. 158 --><p class='indent'>   Each of these phase gadget unitaries contributes one term to the phase
polynomial:
                                                                     

                                                                     
</p><!-- tex4ht:inline --><!-- l. 169 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mtable class='align-star' columnalign='left' displaystyle='true'>
      <mtr><mtd class='align-odd' columnalign='right'><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo></mtd>      <mtd class='align-even'><mover class='overset'><mrow><mo class='MathClass-rel' stretchy='false'>⟼</mo></mrow><mrow><msub><mrow><mi>U</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></mover><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>α</mi><mo class='MathClass-bin' stretchy='false'>⋅</mo><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>⊕</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>]</mo></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow>
<mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace width='2em'></mspace></mtd>                           <mtd class='align-label' columnalign='right'></mtd>      <mtd class='align-label'>
      <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>               <mtd class='align-even'><mover class='overset'><mrow><mo class='MathClass-rel' stretchy='false'>⟼</mo></mrow><mrow><msub><mrow><mi>U</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></mover><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>α</mi><mo class='MathClass-bin' stretchy='false'>⋅</mo><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>⊕</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>+</mo><mi>β</mi><mo class='MathClass-bin' stretchy='false'>⋅</mo><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>⊕</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>]</mo></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow>
<mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace width='2em'></mspace></mtd>                  <mtd class='align-label' columnalign='right'></mtd>      <mtd class='align-label'>
      <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>               <mtd class='align-even'><mover class='overset'><mrow><mo class='MathClass-rel' stretchy='false'>⟼</mo></mrow><mrow><msub><mrow><mi>U</mi></mrow><mrow><mn>3</mn></mrow></msub></mrow></mover><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>α</mi><mo class='MathClass-bin' stretchy='false'>⋅</mo><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>⊕</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>+</mo><mi>β</mi><mo class='MathClass-bin' stretchy='false'>⋅</mo><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>⊕</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>+</mo><mi>γ</mi><mo class='MathClass-bin' stretchy='false'>⋅</mo><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>⊕</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>]</mo></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow>
<mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace width='2em'></mspace></mtd>          <mtd class='align-label' columnalign='right'></mtd>      <mtd class='align-label'>
      <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>               <mtd class='align-even'><mover class='overset'><mrow><mo class='MathClass-rel' stretchy='false'>⟼</mo></mrow><mrow><msub><mrow><mi>U</mi></mrow><mrow><mn>4</mn></mrow></msub></mrow></mover><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mo class='MathClass-open' stretchy='false'>[</mo><mi>α</mi><mo class='MathClass-bin' stretchy='false'>⋅</mo><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>⊕</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>+</mo><mi>β</mi><mo class='MathClass-bin' stretchy='false'>⋅</mo><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>⊕</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>+</mo><mi>γ</mi><mo class='MathClass-bin' stretchy='false'>⋅</mo><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>⊕</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>+</mo><mi>𝜃</mi><mo class='MathClass-bin' stretchy='false'>⋅</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>]</mo></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow>
<mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace width='2em'></mspace></mtd>      <mtd class='align-label' columnalign='right'></mtd>      <mtd class='align-label'>
      <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>               <mtd class='align-even'><mspace width='2em'></mspace></mtd>                                                  <mtd class='align-label' columnalign='right'>
   </mtd></mtr></mtable></math>
<!-- l. 170 --><p class='noindent'>But there’s some redundancy here. As we noted in the previous section,
<!-- l. 170 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>α</mi></math> and
<!-- l. 170 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>γ</mi></math>
are applied to the same parity of input variables
<!-- l. 170 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub></mrow></math>. By
inspecting the phase polynomial, we can see that the unitary can be more
compactly represented by just 3 phase gadgets: </p><table class='equation'><tr><td>
<!-- l. 171 --><p class='indent'>
</p><!-- l. 171 --><object id='x9-158006r12' data="svgs/eq-phase-gadget-unitary-reduced.svg" alt="diagram of eq:phase-gadget-unitary-reduced" class="svg-diagram"></object></td><td class='eq-no'>(7.12)</td></tr></table>
<!-- l. 174 --><p class='indent'>   To see this graphically, we would need a ZX rule that lets us “fuse” the
phases on phase gadgets connected to an indentical set of wires. We indeed have
such a rule, which we call the <span class='cmbx-10x-x-109'>gadget fusion </span>rule: </p><table class='equation'><tr><td>
<!-- l. 175 --><p class='indent'>
</p><!-- l. 175 --><object id='x9-158007r13' data="svgs/eq-zx-gadget-fusion.svg" alt="diagram of eq:zx-gadget-fusion" class="svg-diagram"></object></td><td class='eq-no'>(7.13)</td></tr></table>
                                                                     

                                                                     
<!-- l. 178 --><p class='indent'>   It is in fact a derived rule, which follows from the usual spider fusion rule and
strong complementarity:
</p>
<div class='center'>
<!-- l. 180 --><p class='noindent'>
</p><!-- l. 181 --><p class='noindent'><object data="svgs/gadget-fusion-pf2.svg" alt="diagram of gadget-fusion-pf2" class="svg-diagram"></object> </p></div>
<!-- l. 184 --><p class='indent'>   Since the <!-- l. 184 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>α</mi></math>
and <!-- l. 184 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>γ</mi></math>
phase gadgets connect to the exact same spiders in (<a href='#x9-158003r9'>7.9<!-- tex4ht:ref: eq:phase-gadget-ex1  --></a>), we can apply
<!-- l. 184 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='label' xlink:href='#x9-158007r13' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'><mstyle class='text'><mtext class='textbf' mathvariant='bold'>gf </mtext></mstyle></mstyle><!-- endlabel --><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
directly to this diagram to simplify it:
</p>
<div class='center'>
<!-- l. 186 --><p class='noindent'>
</p><!-- l. 187 --><p class='noindent'><object data="svgs/phase-gadget-ex1-simp.svg" alt="diagram of phase-gadget-ex1-simp" class="svg-diagram"></object> </p></div>
<!-- l. 190 --><p class='indent'>   Now, by unfusing spiders, we can see exactly the decomposition into phase
gadget unitaries from (<a href='#x9-158006r12'>7.12<!-- tex4ht:ref: eq:phase-gadget-unitary-reduced  --></a>). We can also directly read the phase polynomial
from the diagram: </p><table class='equation-star'><tr><td>
<!-- l. 191 --><object data="svgs/phase-gadget-ex2-simp.svg" alt="diagram of phase-gadget-ex2-simp" class="svg-diagram"></object></td></tr></table>
<!-- l. 194 --><p class='indent'>   We computed the phase gadget form (<a href='#x9-158003r9'>7.9<!-- tex4ht:ref: eq:phase-gadget-ex1  --></a>) by appealing to the simplification
strategy for CNOT circuits from Chapter <a href='main_htmlch4.html#cnot-circuits-and-phasefree-zxdiagrams'>4<!-- tex4ht:ref: ch:phasefree  --></a>. However, there is a more direct way
we can translate CNOT+phase circuits into circuits of phase gadgets, by
studying the way that phase gadgets commute with CNOT gates. There are a
few cases to think about here. First, is the trivial case where a phase gadget and
CNOT gate share no qubits. Obviously these commute. Only slightly
harder to see is if a phase gadget appears on the control qubit (i.e. the Z
                                                                     

                                                                     
spider) of a CNOT gate. Then, commutation follows from spider fusion:
</p><table class='equation'><tr><td>
<!-- l. 195 --><p class='indent'>
</p><!-- l. 195 --><object id='x9-158008r14' data="svgs/eq-pg-cnot-commute1.svg" alt="diagram of eq:pg-cnot-commute1" class="svg-diagram"></object></td><td class='eq-no'>(7.14)</td></tr></table>
<!-- l. 198 --><p class='indent'>   If the phase gadget overlaps with the target qubit (i.e. the X spider) of a
CNOT gate, we can still push a phase gadget through, but it picks up an extra
leg: </p><table class='equation'><tr><td>
<!-- l. 199 --><p class='indent'>
</p><!-- l. 199 --><object id='x9-158009r15' data="svgs/eq-pg-cnot-commute2.svg" alt="diagram of eq:pg-cnot-commute2" class="svg-diagram"></object></td><td class='eq-no'>(7.15)</td></tr></table>
<!-- l. 202 --><p class='indent'>   Just by reading the equation above in reverse, we can also see what happens
when a phase gadget overlaps with both qubits of the CNOT gate. It loses a leg:
</p><table class='equation'><tr><td>
<!-- l. 203 --><p class='indent'>
</p><!-- l. 203 --><object id='x9-158010r16' data="svgs/eq-pg-cnot-commute3.svg" alt="diagram of eq:pg-cnot-commute3" class="svg-diagram"></object></td><td class='eq-no'>(7.16)</td></tr></table>
                                                                     

                                                                     
   <div class='newtheorem'>
<!-- l. 206 --><p class='noindent'><span class='head'>
<a id='x9-158011r2'></a>
<span class='cmbx-10x-x-109'>Exercise 7.2.</span>  </span> Prove equations (<a href='#x9-158009r15'>7.15<!-- tex4ht:ref: eq:pg-cnot-commute2  --></a>) and (<a href='#x9-158010r16'>7.16<!-- tex4ht:ref: eq:pg-cnot-commute3  --></a>). Use the three “phase-gadget
walking” equations (<a href='#x9-158008r14'>7.14<!-- tex4ht:ref: eq:pg-cnot-commute1  --></a>), (<a href='#x9-158009r15'>7.15<!-- tex4ht:ref: eq:pg-cnot-commute2  --></a>), and (<a href='#x9-158010r16'>7.16<!-- tex4ht:ref: eq:pg-cnot-commute3  --></a>), as well as the fact that
Z-phase gates are equivalent to 1-legged phase gadgets, to show that an
<!-- l. 207 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-legged
phase gadget has the following decomposition: </p><table class='equation'><tr><td>
<!-- l. 208 --><p class='indent'>
</p><!-- l. 208 --><object id='x9-158012r17' data="svgs/eq-phase-gadget-circ.svg" alt="diagram of eq:phase-gadget-circ" class="svg-diagram"></object></td><td class='eq-no'>(7.17)</td></tr></table>
   </div>
<!-- l. 211 --><p class='indent'>
</p>
   <h4 class='subsectionHead' id='universal-circuits-with-path-sums'><span class='titlemark'>7.1.3   </span> <a id='x9-1590007.1.3'></a>Universal circuits with path sums</h4>
<!-- l. 213 --><p class='noindent'>In the previous section, we saw that CNOT+phase circuits can be expressed
compactly as phase polynomials, or equivalently using ZX diagrams with phase
gadgets. Both of these gates send Z basis states to Z basis states (up to a phase),
so they can’t possibly be universal. In order to get a universal family of circuits,
we need to include a gate which can produce superpositions of Z basis states, like
the Hadamard gate. Unfortunately, Hadamard gates break our nice phase
polynomial representation. However, we can salvage things somewhat if we are
willing to introduce some extra variables that don’t appear in the input state.
Let’s start by re-visiting the Euler decomposition of a Hadamard gate.
</p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 216 --><object data="svgs/had-euler1.svg" alt="diagram of had-euler1" class="svg-diagram"></object></td></tr></table>
<!-- l. 219 --><p class='indent'>   Back in Section <a href='main_htmlch3.html#euler-decomposition'>3.2.5<!-- tex4ht:ref: sec:rule-euler  --></a>, we saw that there are in fact equivalent
ways to write the Hadamard. One way is to unfuse the middle
<!-- l. 219 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>π</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn></mrow></math> from
the X spider and change its colour: </p><table class='equation-star'><tr><td>
<!-- l. 220 --><object data="svgs/had-euler-gadget.svg" alt="diagram of had-euler-gadget" class="svg-diagram"></object></td></tr></table>
<!-- l. 223 --><p class='indent'>   This gives us a phase gadget connecting the input and the output spiders.
However, unlike the phase gadgets we’ve met so far, this one is not appearing as
part of a diagonal unitary gate like the one depicted in (<a href='#x9-158005r11'>7.11<!-- tex4ht:ref: eq:phase-gadget-unitary  --></a>). That is, it doesn’t
seem to be connected to different qubit wires, which can then be labelled by the
variables in our phase polynomials. We can fix this by unfusing some
spiders:
</p>
<div class='center'>
<!-- l. 225 --><p class='noindent'>
</p><!-- l. 226 --><p class='noindent'><object data="svgs/had-euler-gadget2.svg" alt="diagram of had-euler-gadget2" class="svg-diagram"></object> </p></div>
<!-- l. 229 --><p class='indent'>   The result is a representation of the Hadamard gate where we first prepare an ancilla
in the <!-- l. 229 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext class='MathClass-rel' stretchy='false'>|+⟩</mtext></mrow></math>
state, then do a diagonal 2-qubit unitary, and then post-select the input qubit
onto <!-- l. 229 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mtext class='MathClass-open' stretchy='false'>⟨+|</mtext></mrow></math>.
We already know how to write the middle part in terms of a phase polynomial:
                                                                     

                                                                     
</p><table class='equation-star'><tr><td>
<!-- l. 231 --><object data="svgs/phase-gadget-cz.svg" alt="diagram of phase-gadget-cz" class="svg-diagram"></object></td></tr></table>
<!-- l. 234 --><p class='indent'>   Note that we didn’t supress the <!-- l. 234 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mfrac><mrow><mn>1</mn></mrow>
<mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac></mrow></math>
factor coming from the phase gadget (as we did before), so technically this is
only unitary up to a scalar. This will help us get the Hadamard gate
on-the-nose. The Z-spider plugged into the input means we should sum over
<!-- l. 235 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>y</mi></math>:
</p><table class='equation-star'><tr><td>
<!-- l. 236 --><object data="svgs/Z-state.svg" alt="diagram of Z-state" class="svg-diagram"></object></td></tr></table>
<!-- l. 239 --><p class='indent'>   whereas the Z-spider plugging into the output means that we should send the computational
basis state <!-- l. 239 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> to
<!-- l. 239 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math> (i.e. delete it),
regardless of whether <!-- l. 239 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>
or <!-- l. 239 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>:
</p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 240 --><object data="svgs/Z-effect.svg" alt="diagram of Z-effect" class="svg-diagram"></object></td></tr></table>
<!-- l. 243 --><p class='indent'>   Putting these pieces together, we see that we can write the action of a Hadamard gate
as something much like the phase polynomial form from before, but now with an extra
variable <!-- l. 243 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>y</mi></math>
getting summed over: </p><table class='equation'><tr><td>
<!-- l. 244 --><p class='indent'>
</p><!-- l. 244 --><object id='x9-159001r18' data="svgs/eq-had-path-sum.svg" alt="diagram of eq:had-path-sum" class="svg-diagram"></object></td><td class='eq-no'>(7.18)</td></tr></table>
<!-- l. 247 --><p class='indent'>   The extra variable <!-- l. 247 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>y</mi></math>
is called a <span class='cmbx-10x-x-109'>path variable </span>and the overall expression is called a <span class='cmti-10x-x-109'>sum-over-paths </span>or
<span class='cmbx-10x-x-109'>path sum </span>representation of the unitary. The expression we got in (<a href='#x9-159001r18'>7.18<!-- tex4ht:ref: eq:had-path-sum  --></a>) may not
look much like the definition of a Hadamard gate as we know it, so let’s check
that this indeed gives us the right thing. First, recall that a Hadamard acts like
this on computational basis states: </p><table class='equation-star'><tr><td>
<!-- l. 249 --><object data="svgs/had-1.svg" alt="diagram of had-1" class="svg-diagram"></object></td></tr></table>
<!-- l. 252 --><p class='indent'>   We can summarise this as something that looks like a path sum as follows:
</p><table class='equation'><tr><td>
<!-- l. 253 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 253 --><object id='x9-159002r19' data="svgs/eq-had-multilinear.svg" alt="diagram of eq:had-multilinear" class="svg-diagram"></object></td><td class='eq-no'>(7.19)</td></tr></table>
<!-- l. 256 --><p class='indent'>   That is, we pick up a <!-- l. 256 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iπ</mi></mrow></msup></mrow></math>
coefficient when the input variable <!-- l. 256 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>
AND the summed variable <!-- l. 256 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>y</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>.
However, we don’t (yet) know how to introduce the AND of two variables into a
phase polynomial. We only know how to introduce XORs using phase gadgets.
Thankfully, for <span class='cmbx-10x-x-109'>pseudo-boolean functions</span>, i.e. functions from bitstrings to the
real numbers, these two logical operations are related by the following equation:
</p><table class='equation'><tr><td>
<!-- l. 258 --><p class='indent'>
</p><!-- l. 258 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                     <mstyle class='label' id='x9-159003r20'></mstyle><!-- endlabel --><mi mathvariant='italic'>xy</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⋅</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⋅</mo><mspace class='negthinspace' width='-0.17em'></mspace><mi>y</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><mspace class='negthinspace' width='-0.17em'></mspace> <mo class='MathClass-bin' stretchy='false'>⋅</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>y</mi><mo class='MathClass-close' stretchy='false'>)</mo>
</mrow></math></td><td class='eq-no'>(7.20)</td></tr></table>
<!-- l. 261 --><p class='indent'>   This equation is easy to check just by trying all of values of
<!-- l. 261 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo><mo class='MathClass-open' stretchy='false'>{</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>.
There is a deeper reason why this (and many related) equations hold, related to
the <span class='cmbx-10x-x-109'>Fourier transform </span>of a pseudo-boolean function. We’ll see more about that
in Chapter <a href='main_htmlch9.html#controlled-gates-and-classical-oracles'>9<!-- tex4ht:ref: ch:midlevel  --></a>. For now, we can see that this is exactly what we need to show that
the two expressions for the Hadamard gate, equations (<a href='#x9-159001r18'>7.18<!-- tex4ht:ref: eq:had-path-sum  --></a>) and (<a href='#x9-159002r19'>7.19<!-- tex4ht:ref: eq:had-multilinear  --></a>), agree.
This trick of replacing a Hadamard gate with phase gadgets will work
for any number of Hadamard gates in a circuit. Hence, for any circuit
written in the Clifford+phase gate set, we can transform it into a phase
polynomial circuit, at the cost of introducing some ancillae and post-selections:
</p><table class='equation'><tr><td>
<!-- l. 263 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 263 --><object id='x9-159004r21' data="svgs/eq-circuit-Hadamard-gadgetise.svg" alt="diagram of eq:circuit-Hadamard-gadgetise" class="svg-diagram"></object></td><td class='eq-no'>(7.21)</td></tr></table>
<!-- l. 266 --><p class='indent'>   The procedure for computing the path sum expression off of a circuit with
CNOT, phase, and Hadamard gates can therefore be derived from the simpler
one used for CNOT+phase circuits. We start labelling wires with parities as
before, but as soon as a Hadamard gate is encountered, we replace the label with
a new, fresh path variable. We then add 3 new terms to the phase polynomial
and sum over the path variable.
</p>
   <div class='newtheorem'>
<!-- l. 267 --><p class='noindent'><span class='head'>
<a id='x9-159005r1'></a>
<span class='cmbx-10x-x-109'>Example 7.1.1.</span>  </span>Doing this procedure with the circuit of Eq. (<a href='#x9-159004r21'>7.21<!-- tex4ht:ref: eq:circuit-Hadamard-gadgetise  --></a>) we see that
we get the path sum </p><table class='equation-star'><tr><td>
<!-- l. 269 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
    <mo class='MathClass-rel' stretchy='false'>|</mo><mi>x</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>z</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>↦</mo><munder class='msub'><mrow><mo>∑</mo>
   </mrow><mrow><msub><mrow><mi>h</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>h</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></munder><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi mathvariant='italic'>αx</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mi>β</mi><msub><mrow><mi>h</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>+</mo><mi>γ</mi><msub><mrow><mi>h</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>⊕</mo><mi>z</mi><mo class='MathClass-bin' stretchy='false'>+</mo><msub><mrow><mi>ϕ</mi></mrow><mrow><mi>H</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-bin' stretchy='false'>⊕</mo><mi>y</mi><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>h</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>+</mo><msub><mrow><mi>ϕ</mi></mrow><mrow><mi>H</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>h</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>h</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>x</mi><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>h</mi></mrow><mrow>
<mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>h</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>z</mi><mo class='MathClass-close' stretchy='false'>⟩</mo>
</mrow></math></td></tr></table>
<!-- l. 272 --><p class='indent'>   where
<!-- l. 272 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>ϕ</mi></mrow><mrow><mi>H</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mi>a</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>b</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>2</mn></mrow></mfrac> <mo class='MathClass-open' stretchy='false'>(</mo><mi>a</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>b</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>a</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>b</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
is the phase polynomial that is added by a Hadamard.
</p>
   </div>
<!-- l. 273 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 274 --><p class='noindent'><span class='head'>
                                                                     

                                                                     
<a id='x9-159006r2'></a>
<span class='cmbx-10x-x-109'>Remark 7.1.2.</span>  </span>The  physicists  among  you  might  be  thinking:  “hmm,  a
sum  over  paths  you  say,  that  sounds  familiar.”  And  indeed  they  would
be  right.  The  path  sums  we  are  using  here  are  exactly  a  discretised
version  of  the  Feynman  path  integrals  that  feature  so  prominently  in
quantum  mechanics.  Just  like  how  we  can  view  a  quantum  particle  as
evolving over a superposition of paths that interfere together, so we can
view  a  quantum  computation  as  evolving  a  computational  basis  state
<!-- l. 275 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
through a superposition of paths towards the final outcome.
</p>
   </div>
<!-- l. 276 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 277 --><p class='noindent'><span class='head'>
<a id='x9-159007r3'></a>
<span class='cmbx-10x-x-109'>Exercise 7.3.</span>  </span>We know of course that two Hadamards in a row form the
identity.
   </p><dl class='enumerate'><dt class='enumerate'>
a) </dt><dd class='enumerate'>
   <!-- l. 280 --><p class='noindent'>Write  down  the  path  sum  of  a  single-qubit  circuit  containing  two
   Hadamards.
   </p></dd><dt class='enumerate'>
b) </dt><dd class='enumerate'>
   <!-- l. 281 --><p class='noindent'>Figure out how you could prove from this expression that this is equal
   to the identity. </p></dd></dl>
   </div>
<!-- l. 283 --><p class='indent'>
</p>
   <h3 class='sectionHead' id='circuit-synthesis-and-path-sums'><span class='titlemark'>7.2   </span> <a id='x9-1600007.2'></a>Circuit synthesis and path sums</h3>
<!-- l. 292 --><p class='noindent'>In the previous section we’ve seen how to convert a circuit into a phase
polynomial or path sum expression. Now we will see how we can go back and get
                                                                     

                                                                     
a circuit back out again. First of all, why would we want to do this? The obvious
first application for this is circuit optimisation. Namely, we can start
with a circuit, compute its path sum expression, then re-synthesise a
(hopefully smaller!) circuit that implements the same unitary. We have
already met this simplify-and-extract methodology with CNOT circuits in
Section <a href='main_htmlch4.html#the-phasefree-zx-calculus'>4.2<!-- tex4ht:ref: sec:phase-free-zx  --></a>, and we’ll meet it again a couple more times in this book.
We saw an instance of this already in passing from circuit (<a href='#x9-157004r4'>7.4<!-- tex4ht:ref: eq:cnot-phase-parities  --></a>) to the
smaller circuit (<a href='#x9-157006r6'>7.6<!-- tex4ht:ref: eq:cnot-phase-parities-simp  --></a>). This was a simple example, so we were able to
find a smaller circuit implementing the same phase polynomial in an
<span class='cmti-10x-x-109'>ad hoc </span>way before. In Section <a href='#synthesis-from-phase-polynomials'>7.2.1<!-- tex4ht:ref: sec:synth-gauss  --></a> we will explore some algorithms
for this which work for any phase polynomial. For general path sum
expressions there is no known efficient algorithm for turning it back in a
circuit. We will however in Section <a href='#quantum-fourier-transform'>7.2.2<!-- tex4ht:ref: sec:QFT  --></a> consider a specific example where
we can make it work. This actually brings us to the second application
for constructing circuits from these expressions: it allows you to build
<span class='cmti-10x-x-109'>new </span>circuits from a higher-level description of the circuit behaviour. In
Chapter <a href='main_htmlch9.html#controlled-gates-and-classical-oracles'>9<!-- tex4ht:ref: ch:midlevel  --></a>, we’ll look at this in more detail and see how, thanks to a bit
of boolean Fourier theory, we can build circuits in the Clifford+phase
gate set implementing arbitrary classical functions on quantum data
using phase polynomials and the circuit synthesis techniques from this
section.
</p>
   <h4 class='subsectionHead' id='synthesis-from-phase-polynomials'><span class='titlemark'>7.2.1   </span> <a id='x9-1610007.2.1'></a>Synthesis from phase polynomials</h4>
<!-- l. 296 --><p class='noindent'>Just like how we were able to commandeer the phase-free simplification algorithm
from Chapter <a href='main_htmlch4.html#cnot-circuits-and-phasefree-zxdiagrams'>4<!-- tex4ht:ref: ch:phasefree  --></a> to simplify CNOT+phase circuits, we can (essentially) repurpose
the phase-free extraction algorithm for the parity form of a ZX-diagram to
extract CNOT+phase circuits from the phase gadget form. Recall that a
ZX-diagram in parity form looks like a row of Z-spiders connected to a row of
X-spiders, e.g.
</p>
<div class='center'>
<!-- l. 299 --><p class='noindent'>
</p><!-- l. 300 --><p class='noindent'><object data="svgs/parity-form-unitary-3.svg" alt="diagram of parity-form-unitary-3" class="svg-diagram"></object> </p></div>
<!-- l. 303 --><p class='indent'>   From this form, we can associate a biadjacency matrix: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 304 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'>
 <mrow><mo fence='true' form='prefix'>(</mo><mrow><mtable align='axis' class='array' columnlines='none none none none none none none none none none none none none none none none none none none' displaystyle='true' equalcolumns='false' equalrows='false' style=''> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd></mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd> <mtd class='array-td' columnalign='center'> <mn>1</mn></mtd>
</mtr> <mtr class='array-row'><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>0</mn> </mtd><mtd class='array-td' columnalign='center'> <mn>1</mn> </mtd></mtr> <!-- *\c@MaxMatrixCols c --></mtable>                                                          </mrow><mo fence='true' form='postfix'>)</mo></mrow>
</math></td></tr></table>
<!-- l. 311 --><p class='indent'>   and performing Gauss-Jordan reduction of this matrix gives us a CNOT
decomposition, where each CNOT operations corresponds to a primitive column
operation: </p><table class='equation-star'><tr><td>
<!-- l. 314 --><object data="svgs/parity-form-unitary-2.svg" alt="diagram of parity-form-unitary-2" class="svg-diagram"></object></td></tr></table>
<!-- l. 318 --><p class='indent'>   Now, suppose we generalise from the parity form to the phase gadget
form, i.e. we add some phase gadgets connected to the input Z-spiders:
</p><table class='equation'><tr><td>
<!-- l. 319 --><p class='indent'>
</p><!-- l. 319 --><object id='x9-161001r22' data="svgs/eq-phase-gadget-form.svg" alt="diagram of eq:phase-gadget-form" class="svg-diagram"></object></td><td class='eq-no'>(7.22)</td></tr></table>
<!-- l. 322 --><p class='indent'>   This describes a unitary with phase polynomial expression: </p><table class='equation'><tr><td>
<!-- l. 323 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 323 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
          <mstyle class='label' id='x9-161002r23'></mstyle><!-- endlabel --><mi>U</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-punc' stretchy='false'>:</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>↦</mo><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iα</mi><mo class='MathClass-bin' stretchy='false'>⋅</mo><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>⊕</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-bin' stretchy='false'>+</mo><mi>β</mi><mo class='MathClass-bin' stretchy='false'>⋅</mo><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>⊕</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow>
<mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>3</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo>
</mrow></math></td><td class='eq-no'>(7.23)</td></tr></table>
<!-- l. 328 --><p class='indent'>   The first thing we realise from inspecting (<a href='#x9-161001r22'>7.22<!-- tex4ht:ref: eq:phase-gadget-form  --></a>) is that most of the
diagram is already in parity form, except for the two phases themselves:
</p><table class='equation-star'><tr><td>
<!-- l. 329 --><object data="svgs/phase-gadget-form.svg" alt="diagram of phase-gadget-form" class="svg-diagram"></object></td></tr></table>
<!-- l. 332 --><p class='indent'>   Writing down the biadjacency matrix, we see that we now get a tall, skinny
matrix, with some extra rows at the beginning corresponding to phase gadgets:
</p><table class='equation'><tr><td>
<!-- l. 333 --><p class='indent'>
</p><!-- l. 333 --><object id='x9-161003r24' data="svgs/eq-phase-gadget-matrix.svg" alt="diagram of eq:phase-gadget-matrix" class="svg-diagram"></object></td><td class='eq-no'>(7.24)</td></tr></table>
<!-- l. 336 --><p class='indent'>   Just like before, precomposing with CNOTs performs primitive column
operations. For example, this: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 337 --><object data="svgs/begintabu.svg" alt="diagram of begintabu" class="svg-diagram"></object></td></tr></table>
<!-- l. 340 --><p class='indent'>   corresponds to this equation of ZX-diagrams: </p><table class='equation-star'><tr><td>
<!-- l. 341 --><object data="svgs/phase-gadget-form1.svg" alt="diagram of phase-gadget-form1" class="svg-diagram"></object></td></tr></table>
<!-- l. 344 --><p class='indent'>   But note that the <!-- l. 344 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>α</mi></math>
phase is now attached to a 1-legged phase gadget, i.e. an identity X-spider. So,
we can use spider fusion to pull it out: </p><table class='equation-star'><tr><td>
<!-- l. 345 --><object data="svgs/phase-gadget-form2.svg" alt="diagram of phase-gadget-form2" class="svg-diagram"></object></td></tr></table>
<!-- l. 348 --><p class='indent'>   The reason we could do that, is because our primitive column operation
turned one of the rows above the line in matrix (<a href='#x9-161003r24'>7.24<!-- tex4ht:ref: eq:phase-gadget-matrix  --></a>) into a unit vector. Since
this means that phase gadget is now 1-legged, we can always pull it out to
become a Z phase gate. The remaining bit of the diagram in phase gadget
form then has a biadjancency matrix obtained by deleting the first row:
</p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 349 --><object data="svgs/begintabu-1.svg" alt="diagram of begintabu-1" class="svg-diagram"></object></td></tr></table>
<!-- l. 352 --><p class='indent'>   We can now create a unit vector in the first row by adding the second column
to the third column: </p><table class='equation-star'><tr><td>
<!-- l. 353 --><object data="svgs/begintabu-2.svg" alt="diagram of begintabu-2" class="svg-diagram"></object></td></tr></table>
<!-- l. 356 --><p class='indent'>   Again, the phase gadget turns into a simple Z phase gate, which we can pull
out to the left: </p><table class='equation-star'><tr><td>
<!-- l. 357 --><object data="svgs/phase-gadget-form4.svg" alt="diagram of phase-gadget-form4" class="svg-diagram"></object></td></tr></table>
<!-- l. 360 --><p class='indent'>   Now that we have no phase gadgets left, there is nothing above the line in our
biadjacency matrix, so we finish off by doing normal Gaussian elimination:
</p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 361 --><object data="svgs/begintabu-3.svg" alt="diagram of begintabu-3" class="svg-diagram"></object></td></tr></table>
<!-- l. 364 --><p class='indent'>   This then yields as a final circuit: </p><table class='equation-star'><tr><td>
<!-- l. 365 --><object data="svgs/phase-gadget-form-1.svg" alt="diagram of phase-gadget-form-1" class="svg-diagram"></object></td></tr></table>
<!-- l. 368 --><p class='indent'>   We can check our work by labelling wires with parities:
</p>
<div class='center'>
<!-- l. 370 --><p class='noindent'>
</p><!-- l. 371 --><p class='noindent'><object data="svgs/phase-gadget-form9.svg" alt="diagram of phase-gadget-form9" class="svg-diagram"></object> </p></div>
<!-- l. 374 --><p class='indent'>   Comparing this labelled circuit to the phase polynomial expression
in equation (<a href='#x9-161002r23'>7.23<!-- tex4ht:ref: eq:parity-form-poly  --></a>), we see that we have indeed synthesised a
correct circuit for this unitary. Hence, the general algorithm for
synthesising a circuit from a phase polynomial expression for a unitary
<!-- l. 375 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math> is the
following:
     </p><dl class='enumerate'><dt class='enumerate'>
  1.. </dt><dd class='enumerate'>
     <!-- l. 377 --><p class='noindent'>Form a block diagonal matrix over
     <!-- l. 377 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></math>
     whose columns are labelled by input variables
     <!-- l. 377 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub></mrow></math>,
     where: </p>
                                                                     

                                                                     
          <ul class='itemize1'>
          <li class='itemize'>the first <!-- l. 379 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
          rows correspond to the <!-- l. 379 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
          terms in the phase polynomial, with a <!-- l. 379 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>
          in column <!-- l. 379 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math>
          iff <!-- l. 379 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mi>i</mi></mrow></msub></math>
          appears in that term, and
          </li>
          <li class='itemize'>the last <!-- l. 380 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
          rows correspond to the parity map describing <!-- l. 380 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>’s
          action on basis states. </li></ul>
     </dd><dt class='enumerate'>
  2.. </dt><dd class='enumerate'>
     <!-- l. 382 --><p class='noindent'>Perform primitive column operations (i.e. CNOT gates) until one of the first
     <!-- l. 382 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> rows is reduced to a
     unit vector with a <!-- l. 382 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>1</mn></math>
     in column <!-- l. 382 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>j</mi></math>
     </p></dd><dt class='enumerate'>
  3.. </dt><dd class='enumerate'>
     <!-- l. 383 --><p class='noindent'>Apply a phase gate to the <!-- l. 383 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>j</mi></math>-th
     qubit and delete the unit vector.
     </p></dd><dt class='enumerate'>
  4.. </dt><dd class='enumerate'>
     <!-- l. 384 --><p class='noindent'>Repeat from step 2 until the top block of the parity matrix is empty.
     </p></dd><dt class='enumerate'>
  5.. </dt><dd class='enumerate'>
     <!-- l. 385 --><p class='noindent'>Synthesise a CNOT circuit corresponding to the remaining
     <!-- l. 385 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
     rows. </p></dd></dl>
<!-- l. 387 --><p class='noindent'>Note that step 2 will always succeed: we can reduce any non-zero row to a unit
vector using primitive column operations, and since steps 2-4 always remove a
row, the algorithm will terminate. However, just as we saw in the CNOT case,
the size of the resulting circuit is very sensitive to which column operations are
performed and in which order. In fact, here we have two kinds of decisions to
make: which rows to eliminate first, and which column operations should be used
to eliminate a given row? The answer to these questions will depend on what our
goals are. Namely, do we want to choose operations to minimise the depth of the
                                                                     

                                                                     
circuit or just the CNOT count? Or maybe it could be beneficial on our
architecture to do as many phase gates in parallel as possible. For the
remainder of this section, we will discuss some heuristics for achieving
these goals.  It may also be the case that we cannot apply CNOT gates
between arbitrary pairs of qubits, but only nearest neighbours in our
architecture. We discuss how to deal with this in the References of this
chapter.
</p>
   <h4 class='subsectionHead' id='quantum-fourier-transform'><span class='titlemark'>7.2.2   </span> <a id='x9-1620007.2.2'></a>Quantum Fourier transform</h4>
<!-- l. 395 --><p class='noindent'>While it is possible to efficiently extract a circuit from a phase polynomial
description, doing the same from a path-sum description is still an open problem.
For certain special cases we can try to make it work just by using raw
brainpower. In this section we will find a circuit for the <span class='cmbx-10x-x-109'>Quantum Fourier
transform </span>based on its description as a path sum. Recall that this unitary is for
instance the magic trick that makes Shor’s algorithm work. In general, for a
<!-- l. 398 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>d</mi></math>-dimensional space
<!-- l. 398 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>ℂ</mi></mrow><mrow><mi>d</mi></mrow></msup></math> we define its Fourier
transform as follows. Let <!-- l. 398 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mi>d</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
be the standard basis states. Then
<!-- tex4ht:inline --></p><!-- l. 399 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                  <mi mathvariant='italic'>QFT</mi><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-punc' stretchy='false'>:</mo> <mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-rel' stretchy='false'>|</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>↦</mo> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msqrt><mrow><mi>d</mi></mrow></msqrt></mrow></mfrac><munderover accent='false' accentunder='false'><mrow><mo>∑</mo>
  </mrow><mrow><mi>y</mi><mo class='MathClass-rel' stretchy='false'>=</mo><mn>0</mn></mrow><mrow><mi>d</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></munderover><msup><mrow><mi>e</mi></mrow><mrow><mfrac><mrow><mn>2</mn><mi mathvariant='italic'>πi</mi></mrow>
 <mrow><mi>d</mi></mrow></mfrac>  <mi mathvariant='italic'>xy</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>y</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math>
<!-- l. 399 --><p class='nopar'> For instance, when <!-- l. 400 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>d</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>2</mn></mrow></math>
we get <!-- l. 400 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>↦</mo> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msqrt><mrow><mn>2</mn></mrow></msqrt></mrow></mfrac><msub><mrow> <mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>y</mi></mrow></msub><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iπxy</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>y</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>,
which is exactly the Hadamard. We will be interested in the case where
<!-- l. 400 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>d</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></math>, so that the space corresponds
to <!-- l. 400 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math> qubits. We should read
the expression <!-- l. 400 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>xy</mi></mrow></math> then as
multiplying the numbers <!-- l. 400 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>y</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo><mo class='MathClass-open' stretchy='false'>{</mo><mn>0</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>,
<span class='cmti-10x-x-109'>not </span>as taking the inner product of two bit strings. But since we do like
thinking about bit strings, let’s define a translation. For a bit string
<!-- l. 400 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></math>, define
                                                                     

                                                                     
<!-- l. 400 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>b</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>2</mn></mrow></msup><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-rel' stretchy='false'>⋯</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mn>2</mn></mrow><mrow><mn>0</mn></mrow></msup><msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub></mrow></math>. Then we can
write the <!-- l. 400 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit
QFT as follows: </p><table class='equation'><tr><td>
<!-- l. 401 --><p class='indent'>
</p><!-- l. 401 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                 <mstyle class='label' id='x9-162001r25'></mstyle><!-- endlabel --><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>↦</mo>  <mfrac><mrow><mn>1</mn></mrow> 
<mrow><msqrt><mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></msqrt></mrow></mfrac><munder class='msub'><mrow><mo> ∑</mo>
   </mrow><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>∈</mo><mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></munder><msup><mrow><mi>e</mi></mrow><mrow><mfrac><mrow><mn>2</mn><mi mathvariant='italic'>πi</mi></mrow>
<mrow><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></mrow></mfrac> <mi>b</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo><mi>b</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td><td class='eq-no'>(7.25)</td></tr></table>
   <div class='newtheorem'>
<!-- l. 404 --><p class='noindent'><span class='head'>
<a id='x9-162002r4'></a>
<span class='cmbx-10x-x-109'>Exercise 7.4.</span>  </span>In this exercise we will use the path-sum formalism to find a circuit implementing
the <!-- l. 405 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit
QFT.
     </p><dl class='enumerate'><dt class='enumerate'>
  1.. </dt><dd class='enumerate'>
     <!-- l. 407 --><p class='noindent'>To compile the QFT unitary to a quantum circuit, we will need to know
     first how to compile <span class='cmti-10x-x-109'>controlled phase </span>gates. These are unitaries that act like
     <!-- l. 407 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-rel' stretchy='false'>↦</mo><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iα</mi><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>⋅</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
     Using phase polynomials and the identity
     <!-- l. 407 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <mi>y</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>y</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>x</mi> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <mi>y</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
     show that the following circuit implements a controlled phase gate:
     </p><table class='equation'><tr><td>
     <!-- l. 408 --><p class='noindent'>
     </p><!-- l. 408 --><object id='x9-162004r26' data="svgs/controlled-phase-cnots.svg" alt="diagram of controlled-phase-cnots" class="svg-diagram"></object></td><td class='eq-no'>(7.26)</td></tr></table>
                                                                     

                                                                     
     </dd><dt class='enumerate'>
  2.. </dt><dd class='enumerate'>
     <!-- l. 411 --><p class='noindent'>For <!-- l. 411 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>2</mn></mrow></math>, expand the
     definition of <!-- l. 411 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>b</mi></math>
     in Eq. (<a href='#x9-162001r25'>7.25<!-- tex4ht:ref: eq:QFT  --></a>) to write the phase polynomial as a product of
     <!-- l. 411 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iα</mi><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub><msub><mrow><mi>y</mi></mrow><mrow><mi>l</mi></mrow></msub></mrow></msup></math> terms. Argue
     that the <!-- l. 411 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mi>y</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></math>
     term can be removed without changing the resulting map.
     </p></dd><dt class='enumerate'>
  3.. </dt><dd class='enumerate'>
     <!-- l. 412 --><p class='noindent'>Using the path-sum approach, show that the following circuit implements
     the 2-qubit QFT, by verifying that it is equal to the expression you derived
     above: </p><table class='equation'><tr><td>
     <!-- l. 413 --><p class='noindent'>
     </p><!-- l. 413 --><object id='x9-162007r27' data="svgs/QFT-2-qubit.svg" alt="diagram of QFT-2-qubit" class="svg-diagram"></object></td><td class='eq-no'>(7.27)</td></tr></table>
     <!-- l. 416 --><p class='noindent'>Note that you might need to ‘rename’ the variables
     <!-- l. 416 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>y</mi></math>
     you are getting out of an application of a Hadamard gate to make sure it
     matches the expression you had above.
     </p></dd><dt class='enumerate'>
  4.. </dt><dd class='enumerate'>
     <!-- l. 417 --><p class='noindent'>Now for <!-- l. 417 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>3</mn></mrow></math>, again expand
     the definition of <!-- l. 417 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>b</mi></math>
     in Eq. (<a href='#x9-162001r25'>7.25<!-- tex4ht:ref: eq:QFT  --></a>) to write the phase polynomial as a product of
     <!-- l. 417 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iα</mi><msub><mrow><mi>x</mi></mrow><mrow><mi>k</mi></mrow></msub><msub><mrow><mi>y</mi></mrow><mrow><mi>l</mi></mrow></msub></mrow></msup></math>
     terms and remove the terms that you can remove. Construct a circuit to
     implement the 3-qubit QFT.
     </p></dd><dt class='enumerate'>
  5.. </dt><dd class='enumerate'>
                                                                     

                                                                     
     <!-- l. 418 --><p class='noindent'>Give a recipe for constructing the
     <!-- l. 418 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit QFT
     for any <!-- l. 418 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>.
     </p></dd></dl>
   </div>
<!-- l. 420 --><p class='indent'>
</p>
   <h3 class='sectionHead' id='pauli-exponentials'><span class='titlemark'>7.3   </span> <a id='x9-1630007.3'></a>Pauli exponentials</h3>
<!-- l. 431 --><p class='noindent'>Now we will switch to a very different way of looking at universal quantum
circuits. Not as a series of logic gates that create branches of computational basis
states and evolve these with phase polynomials, but as a series of applications of
rotations around Pauli gates.
</p>
   <h4 class='subsectionHead' id='unitaries-from-pauli-boxes'><span class='titlemark'>7.3.1   </span> <a id='x9-1640007.3.1'></a>Unitaries from Pauli boxes</h4>
<!-- l. 433 --><p class='noindent'>In Chapter <a href='main_htmlch6.html#stabiliser-theory'>6<!-- tex4ht:ref: ch:stabiliser  --></a>, we introduced <span class='cmbx-10x-x-109'>Pauli boxes</span>, which gave us a way to wrap up the
pair of projectors coming from a Pauli measurement into a single object. We also
saw in Exercise <a href='main_htmlch6.html#x8-136025r8'>6.8<!-- tex4ht:ref: exer:measure-box  --></a> that these are special case of <span class='cmbx-10x-x-109'>measure boxes</span>, which can
represent an arbitrary (2-outcome) measurement using a single map satisfying
the following properties:
</p>
<div class='center'>
<!-- l. 435 --><p class='noindent'>
</p><!-- l. 436 --><p class='noindent'><object data="svgs/coherent-measurement.svg" alt="diagram of coherent-measurement" class="svg-diagram"></object> </p></div>
<!-- l. 439 --><p class='indent'>   These three conditions are equivalent to the condition that the following
forms a measurement: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 440 --><object data="svgs/coherent-measurement-projection-1.svg" alt="diagram of coherent-measurement-projection-1" class="svg-diagram"></object></td></tr></table>
<!-- l. 443 --><p class='indent'>   So, we get a measurement when plugging in X spiders into the control wire.
Here’s a (seemingly) random question: what happens if we plug in Z
spiders? To find out, lets see what happens when we form a linear map
<!-- l. 443 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>L</mi></math> as
follows: </p><table class='equation-star'><tr><td>
<!-- l. 444 --><object data="svgs/coherent-measurement-unitary.svg" alt="diagram of coherent-measurement-unitary" class="svg-diagram"></object></td></tr></table>
<!-- l. 447 --><p class='indent'>   Thanks to the third property of measure boxes, we have: </p><table class='equation-star'><tr><td>
<!-- l. 448 --><object data="svgs/measure-box-adj.svg" alt="diagram of measure-box-adj" class="svg-diagram"></object></td></tr></table>
<!-- l. 451 --><p class='indent'>   Using the other two properties: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 452 --><object data="svgs/measure-box-isom.svg" alt="diagram of measure-box-isom" class="svg-diagram"></object></td></tr></table>
<!-- l. 455 --><p class='indent'>   and similarly, <!-- l. 455 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>L</mi><msup><mrow><mi>L</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi></mrow></math>.
So <!-- l. 455 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>L</mi></math> is
a unitary!
</p>
   <div class='newtheorem'>
<!-- l. 456 --><p class='noindent'><span class='head'>
<a id='x9-164001r1'></a>
<span class='cmbx-10x-x-109'>Proposition 7.3.1.</span>  </span> For any self-adjoint Pauli string
<!-- l. 457 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></math>, the
following map: </p><table class='equation'><tr><td>
<!-- l. 458 --><p class='indent'>
</p><!-- l. 458 --><object id='x9-164002r28' data="svgs/pauli-box.svg" alt="diagram of pauli-box" class="svg-diagram"></object></td><td class='eq-no'>(7.28)</td></tr></table>
<!-- l. 461 --><p class='indent'>   is a unitary.
</p>
   </div>
<!-- l. 462 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 464 --><p class='indent'>   <span class='head'>
                                                                     

                                                                     
<span class='cmti-10x-x-109'>Proof.</span> </span>Follows immediately from the fact that Pauli boxes are measurement
boxes, as shown in Exercise <a href='main_htmlch6.html#x8-136025r8'>6.8<!-- tex4ht:ref: exer:measure-box  --></a>.                                                       □
</p>
   </div>
<!-- l. 466 --><p class='indent'>   Let’s expand out what is in the Pauli box to see what these unitaries
from Proposition <a href='#x9-164001r1'>7.3.1<!-- tex4ht:ref: prop:Pauli-box-unitary  --></a> actually look like. Recall from Definition <a href='main_htmlch6.html#x8-136014r3'>6.2.3<!-- tex4ht:ref: def:Pauli-proj  --></a>
that
</p>
<div class='center'>
<!-- l. 468 --><p class='noindent'>
</p><!-- l. 469 --><p class='noindent'><object data="svgs/pauli-box.svg" alt="diagram of pauli-box" class="svg-diagram"></object> </p></div>
<!-- l. 472 --><p class='indent'>   where
</p>
<div class='center'>
<!-- l. 474 --><p class='noindent'>
</p><!-- l. 475 --><p class='noindent'><object data="svgs/pauli-boxes.svg" alt="diagram of pauli-boxes" class="svg-diagram"></object> </p></div>
<!-- l. 478 --><p class='indent'>   Hence, for the special case of <!-- l. 478 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>Z</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mo class='MathClass-rel' stretchy='false'>⋯</mo> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>Z</mi></mrow></math>
we get: </p><table class='equation'><tr><td>
<!-- l. 479 --><p class='indent'>
</p><!-- l. 479 --><object id='x9-164003r29' data="svgs/pauli-exp-ZZ-alpha.svg" alt="diagram of pauli-exp-ZZ-alpha" class="svg-diagram"></object></td><td class='eq-no'>(7.29)</td></tr></table>
<!-- l. 482 --><p class='indent'>   We get phase gadgets! For a general unitary built from
Pauli boxes, we can adapt Eq. (<a href='main_htmlch6.html#x8-136017r8'>6.8<!-- tex4ht:ref: eq:pproj-Ui  --></a>): for any Pauli string
<!-- l. 484 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>P</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mo>…</mo> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <msub><mrow><mi>P</mi></mrow><mrow><mi>n</mi></mrow></msub></mrow></math> with
<!-- l. 484 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>P</mi></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>∈</mo><mo class='MathClass-open' stretchy='false'>{</mo><mi>X</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>Y</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>Z</mi><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>, we
have: </p><table class='equation'><tr><td>
<!-- l. 485 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 485 --><object id='x9-164004r30' data="svgs/eq-puni-Ui.svg" alt="diagram of eq:puni-Ui" class="svg-diagram"></object></td><td class='eq-no'>(7.30)</td></tr></table>
<!-- l. 488 --><p class='indent'>   The general case can be obtained by additionally representing any
<!-- l. 488 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>P</mi></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi></mrow></math> by simply not
connecting to the <!-- l. 488 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math>-th
qubit. The unitaries built from Pauli boxes in this way hence generalise phase
gadgets: they are just phase gadgets surrounded by some particular single-qubit
Cliffords. We will call such unitaries <span class='cmbx-10x-x-109'>Pauli exponentials</span>. As the name suggests,
we can view these unitaries as special cases of matrix exponentials, which we’ll
introduce in the next section.
</p>
   <h4 class='subsectionHead' id='matrix-exponentials'><span class='titlemark'>7.3.2   </span> <a id='x9-1650007.3.2'></a>Matrix exponentials</h4>
<!-- l. 492 --><p class='noindent'>We first mentioned matrix exponentials back in Section <a href='main_htmlch2.html#unitary-evolution'>2.2.3<!-- tex4ht:ref: sec:unitaries  --></a> as a means of
constructing solutions to the Schrödinger equation, but avoided giving a formal
definition. We’ll do that now. At this point, we should be pretty used to raising
<!-- l. 493 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>e</mi></math> to the power of a
complex number <!-- l. 493 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>z</mi></math>.
For instance, when <!-- l. 493 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>z</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi mathvariant='italic'>iα</mi></mrow></math>
is imaginary, this is how to obtain phases. If we crack open a textbook on complex analysis,
we’ll see that <!-- l. 493 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi>z</mi></mrow></msup></math>
for any complex number is defined as the following power series: </p><table class='equation-star'><tr><td>
<!-- l. 494 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                          <msup><mrow><mi>e</mi></mrow><mrow><mi>z</mi></mrow></msup> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo><munderover accent='false' accentunder='false'><mrow><mo> ∑</mo>
  </mrow><mrow><mi>k</mi><mo class='MathClass-rel' stretchy='false'>=</mo><mn>0</mn></mrow><mrow><mi>∞</mi></mrow></munderover><mfrac><mrow><msup><mrow><mi>z</mi></mrow><mrow><mi>k</mi></mrow></msup></mrow>
<mrow><mi>k</mi><mo class='MathClass-punc' stretchy='false'>!</mo></mrow></mfrac>
</mrow></math></td></tr></table>
                                                                     

                                                                     
<!-- l. 497 --><p class='indent'>   Swapping out the complex number
<!-- l. 497 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>z</mi></math> for a square
matrix <!-- l. 497 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>
gives us a definition for the <span class='cmbx-10x-x-109'>matrix exponential</span>: </p><table class='equation'><tr><td>
<!-- l. 498 --><p class='indent'>
</p><!-- l. 498 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                          <mstyle class='label' id='x9-165001r31'></mstyle><!-- endlabel --><msup><mrow><mi>e</mi></mrow><mrow><mi>A</mi></mrow></msup> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo><munderover accent='false' accentunder='false'><mrow><mo> ∑</mo>
  </mrow><mrow><mi>k</mi><mo class='MathClass-rel' stretchy='false'>=</mo><mn>0</mn></mrow><mrow><mi>∞</mi></mrow></munderover><mfrac><mrow><msup><mrow><mi>A</mi></mrow><mrow><mi>k</mi></mrow></msup></mrow>
 <mrow><mi>k</mi><mo class='MathClass-punc' stretchy='false'>!</mo></mrow></mfrac> <mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td><td class='eq-no'>(7.31)</td></tr></table>
<!-- l. 501 --><p class='indent'>   Here the powers <!-- l. 501 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>A</mi></mrow><mrow><mi>k</mi></mrow></msup></math>
are just multiplying <!-- l. 501 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>
with itself <!-- l. 501 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> times,
and in particular <!-- l. 501 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>A</mi></mrow><mrow><mn>0</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi></mrow></math>
is the identity matrix. There are a few things we should know about matrix
exponentials. The first is that if we are working with a diagonal matrix, then its
matrix exponential is just the exponential of each of its components:
</p><table class='equation'><tr><td>
<!-- l. 503 --><p class='indent'>
</p><!-- l. 503 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                    <mstyle class='label' id='x9-165002r32'></mstyle><!-- endlabel --><msup><mrow><mi>e</mi></mrow><mrow><mstyle class='text'><mtext>diag</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>a</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>a</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mstyle class='text'><mtext>diag</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>e</mi></mrow><mrow><msub><mrow><mi>a</mi></mrow><mrow><mn>1</mn></mrow></msub>
    </mrow></msup><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mi>e</mi></mrow><mrow><msub><mrow><mi>a</mi></mrow><mrow><mi>n</mi></mrow></msub>
   </mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td><td class='eq-no'>(7.32)</td></tr></table>
<!-- l. 506 --><p class='indent'>   This works because, when we raise a diagonal matrix to a power
<!-- l. 506 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>, it
just goes inside:
                                                                     

                                                                     
</p><!-- tex4ht:inline --><!-- l. 517 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mtable class='align-star' columnalign='left' displaystyle='true'>
       <mtr><mtd class='align-odd' columnalign='right'><msup><mrow><mi>e</mi></mrow><mrow><mstyle class='text'><mtext>diag</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>a</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>a</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup></mtd>       <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo><munderover accent='false' accentunder='false'><mrow><mo> ∑</mo>
  </mrow><mrow><mi>k</mi><mo class='MathClass-rel' stretchy='false'>=</mo><mn>0</mn></mrow><mrow><mi>∞</mi></mrow></munderover><mfrac><mrow><mstyle class='text'><mtext>diag</mtext></mstyle><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>a</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>a</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi>k</mi></mrow></msup></mrow>
         <mrow><mi>k</mi><mo class='MathClass-punc' stretchy='false'>!</mo></mrow></mfrac>          <mo class='MathClass-rel' stretchy='false'>=</mo><munderover accent='false' accentunder='false'><mrow><mo> ∑</mo>
</mrow><mrow><mi>k</mi><mo class='MathClass-rel' stretchy='false'>=</mo><mn>0</mn></mrow><mrow><mi>∞</mi></mrow></munderover><mfrac><mrow><mstyle class='text'><mtext>diag</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><msubsup><mrow><mi>a</mi></mrow><mrow><mn>1</mn></mrow><mrow><mi>k</mi></mrow></msubsup><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msubsup><mrow><mi>a</mi></mrow><mrow><mi>n</mi></mrow><mrow><mi>k</mi></mrow></msubsup><mo class='MathClass-close' stretchy='false'>)</mo></mrow>
         <mrow><mi>k</mi><mo class='MathClass-punc' stretchy='false'>!</mo></mrow></mfrac>          <mspace width='2em'></mspace></mtd>       <mtd class='align-label' columnalign='right'></mtd>       <mtd class='align-label'>
       <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>                   <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mstyle class='text'><mtext>diag</mtext></mstyle> <mrow><mo fence='true' form='prefix'>(</mo><mrow><munder class='msub'><mrow><mo>∑</mo>
  </mrow><mrow><mi>k</mi></mrow></munder><mfrac><mrow><msubsup><mrow><mi>a</mi></mrow><mrow><mn>1</mn></mrow><mrow><mi>k</mi></mrow></msubsup></mrow> 
 <mrow><mi>k</mi><mo class='MathClass-punc' stretchy='false'>!</mo></mrow></mfrac>  <mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><munder class='msub'><mrow><mo>∑</mo>
  </mrow><mrow><mi>k</mi></mrow></munder><mfrac><mrow><msubsup><mrow><mi>a</mi></mrow><mrow><mi>n</mi></mrow><mrow><mi>k</mi></mrow></msubsup></mrow> 
 <mrow><mi>k</mi><mo class='MathClass-punc' stretchy='false'>!</mo></mrow></mfrac>  </mrow><mo fence='true' form='postfix'>)</mo></mrow><mspace width='2em'></mspace></mtd>                                   <mtd class='align-label' columnalign='right'></mtd>       <mtd class='align-label'>
       <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>                   <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mstyle class='text'><mtext>diag</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>e</mi></mrow><mrow><msub><mrow><mi>a</mi></mrow><mrow><mn>1</mn></mrow></msub>
    </mrow></msup><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mi>e</mi></mrow><mrow><msub><mrow><mi>a</mi></mrow><mrow><mi>n</mi></mrow></msub>
   </mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo><mspace width='2em'></mspace></mtd>                                         <mtd class='align-label' columnalign='right'></mtd>       <mtd class='align-label'>
   <mspace width='2em'></mspace></mtd></mtr></mtable></math>
<!-- l. 518 --><p class='noindent'>The second thing we need to know is that conjugation by a unitary commutes
with exponentiation: </p><table class='equation'><tr><td>
<!-- l. 519 --><p class='indent'>
</p><!-- l. 519 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
        <mstyle class='label' id='x9-165003r33'></mstyle><!-- endlabel --><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>UA</mi><msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup>
    </mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo><munderover accent='false' accentunder='false'><mrow><mo> ∑</mo>
  </mrow><mrow><mi>k</mi><mo class='MathClass-rel' stretchy='false'>=</mo><mn>0</mn></mrow><mrow><mi>∞</mi></mrow></munderover><mfrac><mrow><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi mathvariant='italic'>UA</mi><msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi>k</mi></mrow></msup></mrow>
     <mrow><mi>k</mi><mo class='MathClass-punc' stretchy='false'>!</mo></mrow></mfrac>      <mo class='MathClass-rel' stretchy='false'>=</mo><munderover accent='false' accentunder='false'><mrow><mo> ∑</mo>
</mrow><mrow><mi>k</mi><mo class='MathClass-rel' stretchy='false'>=</mo><mn>0</mn></mrow><mrow><mi>∞</mi></mrow></munderover><mfrac><mrow><mi>U</mi><msup><mrow><mi>A</mi></mrow><mrow><mi>k</mi></mrow></msup><msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup></mrow>
  <mrow><mi>k</mi><mo class='MathClass-punc' stretchy='false'>!</mo></mrow></mfrac>     <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>U</mi><msup><mrow><mi>e</mi></mrow><mrow><mi>A</mi></mrow></msup><msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td><td class='eq-no'>(7.33)</td></tr></table>
<!-- l. 522 --><p class='indent'>   With these facts we can easily compute the matrix exponential of any diagonalisable matrix.
Let <!-- l. 522 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math> be a matrix with
diagonalisation <!-- l. 522 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>A</mi> <mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow> <mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>j</mi></mrow></msub><msub><mrow><mi>λ</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>ϕ</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><msub><mrow><mi>ϕ</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>
for some ONB <!-- l. 522 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>{</mo><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>ϕ</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>.
Write <!-- l. 523 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>U</mi> <mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow> <mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>ϕ</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mi>j</mi><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>
for the unitary that maps the computational basis
<!-- l. 523 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>{</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mi>j</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math> into the
eigenbasis <!-- l. 523 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>{</mo><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>ϕ</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math> of
<!-- l. 523 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>, and write
<!-- l. 523 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>D</mi> <mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow> <mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>j</mi></mrow></msub><msub><mrow><mi>λ</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><mi>j</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mi>j</mi><mo class='MathClass-rel' stretchy='false'>|</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mstyle class='text'><mtext>diag</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>λ</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>λ</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> for the diagonal matrix
of eigenvalues of <!-- l. 523 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>.
Then we have <!-- l. 523 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>A</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi mathvariant='italic'>UD</mi><msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup></mrow></math>.
Hence, we calculate <!-- l. 523 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>e</mi></mrow><mrow><mi>A</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>UD</mi><msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup>
    </mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>U</mi><msup><mrow><mi>e</mi></mrow><mrow><mi>D</mi></mrow></msup><msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup></mrow></math>.
As <!-- l. 523 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi>D</mi></mrow></msup></math> is the
exponential of a diagonal matrix, it is easily calculated and so we get an easy expression
for <!-- l. 523 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi>A</mi></mrow></msup></math>, simply
                                                                     

                                                                     
by multiplying out the matrices of its diagonalisation. There is one final property of
the matrix exponential we will be interested in. Remember that for regular complex
numbers <!-- l. 524 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>z</mi></mrow><mrow><mn>1</mn></mrow></msub></math>
and <!-- l. 524 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>z</mi></mrow><mrow><mn>2</mn></mrow></msub></math> we have
<!-- l. 524 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>e</mi></mrow><mrow><msub><mrow><mi>z</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>+</mo><msub><mrow><mi>z</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><msub><mrow><mi>z</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><msub><mrow><mi>z</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></msup></mrow></math>. The same
holds for the matrix exponential <span class='cmti-10x-x-109'>as long as </span>the matrices commute. That is, if we have
matrices <!-- l. 524 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>
and <!-- l. 524 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>B</mi></math> that
commute, then <!-- l. 524 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>e</mi></mrow><mrow><mi>A</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mi>B</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi>A</mi></mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mi>B</mi></mrow></msup></mrow></math>.
When <!-- l. 524 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>
and <!-- l. 524 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>B</mi></math>
allow diagonalisations, this is easily proven, as we can then find a joint
diagonalisation, and reduce the problem to diagonal matrices.
</p>
   <div class='newtheorem'>
<!-- l. 525 --><p class='noindent'><span class='head'>
<a id='x9-165004r2'></a>
<span class='cmbx-10x-x-109'>Proposition 7.3.2.</span>  </span> Let <!-- l. 526 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>
and <!-- l. 526 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>B</mi></math>
be commuting square matrices. Then <!-- l. 526 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>e</mi></mrow><mrow><mi>A</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mi>B</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi>A</mi></mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mi>B</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi>B</mi></mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mi>A</mi></mrow></msup></mrow></math>.
In particular <!-- l. 526 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>I</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mn>0</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi>A</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mi>A</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi>A</mi></mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi>A</mi></mrow></msup></mrow></math>
so that <!-- l. 526 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>e</mi></mrow><mrow><mi>A</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi>A</mi></mrow></msup></mrow></math>
for any matrix <!-- l. 526 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>.
</p>
   </div>
<!-- l. 527 --><p class='indent'>    When <!-- l. 528 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math> and
<!-- l. 528 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>B</mi></math> do not commute,
we generally have <!-- l. 528 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>e</mi></mrow><mrow><mi>A</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mi>B</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>≠</mo><msup><mrow><mi>e</mi></mrow><mrow><mi>A</mi></mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mi>B</mi></mrow></msup></mrow></math>.
In fact, studying ways to approximate the value of
<!-- l. 528 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi>A</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mi>B</mi></mrow></msup></math> using
just <!-- l. 528 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi>A</mi></mrow></msup></math>
and <!-- l. 528 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi>B</mi></mrow></msup></math>
is incredibly important for simulating quantum mechanical systems using a
quantum computer. We’ll study this problem in more detail in Section <a href='#hamiltonian-simulation'>7.5<!-- tex4ht:ref: sec:hammy-sim  --></a>.
</p>
   <h4 class='subsectionHead' id='building-unitaries-as-exponentials'><span class='titlemark'>7.3.3   </span> <a id='x9-1660007.3.3'></a>Building unitaries as exponentials</h4>
<!-- l. 530 --><p class='noindent'>With this mathematical machinery of matrix exponentials in hand, let’s look at
how it can help us understand unitary maps. Suppose we have some
<!-- l. 530 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-dimensional
                                                                     

                                                                     
unitary <!-- l. 530 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>.
As discussed in Section <a href='main_htmlch2.html#types-of-linear-maps'>2.1.3<!-- tex4ht:ref: sec:linear-maps  --></a>, a unitary is a normal linear map and hence can be
diagonalised: <!-- l. 530 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>U</mi> <mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow> <mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>j</mi></mrow></msub><msub><mrow><mi>λ</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>ϕ</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><msub><mrow><mi>ϕ</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>.
Using the description above we can then also write this as
<!-- l. 530 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>U</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>V</mi> <mi>D</mi><msup><mrow><mi>V</mi> </mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup></mrow></math> where
<!-- l. 530 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> </mrow></math> is some
unitary and <!-- l. 530 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>D</mi></math>
is some diagonal matrix consisting of the eigenvalues of
<!-- l. 530 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>.
Now remember that all the eigenvalues of a unitary are phases so that
<!-- l. 531 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>λ</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><msub><mrow><mi>α</mi></mrow><mrow><mi>j</mi></mrow></msub></mrow></msup></mrow></math> for some
phases <!-- l. 531 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>α</mi></mrow><mrow><mi>j</mi></mrow></msub></math>. This
means that <!-- l. 531 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>D</mi></math> is
a matrix of exponentials. In the previous section we saw that the exponential of a diagonal
matrix is a matrix of exponentials. The converse is however also true. We can hence
write <!-- l. 531 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>D</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><msup><mrow><mi>D</mi></mrow><mrow><mi>′</mi></mrow></msup>
  </mrow></msup></mrow></math> where
<!-- l. 531 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>D</mi></mrow><mrow><mi>′</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mstyle class='text'><mtext>diag</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>α</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>α</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>. We have here taken
out the factor of <!-- l. 531 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>i</mi></math>
out of the matrix for reasons that will become clear soon enough. So now we have
<!-- l. 532 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>U</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>V</mi> <msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><msup><mrow><mi>D</mi></mrow><mrow><mi>′</mi></mrow></msup>
  </mrow></msup><msup><mrow><mi>V</mi> </mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup></mrow></math>. We can take this
conjugation by <!-- l. 532 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>V</mi> </mrow></math> inside of the
matrix exponential to get <!-- l. 532 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>U</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iH</mi></mrow></msup></mrow></math>
where <!-- l. 532 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>H</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>V</mi> <msup><mrow><mi>D</mi></mrow><mrow><mi>′</mi></mrow></msup><msup><mrow><mi>V</mi> </mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup></mrow></math>. Now the
eigenvalues of <!-- l. 532 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math> are
precisely the values in <!-- l. 532 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>D</mi></mrow><mrow><mi>′</mi></mrow></msup></math>,
which are real numbers. As we saw in Exercise <a href='main_htmlch2.html#x4-13003r4'>2.4<!-- tex4ht:ref: exer:diag-scalars  --></a> a matrix whose eigenvalues
are real numbers is self-adjoint. We hence have proven the following result.
</p>
   <div class='newtheorem'>
<!-- l. 533 --><p class='noindent'><span class='head'>
<a id='x9-166001r3'></a>
<span class='cmbx-10x-x-109'>Proposition 7.3.3.</span>  </span> Any unitary <!-- l. 534 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
is the complex exponential of some self-adjoint matrix <!-- l. 534 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math>
via <!-- l. 534 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>U</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iH</mi></mrow></msup></mrow></math>.
</p>
   </div>
<!-- l. 535 --><p class='indent'>    Note that <!-- l. 536 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math> is not unique:
we can add <!-- l. 536 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>2</mn><mi mathvariant='italic'>πI</mi></mrow></math> to it and still
get the same result: <!-- l. 536 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>H</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mn>2</mn><mi mathvariant='italic'>πI</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iH</mi></mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mn>2</mn><mi mathvariant='italic'>πI</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iH</mi></mrow></msup></mrow></math>. Here
in the last step we used <!-- l. 536 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>e</mi></mrow><mrow><mn>2</mn><mi mathvariant='italic'>iπ</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>.
In fact, adding any multiple of the identity to
                                                                     

                                                                     
<!-- l. 536 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math> just changes the
global phase of <!-- l. 536 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>,
and so we don’t care about it. The converse of Proposition <a href='#x9-166001r3'>7.3.3<!-- tex4ht:ref: prop:unitary-is-exponential  --></a> is also true: if we take some
self-adjoint matrix <!-- l. 537 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math>,
then <!-- l. 537 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iH</mi></mrow></msup></math>
is unitary (This follows from Exercise <a href='main_htmlch2.html#x4-13003r4'>2.4<!-- tex4ht:ref: exer:diag-scalars  --></a>, as the eigenvalues of
<!-- l. 537 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iH</mi></mrow></msup></math> will all
be complex phases). This gives us a way to construct unitaries. In fact, given a
self-adjoint <!-- l. 537 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math>,
it will be useful to consider the entire family of unitaries constructed by rescaling
<!-- l. 537 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math>: for any
<!-- l. 537 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>t</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℝ</mi></mrow></math> we have that
<!-- l. 537 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>itH</mi></mrow></msup></math> is unitary. We
use the letter <!-- l. 537 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>t</mi></math>
here, as this gives the elapsed time in the Schrödinger equation.
</p>
   <div class='newtheorem'>
<!-- l. 538 --><p class='noindent'><span class='head'>
<a id='x9-166002r4'></a>
<span class='cmbx-10x-x-109'>Example 7.3.4.</span>  </span> Let <!-- l. 539 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi> <mo class='MathClass-rel' stretchy='false'>=</mo><mi class='qopname'> diag</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
be the standard Pauli <!-- l. 539 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math>.
Then for any <!-- l. 539 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>t</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℝ</mi></mrow></math>
we calculate <!-- l. 539 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>itZ</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo><mi class='qopname'> diag</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>it</mi></mrow></msup><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>it</mi></mrow></msup><mi class='qopname'> diag</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>2</mn><mi mathvariant='italic'>it</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
So we see that </p><table class='equation'><tr><td>
<!-- l. 541 --><p class='indent'>
</p><!-- l. 541 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                            <mstyle class='label' id='x9-166003r34'></mstyle><!-- endlabel --><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>itZ</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>∝</mo> <mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mn>2</mn><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td><td class='eq-no'>(7.34)</td></tr></table>
<!-- l. 544 --><p class='indent'>   In particular, the <!-- l. 544 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math>
and <!-- l. 544 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates can be written
(up to global phase) as <!-- l. 544 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>S</mi> <mo class='MathClass-rel' stretchy='false'>∝</mo> <msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> <mi>Z</mi></mrow></msup></mrow></math>
and <!-- l. 544 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>T</mi> <mo class='MathClass-rel' stretchy='false'>∝</mo> <msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>8</mn></mrow></mfrac> <mi>Z</mi></mrow></msup></mrow></math>. It is for this reason
that in some works the <!-- l. 544 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gate is also called the <!-- l. 544 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>8</mn></mrow></mfrac> </mrow></math>
                                                                     

                                                                     
phase gate.
</p>
   </div>
<!-- l. 545 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 546 --><p class='noindent'><span class='head'>
<a id='x9-166004r5'></a>
<span class='cmbx-10x-x-109'>Example 7.3.5.</span>  </span> For the Pauli <!-- l. 547 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>
gate we can easily calculate its matrix exponential by realising that
<!-- l. 547 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>X</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi mathvariant='italic'>HZ</mi><msup><mrow><mi>H</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup></mrow></math> (of
course <!-- l. 547 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>H</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>H</mi></mrow></math>,
but it will be useful to write it like this) and using Eq. (<a href='#x9-165003r33'>7.33<!-- tex4ht:ref: eq:exp-conjugation  --></a>):
<!-- l. 547 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>itX</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>itHZ</mi><msup><mrow><mi>H</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup>
      </mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>H</mi><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>itZ</mi></mrow></msup><msup><mrow><mi>H</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mo class='MathClass-rel' stretchy='false'>∝</mo> <mi mathvariant='italic'>HZ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mn>2</mn><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo><msup><mrow><mi>H</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>X</mi><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mn>2</mn><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>, where we used Eq. (<a href='#x9-166003r34'>7.34<!-- tex4ht:ref: eq:Z-exp-phase  --></a>)
to convert the <!-- l. 547 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math> exponential
into a <!-- l. 547 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math> phase gate. Hence,
the exponentiated <!-- l. 547 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>
matrices correspond to <!-- l. 547 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>
phase gates. It is interesting however to see how you would calculate this directly
using the definition of the matrix exponential (<a href='#x9-165001r31'>7.31<!-- tex4ht:ref: eq:matrix-exponential  --></a>). The trick is to observe that
<!-- l. 547 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>X</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi></mrow></math>,
which allows us to split the infinite sum into two parts: </p><table class='equation-star'><tr><td>
<!-- l. 548 --><object data="svgs/eqrefeq-matrix-exponential.svg" alt="diagram of eqrefeq-matrix-exponential" class="svg-diagram"></object></td></tr></table>
<!-- l. 551 --><p class='indent'>   Here in the last step we used the standard Taylor series equality for
<!-- l. 551 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi class='qopname'>sin</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --></mrow></math> and
<!-- l. 551 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi class='qopname'>cos</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --></mrow></math>.
</p>
   </div>
                                                                     

                                                                     
<!-- l. 552 --><p class='indent'>    In this direct calculation of the matrix exponential of the Pauli
<!-- l. 553 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math> we actually
only used that <!-- l. 553 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>X</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi></mrow></math>,
and nothing else, so this calculation works for any matrix with this property. As
this is actually quite useful, let’s record this for later.
</p>
   <div class='newtheorem'>
<!-- l. 554 --><p class='noindent'><span class='head'>
<a id='x9-166005r6'></a>
<span class='cmbx-10x-x-109'>Proposition 7.3.6.</span>  </span> Let <!-- l. 555 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math>
be any matrix for which <!-- l. 555 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>M</mi></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi></mrow></math>.
Then <!-- l. 555 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>itM</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo><mi class='qopname'> cos</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi>I</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>i</mi><mi class='qopname'>sin</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi>M</mi></mrow></math>.
</p>
   </div>
<!-- l. 556 --><p class='indent'>
</p>
   <h4 class='subsectionHead' id='pauli-exponentials1'><span class='titlemark'>7.3.4   </span> <a id='x9-1670007.3.4'></a>Pauli exponentials</h4>
<!-- l. 558 --><p class='noindent'>Now that we can understand any unitary as a matrix exponential, let’s zoom in a bit
and take a look at Pauli exponentials. The Examples <a href='#x9-166002r4'>7.3.4<!-- tex4ht:ref: ex:Z-exponential  --></a> and <a href='#x9-165001r31'>7.31<!-- tex4ht:ref: eq:matrix-exponential  --></a> show that we can
view the <!-- l. 559 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math>
and <!-- l. 559 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math> phase
gates as exponentials of Pauli matrices. It turns out that this holds for essentially
<span class='cmti-10x-x-109'>all </span>unitaries if we do the same with multi-qubit Pauli strings. A Pauli string
<!-- l. 561 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></math> is just a tensor product
of single-qubit Paulis <!-- l. 561 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iα</mi></mrow></msup><msub><mrow><mi>P</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mo class='MathClass-rel' stretchy='false'>⋯</mo> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <msub><mrow><mi>P</mi></mrow><mrow><mi>n</mi></mrow></msub></mrow></math>
where <!-- l. 561 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>P</mi></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>∈</mo><mo class='MathClass-open' stretchy='false'>{</mo><mi>I</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>X</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>Y</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>Z</mi><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math> and
<!-- l. 561 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>α</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℝ</mi></mrow></math> is some
global phase. Since we want to take exponentials of these to construct unitaries, we want
<!-- l. 561 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></math> to be self-adjoint,
which requires <!-- l. 561 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iα</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>∈</mo><mo class='MathClass-open' stretchy='false'>{</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>.
</p>
   <div class='newtheorem'>
<!-- l. 562 --><p class='noindent'><span class='head'>
<a id='x9-167001r7'></a>
<span class='cmbx-10x-x-109'>Definition 7.3.7.</span>  </span>A <span class='cmbx-10x-x-109'>Pauli exponential </span>is any unitary of the form:
                                                                     

                                                                     
<!-- tex4ht:inline --></p><!-- l. 564 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                             <msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>±</mo><mi mathvariant='italic'>i𝜃</mi><msub><mrow><mi>P</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>⊗</mo><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>P</mi></mrow><mrow><mi>n</mi></mrow></msub>
                </mrow></msup>
</mrow></math>
<!-- l. 564 --><p class='nopar'>                              where                                           the
<!-- l. 565 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>P</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>∈</mo><mo class='MathClass-open' stretchy='false'>{</mo><mi>I</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>X</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>Y</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>Z</mi><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>
are                                         Paulis                                         and
<!-- l. 565 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>𝜃</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℝ</mi></mrow></math>
is a phase.
</p>
   </div>
<!-- l. 566 --><p class='indent'>    Here we write <!-- l. 567 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>𝜃</mi></math>
instead of <!-- l. 567 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>t</mi></math>,
because we will be thinking of this as an angle in a rotation, instead of an elapsed
time. Using Proposition <a href='#x9-166005r6'>7.3.6<!-- tex4ht:ref: prop:exp-self-inverse  --></a> we calculate: </p><table class='equation'><tr><td>
<!-- l. 569 --><p class='indent'>
</p><!-- l. 569 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
            <mstyle class='label' id='x9-167002r35'></mstyle><!-- endlabel --><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>±</mo><mi mathvariant='italic'>i𝜃</mi><msub><mrow><mi>P</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>⊗</mo><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>P</mi></mrow><mrow><mi>n</mi></mrow></msub>
                </mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo><mi class='qopname'> cos</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><mi>𝜃</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi>I</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mo class='MathClass-rel' stretchy='false'>⋯</mo> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>I</mi> <mo class='MathClass-bin' stretchy='false'>±</mo> <mi>i</mi><mi class='qopname'>sin</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><mi>𝜃</mi><mo class='MathClass-close' stretchy='false'>)</mo><msub><mrow><mi>P</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>P</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td><td class='eq-no'>(7.35)</td></tr></table>
<!-- l. 572 --><p class='indent'>   Using this, we see that an identity in a Pauli string makes the Pauli
exponential act as an identity on that qubit: </p><table class='equation'><tr><td>
<!-- l. 573 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 573 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mstyle class='label' id='x9-167003r36'></mstyle><!-- endlabel --><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>±</mo><mi mathvariant='italic'>i𝜃I</mi><mo class='MathClass-bin' stretchy='false'>⊗</mo><mi>P</mi> </mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo><mi class='qopname'> cos</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><mi>𝜃</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi>I</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mi>I</mi> <mo class='MathClass-bin' stretchy='false'>±</mo><mi>i</mi><mi class='qopname'>sin</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><mi>𝜃</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi>I</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mi>P</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mo class='MathClass-open' stretchy='false'>(</mo><mi class='qopname'>cos</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><mi>𝜃</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi>I</mi> <mo class='MathClass-bin' stretchy='false'>±</mo><mi>i</mi><mi class='qopname'>sin</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><mi>𝜃</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi>P</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>i𝜃P</mi> </mrow></msup><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td><td class='eq-no'>(7.36)</td></tr></table>
<!-- l. 576 --><p class='indent'>   We can use this to calculate a circuit that implements any Pauli exponential
using gates we have already encountered. Before we do that in full generality it
will be useful to consider a specific example.
</p>
   <div class='newtheorem'>
<!-- l. 577 --><p class='noindent'><span class='head'>
<a id='x9-167004r8'></a>
<span class='cmbx-10x-x-109'>Example 7.3.8.</span>  </span>Let’s calculate what unitary
<!-- l. 578 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>i𝜃Z</mi><mo class='MathClass-bin' stretchy='false'>⊗</mo><mi>Z</mi></mrow></msup></math> is. First, let’s do it
directly. Note that <!-- l. 578 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>Z</mi> <mo class='MathClass-rel' stretchy='false'>=</mo><mi class='qopname'> diag</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
Then using Proposition <a href='#x9-166005r6'>7.3.6<!-- tex4ht:ref: prop:exp-self-inverse  --></a> we get
</p><!-- tex4ht:inline --><!-- l. 583 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mtable class='align-star' columnalign='left' displaystyle='true'>
        <mtr><mtd class='align-odd' columnalign='right'><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>i𝜃Z</mi><mo class='MathClass-bin' stretchy='false'>⊗</mo><mi>Z</mi></mrow></msup></mtd>        <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo><mi class='qopname'> cos</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><mi>𝜃</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi>I</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>I</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>i</mi><mi class='qopname'>sin</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><mi>𝜃</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi>Z</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>Z</mi><mspace width='2em'></mspace></mtd>                           <mtd class='align-label' columnalign='right'></mtd>        <mtd class='align-label'>
        <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>              <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo><mi class='qopname'> cos</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><mi>𝜃</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi class='qopname'>diag</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>i</mi><mi class='qopname'>sin</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><mi>𝜃</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi class='qopname'>diag</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo><mspace width='2em'></mspace></mtd>        <mtd class='align-label' columnalign='right'></mtd>        <mtd class='align-label'>
        <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>              <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo><mi class='qopname'> diag</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>i𝜃</mi></mrow></msup><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>i𝜃</mi></mrow></msup><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>i𝜃</mi></mrow></msup><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>i𝜃</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-punc' stretchy='false'>.</mo><mspace width='2em'></mspace></mtd>                              <mtd class='align-label' columnalign='right'></mtd>        <mtd class='align-label'>
   <mspace width='2em'></mspace></mtd></mtr></mtable></math>
<!-- l. 584 --><p class='noindent'>Here in the last step we used <!-- l. 584 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>±</mo><mi mathvariant='italic'>i𝜃</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo><mi class='qopname'> cos</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><mi>𝜃</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>±</mo> <mi>i</mi><mi class='qopname'>sin</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><mi>𝜃</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
Now, let’s calculate this in a more systematic way. Note that
<!-- l. 585 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>Z</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mstyle class='text'><mtext>CNOT</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mi>I</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>Z</mi><mo class='MathClass-close' stretchy='false'>)</mo><msup><mrow><mstyle class='text'><mtext>CNOT</mtext></mstyle></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup></mrow></math> (see
Section <a href='main_htmlch6.html#clifford-conjugation-aka-pushin-paulis'>6.1.1<!-- tex4ht:ref: sec:Clifford-conj  --></a>). Hence:
                                                                     

                                                                     
</p><!-- tex4ht:inline --><!-- l. 592 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mtable class='align-star' columnalign='left' displaystyle='true'>
 <mtr><mtd class='align-odd' columnalign='right'><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>±</mo><mi mathvariant='italic'>i𝜃Z</mi><mo class='MathClass-bin' stretchy='false'>⊗</mo><mi>Z</mi></mrow></msup></mtd> <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>±</mo><mi mathvariant='italic'>i𝜃 </mi><mstyle class='text'><mtext>CNOT</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mi>I</mi><mo class='MathClass-bin' stretchy='false'>⊗</mo><mi>Z</mi><mo class='MathClass-close' stretchy='false'>)</mo><msup><mrow><mstyle class='text'><mtext>CNOT</mtext></mstyle></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup>
                    </mrow></msup><mover class='stackrel'><mrow><mo class='MathClass-rel' stretchy='false'>=</mo></mrow><mrow><mrow><mstyle class='text'><mtext class='textup' mathvariant='normal'>(</mtext><mtext class='label' xlink:href='#x9-165003r33' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'>7.33<!-- tex4ht:ref: eq:exp-conjugation  --></mtext><mtext class='endlabel'>)</mtext></mstyle></mrow></mrow></mover><mstyle class='text'><mtext>CNOT</mtext></mstyle><mi> </mi><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>±</mo><mi mathvariant='italic'>i𝜃I</mi><mo class='MathClass-bin' stretchy='false'>⊗</mo><mi>Z</mi></mrow></msup><mspace class='nbsp' width='0.33em'></mspace><msup><mrow><mstyle class='text'><mtext>CNOT</mtext></mstyle></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mspace width='2em'></mspace></mtd>           <mtd class='align-label' columnalign='right'></mtd> <mtd class='align-label'>
 <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>        <mtd class='align-even'><mover class='stackrel'><mrow><mo class='MathClass-rel' stretchy='false'>=</mo></mrow><mrow><mrow><mstyle class='text'><mtext class='textup' mathvariant='normal'>(</mtext><mtext class='label' xlink:href='#x9-167003r36' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'>7.36<!-- tex4ht:ref: eq:exp-Pauli-id  --></mtext><mtext class='endlabel'>)</mtext></mstyle></mrow></mrow></mover><mstyle class='text'><mtext>CNOT</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mi>I</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>±</mo><mi mathvariant='italic'>i𝜃Z</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo><msup><mrow><mstyle class='text'><mtext>CNOT</mtext></mstyle></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mover class='stackrel'><mrow><mo class='MathClass-rel' stretchy='false'>∝</mo></mrow><mrow><mrow><mstyle class='text'><mtext class='textup' mathvariant='normal'>(</mtext><mtext class='label' xlink:href='#x9-166003r34' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'>7.34<!-- tex4ht:ref: eq:Z-exp-phase  --></mtext><mtext class='endlabel'>)</mtext></mstyle></mrow></mrow></mover><mstyle class='text'><mtext>CNOT</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mi>I</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-bin' stretchy='false'>∓</mo><mn>2</mn><mi>𝜃</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo><msup><mrow><mstyle class='text'><mtext>CNOT</mtext></mstyle></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mspace width='2em'></mspace></mtd> <mtd class='align-label' columnalign='right'></mtd> <mtd class='align-label'>
 <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>        <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo><mi class='qopname'> diag</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>∓</mo><mn>2</mn><mi>𝜃</mi></mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>∓</mo><mn>2</mn><mi>𝜃</mi></mrow></msup><mo class='MathClass-punc' stretchy='false'>,</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-punc' stretchy='false'>.</mo><mspace width='2em'></mspace></mtd>                                            <mtd class='align-label' columnalign='right'></mtd> <mtd class='align-label'>
   <mspace width='2em'></mspace></mtd></mtr></mtable></math>
<!-- l. 593 --><p class='noindent'>This last matrix is indeed equal to what we got before, up to global
phase.
</p>
   </div>
<!-- l. 594 --><p class='indent'>    The expression we got in this example,
<!-- l. 595 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext>CNOT</mtext></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mi>I</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-bin' stretchy='false'>∓</mo><mn>2</mn><mi>𝜃</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo><mstyle class='text'><mtext>CNOT</mtext></mstyle></mrow></math>
consists only of gates we have already encountered, and that we can in particular
write as a ZX-diagram: </p><table class='equation-star'><tr><td>
<!-- l. 596 --><object data="svgs/phase-gadget-two-qubit-theta.svg" alt="diagram of phase-gadget-two-qubit-theta" class="svg-diagram"></object></td></tr></table>
<!-- l. 599 --><p class='indent'>   It is also a phase gadget! This in fact remains true if we
add more qubits, by realising that a CNOT ladder sends
<!-- l. 599 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mo class='MathClass-rel' stretchy='false'>⋯</mo> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>Z</mi></mrow></math> to
<!-- l. 599 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>Z</mi></mrow><mrow><mi>n</mi></mrow></msub></math>:
</p><table class='equation'><tr><td>
<!-- l. 600 --><p class='indent'>
</p><!-- l. 600 --><object id='x9-167005r37' data="svgs/CNOT-ladder-Zs.svg" alt="diagram of CNOT-ladder-Zs" class="svg-diagram"></object></td><td class='eq-no'>(7.37)</td></tr></table>
                                                                     

                                                                     
<!-- l. 603 --><p class='indent'>   By Exercise <a href='#x9-158011r2'>7.2<!-- tex4ht:ref: exer:phase-gadget  --></a> such CNOT ladders with a phase in the middle are phase
gadgets. As the unitaries we constructed from Pauli boxes <span class='cmti-10x-x-109'>also </span>were phase
gadgets, we see that we can now relate them: </p><table class='equation'><tr><td>
<!-- l. 604 --><p class='indent'>
</p><!-- l. 604 --><object id='x9-167006r38' data="svgs/pauli-exp-ZZ-alpha-1.svg" alt="diagram of pauli-exp-ZZ-alpha-1" class="svg-diagram"></object></td><td class='eq-no'>(7.38)</td></tr></table>
<!-- l. 607 --><p class='indent'>   For a more general Pauli string <!-- l. 607 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>P</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mo>…</mo> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <msub><mrow><mi>P</mi></mrow><mrow><mi>n</mi></mrow></msub></mrow></math>
with <!-- l. 607 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>P</mi></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>∈</mo><mo class='MathClass-open' stretchy='false'>{</mo><mi>X</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>Y</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>Z</mi><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math> we can use the
fact that the <!-- l. 607 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>U</mi></mrow><mrow><mi>i</mi></mrow></msub></math> from
Eq. (<a href='#x9-164004r30'>7.30<!-- tex4ht:ref: eq:puni-Ui  --></a>) satisfy <!-- l. 607 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>P</mi></mrow><mrow><mi>i</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>U</mi></mrow><mrow><mi>i</mi></mrow></msub><mi>Z</mi><msubsup><mrow><mi>U</mi></mrow><mrow><mi>i</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msubsup></mrow></math>
to then write any Pauli exponential as a unitary from a Pauli box: setting
<!-- l. 607 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>U</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>U</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mo class='MathClass-rel' stretchy='false'>⋯</mo> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <msub><mrow><mi>U</mi></mrow><mrow><mi>n</mi></mrow></msub></mrow></math> we
have <!-- l. 607 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi mathvariant='italic'>UZ</mi><mo class='MathClass-rel' stretchy='false'>⋯</mo><mi>Z</mi><msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup></mrow></math>,
and hence
<!-- tex4ht:inline --></p><!-- l. 608 --><object data="svgs/pauli-exp-ZZ-U-alpha.svg" alt="diagram of pauli-exp-ZZ-U-alpha" class="svg-diagram"></object>
<!-- l. 610 --><p class='nopar'> Hence: </p><table class='equation'><tr><td>
<!-- l. 612 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 612 --><object id='x9-167007r39' data="svgs/Pauli-exp-alpha-short.svg" alt="diagram of Pauli-exp-alpha-short" class="svg-diagram"></object></td><td class='eq-no'>(7.39)</td></tr></table>
<!-- l. 615 --><p class='indent'>   It will be helpful to introduce some shorthand for
<!-- l. 615 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>i𝜃</mi><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow></msup></math>. For
<!-- l. 615 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math> and
<!-- l. 615 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math> phase gates we have
been writing <!-- l. 615 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> for a
phase rotation over <!-- l. 615 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>α</mi></math>. We
have also seen that <!-- l. 615 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>i𝜃Z</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>∝</mo> <mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mn>2</mn><mi>𝜃</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>, or
in other words that <!-- l. 615 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>∝</mo> <msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>iα</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn><mi>Z</mi></mrow></msup></mrow></math>.
This suggests the following notation for any Pauli string
<!-- l. 615 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></math>:
</p><table class='equation'><tr><td>
<!-- l. 616 --><p class='indent'>
</p><!-- l. 616 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                         <mstyle class='label' id='x9-167008r40'></mstyle><!-- endlabel --><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>α</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> </mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi>i</mi><mfrac><mrow><mi>α</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> <mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow></msup><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td><td class='eq-no'>(7.40)</td></tr></table>
<!-- l. 619 --><p class='indent'>   Here we have included a global phase for good measure, so that
<!-- l. 619 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> and
<!-- l. 619 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>X</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> match
exactly to the definition of those phase gates that we were using before. For a multi-qubit
Pauli string we will again adopt the shorthand of not writing the tensor product symbol
<!-- l. 619 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mo class='MathClass-bin' stretchy='false'>⊗</mo></math>. So we will for
instance write <!-- l. 619 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>ZZ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> for
the unitary <!-- l. 619 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iα</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn></mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>iα</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn><mi>Z</mi><mo class='MathClass-bin' stretchy='false'>⊗</mo><mi>Z</mi></mrow></msup></mrow></math>. Note
that replacing <!-- l. 620 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></math>
by <!-- l. 620 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>−</mo><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow></math> in
a Pauli exponential is equivalent to flipping the phase of the exponential:
<!-- l. 620 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>i𝜃</mi><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>i𝜃</mi><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow></msup></mrow></math>. Hence, in the definition
Eq. (<a href='#x9-167008r40'>7.40<!-- tex4ht:ref: eq:def-Pauli-phase  --></a>) we get <!-- l. 620 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>[</mo><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi>k</mi></mrow></msup><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>]</mo><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>∝</mo><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi>k</mi></mrow></msup><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
For the future let’s record some useful facts now that we have this
correspondence between Pauli exponentials and Pauli boxes. First, we can
                                                                     

                                                                     
represent any Pauli exponential using just a small number of standard
gates.
</p>
   <div class='newtheorem'>
<!-- l. 623 --><p class='noindent'><span class='head'>
<a id='x9-167009r9'></a>
<span class='cmbx-10x-x-109'>Proposition 7.3.9.</span>  </span> Let <!-- l. 624 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></math>
be any <!-- l. 624 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit
Pauli string. Then we can represent <!-- l. 624 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>i𝜃</mi><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow></msup></math>
as a circuit of at most <!-- l. 624 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>4</mn><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math>
gates of type <!-- l. 624 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext>CNOT</mtext></mstyle><mo class='MathClass-punc' stretchy='false'>,</mo><mi>H</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>X</mi><mo class='MathClass-open' stretchy='false'>(</mo><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> <mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-punc' stretchy='false'>,</mo><mi>X</mi><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> <mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>,
and <!-- l. 624 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mn>2</mn><mi>𝜃</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
</p>
   </div>
<!-- l. 625 --><p class='indent'>    Second, we see a Pauli exponential is Clifford iff its phase is Clifford.
</p>
   <div class='newtheorem'>
<!-- l. 627 --><p class='noindent'><span class='head'>
<a id='x9-167010r10'></a>
<span class='cmbx-10x-x-109'>Proposition 7.3.10.</span>  </span>A Pauli exponential <!-- l. 628 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
for a non-trivial <!-- l. 628 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></math>
is Clifford iff <!-- l. 628 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>α</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>k</mi><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>
for some <!-- l. 628 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>∈</mo> <mi>ℤ</mi></mrow></math>.
</p>
   </div>
<!-- l. 629 --><p class='indent'>    The condition on ‘non-trivial’ here is necessary since the trivial Pauli exponential
<!-- l. 630 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>i𝜃I</mi></mrow></msup></math>
is of course just the identity gate up to global phase for any
<!-- l. 630 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>𝜃</mi></math>.
</p>
   <h3 class='sectionHead' id='pauli-exponential-compilation'><span class='titlemark'>7.4   </span> <a id='x9-1680007.4'></a>Pauli exponential compilation</h3>
<!-- l. 632 --><p class='noindent'>Now that we know a bit about Pauli exponentials, let’s see how they help us
think about quantum circuits and compilation.
                                                                     

                                                                     
</p>
   <h4 class='subsectionHead' id='pauli-exponentials-are-a-universal-gate-set'><span class='titlemark'>7.4.1   </span> <a id='x9-1690007.4.1'></a>Pauli exponentials are a universal gate set</h4>
<!-- l. 634 --><p class='noindent'>We have already seen that <!-- l. 634 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math>
and <!-- l. 634 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>
phase gates can be represented as Pauli exponentials. This means in particular
that any single-qubit unitary can be represented as a composition of
Pauli exponentials. We know that single-qubit unitaries together with
the CNOT gate form a universal gate set, so if we can show that the
<!-- l. 635 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle class='text'><mtext>CNOT</mtext></mstyle></math> gate
can be built out of Pauli exponentials, then we know that <span class='cmti-10x-x-109'>all </span>unitaries are just
compositions of Pauli exponentials. It will in fact be easier to look at the
<!-- l. 636 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle class='text'><mtext>CZ</mtext></mstyle></math> gate. Remember
that the <!-- l. 636 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle class='text'><mtext>CNOT</mtext></mstyle></math>
is just a <!-- l. 636 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle class='text'><mtext>CZ</mtext></mstyle></math>
conjugated by Hadamards on the target qubit: </p><table class='equation-star'><tr><td>
<!-- l. 637 --><object data="svgs/CZ-as-CNOT-ZX.svg" alt="diagram of CZ-as-CNOT-ZX" class="svg-diagram"></object></td></tr></table>
<!-- l. 640 --><p class='indent'>   As a Hadamard is just a series of <!-- l. 640 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math>
and <!-- l. 640 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>
phase gates, which are Pauli exponentials, it then indeed remains to look at the
CZ.
</p>
   <div class='newtheorem'>
<!-- l. 641 --><p class='noindent'><span class='head'>
<a id='x9-169001r1'></a>
<span class='cmbx-10x-x-109'>Lemma 7.4.1.</span>  </span> The <!-- l. 642 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle class='text'><mtext>CZ</mtext></mstyle></math>
gate is a composition of Pauli exponentials: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 643 --><object data="svgs/CZ-1.svg" alt="diagram of CZ-1" class="svg-diagram"></object></td></tr></table>
   </div>
<!-- l. 646 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 648 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>For the ZX-diagram equality use Eq. (<a href='main_htmlch3.html#x5-67009r84'>3.84<!-- tex4ht:ref: eq:S-state-equality  --></a>) of Exercise <a href='main_htmlch3.html#x5-67008r15'>3.15<!-- tex4ht:ref: exer:S-state-equality  --></a>, spider
fusion <!-- l. 648 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='label' xlink:href='main_htmlch3.html#x5-580020' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'><mstyle mathvariant='bold'><mi>sp</mi></mstyle></mstyle><!-- endlabel --><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
and then the Euler decomposition <!-- l. 648 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mstyle class='label' xlink:href='main_htmlch3.html#x5-580020' xlink:type='simple' xmlns:xlink='http://www.w3.org/1999/xlink'><mstyle mathvariant='bold'><mi>eu</mi></mstyle></mstyle><!-- endlabel --><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
of the Hadamard. That this diagram is indeed the sequence of Pauli exponentials
follows because a phase gadget is just a <!-- l. 648 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>ZZ</mi></mrow></math>
Pauli exponential.                                                                         □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 650 --><p class='noindent'><span class='head'>
<a id='x9-169002r2'></a>
<span class='cmbx-10x-x-109'>Theorem 7.4.2.</span>  </span> Pauli exponentials form a universal gate set. Or in other
words, any <!-- l. 651 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit
unitary can be written as a composition of Pauli exponentials.
</p>
   </div>
<!-- l. 652 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 654 --><p class='indent'>   <span class='head'>
                                                                     

                                                                     
<span class='cmti-10x-x-109'>Proof.</span>
</span><!-- l. 654 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math>
and
<!-- l. 654 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>
phase gates are Pauli exponentials (see Examples <a href='#x9-166002r4'>7.3.4<!-- tex4ht:ref: ex:Z-exponential  --></a> and <a href='#x9-166004r5'>7.3.5<!-- tex4ht:ref: ex:X-exponential  --></a>). These
gates generate all single-qubit unitaries. Combining this with the CZ gate
gives  a  universal  gate  set,  and  this  CZ  can  also  be  written  as  a  Pauli
exponential by the previous lemma.                                                  □
</p>
   </div>
   <div class='newtheorem'>
<!-- l. 656 --><p class='noindent'><span class='head'>
<a id='x9-169003r3'></a>
<span class='cmbx-10x-x-109'>Remark* 7.4.3.</span>  </span>There is a more ‘abstract nonsense’ argument for why you
should be able to construct any unitary by composing Pauli exponentials.
The <!-- l. 657 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit
unitaries form a <span class='cmbx-10x-x-109'>Lie group</span>, a group that is also a differentiable manifold
in an appropriate way. When we have a continuous family of unitaries we
can take its derivative to get an associated matrix, which in this case will
be a self-adjoint one. This is in fact the matrix exponentiation we have been
looking at: given a self-adjoint matrix <!-- l. 657 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math>,
we get a family of unitaries via <!-- l. 657 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>itH</mi></mrow></msup></math>,
and taking the derivative of the function <!-- l. 657 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>t</mi><mo class='MathClass-rel' stretchy='false'>↦</mo><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>itH</mi></mrow></msup></mrow></math>
gives you back <!-- l. 657 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math>
(or well, actually <!-- l. 657 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>iH</mi></mrow></math>,
but this is just the physicist convention; mathematicians please don’t get
angry at us). All of this is to say that the self-adjoint matrices form the
<span class='cmbx-10x-x-109'>Lie  algebra </span>of  the  group  of  unitaries.  Now,  there  is  a  result  (see  the
References of the chapter) that says that if we have a basis of the Lie algebra
<!-- l. 657 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>H</mi></mrow><mrow><mi>k</mi></mrow></msub></mrow></math>,
that then the associated families of Lie group elements <!-- l. 657 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></msup><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mi>k</mi></mrow></msub></mrow></msup></mrow></math>
<span class='cmti-10x-x-109'>generate </span>the entire (connected part of the) Lie group, meaning that we can
write any Lie group element as a finite combination of elements from these
families. It just so happens that the Paulis form a basis of the <!-- l. 657 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit
self-adjoint matrices, and hence the Pauli exponentials generate the <!-- l. 657 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit
unitaries!
</p>
   </div>
<!-- l. 658 --><p class='indent'>
                                                                     

                                                                     
</p>
   <h4 class='subsectionHead' id='compiling-to-pauli-exponentials'><span class='titlemark'>7.4.2   </span> <a id='x9-1700007.4.2'></a>Compiling to Pauli exponentials</h4>
<!-- l. 660 --><p class='noindent'>Theorem <a href='#x9-169002r2'>7.4.2<!-- tex4ht:ref: thm:Pauli-exp-universal  --></a> gives one way to write a quantum circuit as a series of Pauli
exponentials, but if we are interested in doing this with a <span class='cmti-10x-x-109'>small </span>number of these, it
doesn’t do a very good job. There is in fact a more interesting way to transform a
circuit into Pauli exponentials, which also has practical relevance in quantum
compilation (see the References for this chapter). To do this we need to use what
we learned in the previous chapter. There we saw that pushing a Clifford unitary
<!-- l. 662 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math> through a
Pauli <!-- l. 662 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></math> gives you
another Pauli: <!-- l. 662 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mi>U</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>U</mi><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow></math>
for some <!-- l. 662 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></math>.
Now, in Eq. (<a href='#x9-165003r33'>7.33<!-- tex4ht:ref: eq:exp-conjugation  --></a>) we saw that conjugating a matrix exponential is the same
thing as exponentiating the conjugated matrix. This can be recast as a way to
commute a unitary through a matrix exponential: </p><table class='equation'><tr><td>
<!-- l. 664 --><p class='indent'>
</p><!-- l. 664 --><object id='x9-170001r41' data="svgs/eqrefeq-exp-conjugation.svg" alt="diagram of eqrefeq-exp-conjugation" class="svg-diagram"></object></td><td class='eq-no'>(7.41)</td></tr></table>
<!-- l. 667 --><p class='indent'>   So if our matrix <!-- l. 667 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>
is actually a Pauli <!-- l. 667 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></math>,
and our unitary <!-- l. 667 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
is a Clifford, then we can push the Clifford through the Pauli exponential to get
another Pauli exponential: </p><table class='equation'><tr><td>
<!-- l. 668 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 668 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                     <mstyle class='label' id='x9-170002r42'></mstyle><!-- endlabel --><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>i𝜃</mi><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow></msup><mi>U</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>U</mi><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>i𝜃</mi><msup><mrow><mi>U</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mi>U</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>U</mi><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>i𝜃</mi><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow></msup>
</mrow></math></td><td class='eq-no'>(7.42)</td></tr></table>
   <div class='newtheorem'>
<!-- l. 671 --><p class='noindent'><span class='head'>
<a id='x9-170003r4'></a>
<span class='cmbx-10x-x-109'>Example 7.4.4.</span>  </span>Suppose our Pauli exponential is just
<!-- l. 672 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>i𝜃</mi><msub><mrow><mi>Z</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></msup></math> and
that we want to push a CNOT through it. In terms of ZX-diagrams this becomes:
</p><table class='equation-star'><tr><td>
<!-- l. 673 --><object data="svgs/phase-gadget-push-CNOT.svg" alt="diagram of phase-gadget-push-CNOT" class="svg-diagram"></object></td></tr></table>
   </div>
<!-- l. 676 --><p class='indent'>    How does Eq. (<a href='#x9-170002r42'>7.42<!-- tex4ht:ref: eq:push-Clifford-Pauli-exp  --></a>) help us? Well, it helps us if we put on a
different pair of glasses and view our circuit not as being given by
<!-- l. 678 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math> and
<!-- l. 678 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math> phase
gates and CZ/CNOT gates, but instead view it as consisting of <span class='cmti-10x-x-109'>Clifford </span>gates and
<span class='cmti-10x-x-109'>non-Clifford </span>gates. With this perspective we consider CZ, CNOT, Hadamard,
<!-- l. 678 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math> and
<!-- l. 678 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>X</mi><mo class='MathClass-open' stretchy='false'>(</mo><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> <mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> gates
to all be of the same sort, namely Clifford, while the other class of gates contains
any <!-- l. 678 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> and
<!-- l. 678 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>X</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> where
<!-- l. 678 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>α</mi></math> is not a
multiple of <!-- l. 678 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>.
These non-Clifford phase gates we can then view as Pauli exponentials (which are
only acting on a single qubit). So wearing these glasses we see the circuit as a
series of Clifford gates and Pauli exponentials, where each Pauli exponential
                                                                     

                                                                     
corresponds to a non-Clifford phase gate: </p><table class='equation'><tr><td>
<!-- l. 681 --><p class='indent'>
</p><!-- l. 681 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                <mstyle class='label' id='x9-170004r43'></mstyle><!-- endlabel --><mi>U</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>U</mi></mrow><mrow><mn>1</mn></mrow></msub><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><msub><mrow><mi>𝜃</mi></mrow><mrow><mn>1</mn></mrow></msub><msup><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msup>
           </mrow></msup><msub><mrow><mi>U</mi></mrow><mrow><mn>2</mn></mrow></msub><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><msub><mrow><mi>𝜃</mi></mrow><mrow><mn>2</mn></mrow></msub><msup><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>2</mn></mrow></msup>
</mrow></msup><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>U</mi></mrow><mrow><mi>k</mi></mrow></msub><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><msub><mrow><mi>𝜃</mi></mrow><mrow><mi>k</mi></mrow></msub><msup><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>k</mi></mrow></msup>
         </mrow></msup><msub><mrow><mi>U</mi></mrow><mrow><mi>k</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td><td class='eq-no'>(7.43)</td></tr></table>
<!-- l. 684 --><p class='indent'>   Here each of the Clifford unitaries
<!-- l. 684 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>U</mi></mrow><mrow><mi>j</mi></mrow></msub></math>
can consist of multiple basic Clifford gates like CNOT,
<!-- l. 684 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>S</mi></math> and
<!-- l. 684 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math>.
Now let’s pick the first non-Clifford Pauli exponential in this circuit
<!-- l. 685 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><msub><mrow><mi>𝜃</mi></mrow><mrow><mn>1</mn></mrow></msub><msup><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msup></mrow></msup></math> and push
it through <!-- l. 685 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>U</mi></mrow><mrow><mn>1</mn></mrow></msub></math>
using Eq. (<a href='#x9-170002r42'>7.42<!-- tex4ht:ref: eq:push-Clifford-Pauli-exp  --></a>) to get: </p><table class='equation-star'><tr><td>
<!-- l. 686 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                  <msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><msub><mrow><mi>𝜃</mi></mrow><mrow><mn>1</mn></mrow></msub><msup><mrow><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msup>
           </mrow></msup><msub><mrow><mi>U</mi></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mi>U</mi></mrow><mrow><mn>2</mn></mrow></msub><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><msub><mrow><mi>𝜃</mi></mrow><mrow><mn>2</mn></mrow></msub><msup><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>2</mn></mrow></msup>
           </mrow></msup><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>U</mi></mrow><mrow><mi>k</mi></mrow></msub><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><msub><mrow><mi>𝜃</mi></mrow><mrow><mi>k</mi></mrow></msub><msup><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>k</mi></mrow></msup>
         </mrow></msup><msub><mrow><mi>U</mi></mrow><mrow><mi>k</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td></tr></table>
<!-- l. 689 --><p class='indent'>   Here <!-- l. 689 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msubsup><mrow><mi>U</mi></mrow><mrow><mn>1</mn></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msubsup><msup><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msup><mi>U</mi></mrow></math>. We
then push <!-- l. 689 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><msub><mrow><mi>𝜃</mi></mrow><mrow><mn>2</mn></mrow></msub><msup><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>2</mn></mrow></msup></mrow></msup></math>
through both <!-- l. 689 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>U</mi></mrow><mrow><mn>2</mn></mrow></msub></math>
and <!-- l. 689 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>U</mi></mrow><mrow><mn>1</mn></mrow></msub></math>
and so on, until finally we get the circuit: </p><table class='equation'><tr><td>
<!-- l. 690 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 690 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                   <mstyle class='label' id='x9-170005r44'></mstyle><!-- endlabel --><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><msub><mrow><mi>𝜃</mi></mrow><mrow><mn>1</mn></mrow></msub><msup><mrow><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msup>
           </mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><msub><mrow><mi>𝜃</mi></mrow><mrow><mn>2</mn></mrow></msub><msup><mrow><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>2</mn></mrow></msup>
</mrow></msup><mo class='MathClass-rel' stretchy='false'>⋯</mo><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><msub><mrow><mi>𝜃</mi></mrow><mrow><mi>k</mi></mrow></msub><msup><mrow><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>k</mi></mrow></msup>
         </mrow></msup><msub><mrow><mi>U</mi></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mi>U</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>U</mi></mrow><mrow><mi>k</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td><td class='eq-no'>(7.44)</td></tr></table>
<!-- l. 693 --><p class='indent'>   The circuit now has a very different structure! We see that each non-Clifford
phase gate in the original circuit, which we saw as single-qubit Pauli
exponentials, is transformed into some other Pauli exponential, which can now
act on any number of qubits. All the Clifford gates of the original circuit are still
present here, but are now pushed all the way to the end. In Chapter <a href='main_htmlch5.html#clifford-circuits-and-diagrams'>5<!-- tex4ht:ref: ch:clifford  --></a> we saw
how to optimise Clifford circuits, and in particular that those circuits can
be reduced to a normal form whose maximal size only depends on the
number of qubits (Proposition <a href='main_htmlch5.html#x7-118003r12'>5.3.12<!-- tex4ht:ref: prop:Clifford-number-of-gates  --></a>). This structure is useful for a
variety of reasons that we’ll explore in this chapter, so let’s give a name to
it.
</p>
   <div class='newtheorem'>
<!-- l. 696 --><p class='noindent'><span class='head'>
<a id='x9-170006r5'></a>
<span class='cmbx-10x-x-109'>Definition 7.4.5.</span>  </span> We say a circuit is in <span class='cmbx-10x-x-109'>Pauli exponential form </span>when
it consists of a series of Pauli exponentials followed by a Clifford circuit.
</p>
   </div>
<!-- l. 698 --><p class='indent'>    We’ll often shorten this to PE form or say it is a PE circuit.
</p>
   <div class='newtheorem'>
<!-- l. 700 --><p class='noindent'><span class='head'>
<a id='x9-170007r6'></a>
<span class='cmbx-10x-x-109'>Proposition 7.4.6.</span>  </span>   A   circuit   consisting   of   Clifford   gates   and
<!-- l. 701 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
non-Clifford                                                                            phase
gates can be efficiently transformed into a Pauli exponential form containing
<!-- l. 701 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
Pauli exponentials.
                                                                     

                                                                     
</p>
   </div>
<!-- l. 702 --><p class='indent'>    As a first result, this form gives us a bound on the number of gates we need
to write down an arbitrary circuit based on the number of non-Clifford gates it
contains.
</p>
   <div class='newtheorem'>
<!-- l. 704 --><p class='noindent'><span class='head'>
<a id='x9-170008r7'></a>
<span class='cmbx-10x-x-109'>Proposition 7.4.7.</span>  </span>Let <!-- l. 705 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math>
be an <!-- l. 705 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit
circuit consisting of Clifford gates and <!-- l. 705 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
non-Clifford phase gates. Then it can be written in the <!-- l. 706 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>{</mo><mstyle class='text'><mtext>CNOT</mtext></mstyle><mo class='MathClass-punc' stretchy='false'>,</mo><mi>H</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>S</mi><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mi>S</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>†</mo></mrow></msup><mo class='MathClass-punc' stretchy='false'>,</mo><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>}</mo></mrow></math>
gate set using at most <!-- l. 706 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi><mo class='MathClass-open' stretchy='false'>(</mo><mn>4</mn><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>4</mn><mi>n</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi mathvariant='italic'>kn</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>n</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
gates.
</p>
   </div>
<!-- l. 707 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 709 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>By Proposition <a href='#x9-170007r6'>7.4.6<!-- tex4ht:ref: prop:circ-to-Pauli-exps  --></a> our circuit has <!-- l. 709 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
Pauli exponentials, each of which requires at most <!-- l. 709 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>4</mn><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math>
gates  to  write  down  in  our  gate  set  by  Proposition <a href='#x9-167009r9'>7.3.9<!-- tex4ht:ref: prop:Pauli-exp-num-gates  --></a>  for  a  total  of
<!-- l. 709 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi><mo class='MathClass-open' stretchy='false'>(</mo><mn>4</mn><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
The final Clifford circuit requires an additional <!-- l. 709 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>4</mn><mi>n</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>−</mo> <mn>1</mn></mrow></math>
gates (Proposition <a href='main_htmlch5.html#x7-118003r12'>5.3.12<!-- tex4ht:ref: prop:Clifford-number-of-gates  --></a>).                                                              □
</p>
   </div>
<!-- l. 711 --><p class='indent'>   Note that in most useful quantum computations (those that do
calculations that we can’t efficiently do classically) we will have
<!-- l. 711 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>≫</mo> <mi>n</mi></mrow></math>,
and hence the number of gates in Pauli exponential form scales as
<!-- l. 711 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi mathvariant='italic'>kn</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>. Let’s
zoom out a bit. Why did it make sense to view our circuit as consisting of
Clifford and non-Clifford gates, instead of using a more fine-grained difference
between gates? In Chapter <a href='main_htmlch5.html#clifford-circuits-and-diagrams'>5<!-- tex4ht:ref: ch:clifford  --></a> we saw that computation involving just Clifford
gates is efficiently classically simulable. The power of computation must then
                                                                     

                                                                     
necessarily come from the inclusion of non-Clifford gates. We can then interpret a
circuit in Pauli exponential form as first doing the ‘actual’ quantum computation
using the Pauli exponentials, which are all non-Clifford, and then doing some
final Clifford operations to ‘post-process’ the data in the right way. This analogy
of Clifford operations being a type of post-processing becomes explicit
when we are working with quantum error correcting codes. As we saw in
Chapter <a href='main_htmlch6.html#stabiliser-theory'>6<!-- tex4ht:ref: ch:stabiliser  --></a>, Clifford operations can often be done natively in a quantum
error correcting code and so are ‘free’ operations. This is in contrast to
non-Clifford operations which often require more complicated techniques to do
fault-tolerantly.
</p>
   <h4 class='subsectionHead' id='phase-folding'><span class='titlemark'>7.4.3   </span> <a id='x9-1710007.4.3'></a>Phase folding</h4>
<!-- l. 716 --><p class='noindent'>Okay, so we can limit the number of Pauli exponentials we need to
write an arbitrary circuit. But we can do even better! Remember
from Proposition <a href='#x9-165004r2'>7.3.2<!-- tex4ht:ref: prop:exp-matrix-sum  --></a> that if we have two commuting matrices
<!-- l. 717 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math> and
<!-- l. 717 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>B</mi></math> that
then <!-- l. 717 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>e</mi></mrow><mrow><mi>A</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mi>B</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi>A</mi></mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mi>B</mi></mrow></msup></mrow></math>.
It will be helpful to think of this going in the other direction as well: if we have
commuting matrices, then we can combine adjacent matrix exponentials
<!-- l. 717 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi>A</mi></mrow></msup></math> and
<!-- l. 717 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi>B</mi></mrow></msup></math>
into a single matrix exponential. In particular, if we have a
circuit in PE form then there will be many Pauli exponentials
<!-- l. 718 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><msub><mrow><mi>𝜃</mi></mrow><mrow><mi>j</mi></mrow></msub><msup><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>k</mi></mrow></msup></mrow></msup></math>
in a row. When we then have two Pauli exponentials
<!-- l. 718 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><msub><mrow><mi>𝜃</mi></mrow><mrow><mi>k</mi></mrow></msub><msup><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>k</mi></mrow></msup></mrow></msup></math> and
<!-- l. 718 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><msub><mrow><mi>𝜃</mi></mrow><mrow><mi>l</mi></mrow></msub><msup><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>l</mi></mrow></msup></mrow></msup></math> right next to each
other such that <!-- l. 718 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>k</mi></mrow></msup></math>
and <!-- l. 718 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>l</mi></mrow></msup></math>
commute we can combine them into a single exponential. This is especially helpful if
<!-- l. 718 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>k</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo><msup><mrow> <mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>l</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo><mo class='MathClass-punc' stretchy='false'>:</mo> <mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow></math>.
Then we get: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 719 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
               <msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><msub><mrow><mi>𝜃</mi></mrow><mrow><mi>k</mi></mrow></msub><msup><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>k</mi></mrow></msup>
         </mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><msub><mrow><mi>𝜃</mi></mrow><mrow><mi>l</mi></mrow></msub><msup><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>l</mi></mrow></msup>
        </mrow></msup><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><msub><mrow><mi>𝜃</mi></mrow><mrow><mi>k</mi></mrow></msub><msup><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>k</mi></mrow></msup><mo class='MathClass-bin' stretchy='false'>+</mo><mi>i</mi><msub><mrow><mi>𝜃</mi></mrow><mrow><mi>l</mi></mrow></msub><msup><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>l</mi></mrow></msup>
                   </mrow></msup><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>𝜃</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-bin' stretchy='false'>+</mo><msub><mrow><mi>𝜃</mi></mrow><mrow><mi>l</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow></msup>
</mrow></math></td></tr></table>
<!-- l. 721 --><p class='indent'>   With the notation of Eq. (<a href='#x9-167008r40'>7.40<!-- tex4ht:ref: eq:def-Pauli-phase  --></a>) we can write this as
<!-- l. 721 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-open' stretchy='false'>(</mo><mi>β</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>β</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
Using Pauli boxes we can write this as: </p><table class='equation'><tr><td>
<!-- l. 722 --><p class='indent'>
</p><!-- l. 722 --><object id='x9-171001r45' data="svgs/Pauli-exp-combine.svg" alt="diagram of Pauli-exp-combine" class="svg-diagram"></object></td><td class='eq-no'>(7.45)</td></tr></table>
<!-- l. 725 --><p class='indent'>   However, the Pauli exponentials we want to combine into one
might not be next to each other, as there might be other exponentials
in the way. But remember also from Proposition <a href='#x9-165004r2'>7.3.2<!-- tex4ht:ref: prop:exp-matrix-sum  --></a> that if
<!-- l. 726 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math> and
<!-- l. 726 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>B</mi></math> commute,
that then <!-- l. 726 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi>A</mi></mrow></msup></math>
and <!-- l. 726 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi>B</mi></mrow></msup></math>
will commute as well. So if two Pauli strings commute, then the associated
exponentiated Paulis will commute as well: </p><table class='equation-star'><tr><td>
<!-- l. 727 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
              <mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mspace class='nbsp' width='0.33em'></mspace><mspace class='thickpace' width='0.28em'></mspace><mo class='MathClass-rel' stretchy='false'>⟺</mo><mspace class='thickpace' width='0.28em'></mspace><mspace class='nbsp' width='0.33em'></mspace><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo><mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-open' stretchy='false'>(</mo><mi>β</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='true'><mrow><mi>Q</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-open' stretchy='false'>(</mo><mi>β</mi><mo class='MathClass-close' stretchy='false'>)</mo><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo>
</mrow></math></td></tr></table>
                                                                     

                                                                     
<!-- l. 728 --><p class='indent'>   So using this we can move exponentials out of the way in order to combine
the ones we want.
</p>
   <div class='newtheorem'>
<!-- l. 729 --><p class='noindent'><span class='head'>
<a id='x9-171002r8'></a>
<span class='cmbx-10x-x-109'>Example 7.4.8.</span>  </span>Consider the following circuit:
</p>
<div class='center'>
<!-- l. 732 --><p class='noindent'>
</p><!-- l. 733 --><p class='noindent'><object data="svgs/Pauli-exp-circuit-example.svg" alt="diagram of Pauli-exp-circuit-example" class="svg-diagram"></object> </p></div>
<!-- l. 736 --><p class='indent'>   <!-- l. 736 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>XX</mi></mrow></math> commutes with
<!-- l. 736 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>ZZ</mi></mrow></math>, and hence we
can combine the <!-- l. 736 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>ZZ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
and <!-- l. 736 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>ZZ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>γ</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>, by
moving the <!-- l. 736 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>XX</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>β</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
out of the way. However, we can’t combine these with
<!-- l. 736 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>ZZ</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>ϕ</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> as there
is an <!-- l. 736 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>X</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mi>δ</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
in the way that does not commute with the
<!-- l. 736 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>ZZ</mi></mrow></math> phases (in general of
course: if <!-- l. 736 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>δ</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math> then we can
ignore that gate, and if <!-- l. 736 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>δ</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>π</mi></mrow></math>,
then it is a Pauli <!-- l. 736 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>X</mi></math>
that we can push through the Pauli exponentials).
</p>
   </div>
<!-- l. 737 --><p class='indent'>    All of this suggests the following algorithm for reducing the number of
Pauli exponentials needed to write a circuit, which we will call <span class='cmbx-10x-x-109'>phase
folding</span>.
     </p><dl class='enumerate'><dt class='enumerate'>
  1.. </dt><dd class='enumerate'>
     <!-- l. 740 --><p class='noindent'>Start with a circuit in PE form (Definition <a href='#x9-170006r5'>7.4.5<!-- tex4ht:ref: def:PE-form  --></a>)
     </p></dd><dt class='enumerate'>
  2.. </dt><dd class='enumerate'>
     <!-- l. 741 --><p class='noindent'>Consider the first (leftmost) Pauli exponential <!-- l. 741 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
                                                                     

                                                                     
     </p></dd><dt class='enumerate'>
  3.. </dt><dd class='enumerate'>
     <!-- l. 742 --><p class='noindent'>If there is another <!-- l. 742 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-open' stretchy='false'>(</mo><mi>β</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
     in the circuit, look at all the Pauli exponentials in between <!-- l. 742 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
     and <!-- l. 742 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-open' stretchy='false'>(</mo><mi>β</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
     If <!-- l. 742 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></math>
     commutes with all of these, then combine <!-- l. 742 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
     and <!-- l. 742 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-open' stretchy='false'>(</mo><mi>β</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
     into one <!-- l. 742 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>β</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
     Do this check and combination for all Pauli exponentials of <!-- l. 742 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></math>
     in the circuit.
     </p></dd><dt class='enumerate'>
  4.. </dt><dd class='enumerate'>
     <!-- l. 743 --><p class='noindent'>Repeat the procedure for the next Pauli exponential in the circuit.
     </p></dd><dt class='enumerate'>
  5.. </dt><dd class='enumerate'>
     <!-- l. 744 --><p class='noindent'>Check  if  any  of  the  resulting  Pauli  exponentials  is  Clifford.  If  so,
     push  these  Clifford  ones  past  the  Pauli  exponentials  as  described
     in  Section <a href='#compiling-to-pauli-exponentials'>7.4.2<!-- tex4ht:ref: sec:Pauli-exp-compilation  --></a>,  resulting  in  a  new  circuit  in  PE  form.  Repeat
     the algorithm. If no Clifford Pauli exponentials were created in the
     previous steps, we are done. </p></dd></dl>
<!-- l. 746 --><p class='noindent'>
</p>
   <h3 class='sectionHead' id='hamiltonian-simulation'><span class='titlemark'>7.5   </span> <a id='x9-1720007.5'></a>Hamiltonian simulation</h3>
<!-- l. 747 --><p class='noindent'>Back in Section <a href='main_htmlch2.html#unitary-evolution'>2.2.3<!-- tex4ht:ref: sec:unitaries  --></a>, we mentioned briefly that the time evolution of a quantum
system comes from taking the matrix exponent of a certain operator, called the
Hamiltonian, which encodes all of the physical interactions going on. Now,
suppose a physicist or an engineer hands us a Hamiltonian, and asks us to
<span class='cmti-10x-x-109'>simulate </span>the behaviour of a quantum system it represents. Is there a way we can
do this on a quantum computer? That is, if we start in a known quantum state
<!-- l. 748 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>, can we
use a quantum computer to efficiently transform this state into it’s time-evolved state
<!-- l. 748 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>itH</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>, then
perform some measurements to learn something about it? It turns out, if we just want to
approximate <!-- l. 749 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>itH</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>,
the answer is yes! One way to do this is to employ the Suzuki-Trotter method, a.k.a.
<span class='cmbx-10x-x-109'>Trotterization</span>. In our case, this will let us synthesise a circuit the approximates
<!-- l. 749 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>itH</mi></mrow></msup></math> using Pauli gadgets.
<!-- l. 750 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math> is a self-adjoint
                                                                     

                                                                     
operator on <!-- l. 750 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
qubits, so a generic <!-- l. 750 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math>
could take an exponential amount of data to describe. Of course, in that case, we
don’t have any hope of simulating it efficiently, because even reading
<!-- l. 750 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math> will
take exponential time. Thankfully, lots of useful, physically meaningful
<!-- l. 750 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math>’s can
be written as a linear combination of Pauli strings: </p><table class='equation-star'><tr><td>
<!-- l. 751 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                        <mi>H</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><munderover accent='false' accentunder='false'><mrow><mo>∑</mo>
  </mrow><mrow><mi>j</mi><mo class='MathClass-rel' stretchy='false'>=</mo><mn>1</mn></mrow><mrow><mi>m</mi></mrow></munderover><msub><mrow><mi>α</mi></mrow><mrow>
<mi>m</mi></mrow></msub><msub><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>j</mi></mrow></msub>
</mrow></math></td></tr></table>
<!-- l. 752 --><p class='indent'>   where <!-- l. 752 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>m</mi></math> is
polynomial in <!-- l. 752 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>.
Then, if all the <!-- l. 752 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>j</mi></mrow></msub></math>
commute, we’re laughing because thanks to Proposition <a href='#x9-165004r2'>7.3.2<!-- tex4ht:ref: prop:exp-matrix-sum  --></a>, then
<!-- l. 752 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>U</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>itH</mi></mrow></msup></mrow></math> splits
up as a bunch of Pauli gadgets: </p><table class='equation-star'><tr><td>
<!-- l. 753 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
         <msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>itH</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi>i</mi><mfrac><mrow><msub><mrow><mi>α</mi></mrow><mrow><mi>m</mi></mrow></msub><mi>t</mi></mrow>
  <mrow><mn>2</mn></mrow></mfrac><msub><mrow>   <mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>m</mi></mrow></msub><mo class='MathClass-bin' stretchy='false'>+</mo><mo>…</mo><mo class='MathClass-bin' stretchy='false'>+</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mi>i</mi><mfrac><mrow><msub><mrow><mi>α</mi></mrow><mrow><mn>1</mn></mrow></msub><mi>t</mi></mrow>
 <mrow><mn>2</mn></mrow></mfrac><msub><mrow>  <mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub>
                                         </mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi>i</mi><mfrac><mrow><mi>t</mi><msub><mrow><mi>α</mi></mrow><mrow><mi>m</mi></mrow></msub></mrow>
  <mrow><mn>2</mn></mrow></mfrac><msub><mrow>   <mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>m</mi></mrow></msub>
               </mrow></msup><mo>…</mo><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi>i</mi><mfrac><mrow><mi>t</mi><msub><mrow><mi>α</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow>
  <mrow><mn>2</mn></mrow></mfrac><msub><mrow>  <mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mn>1</mn></mrow></msub>
                </mrow></msup>
</mrow></math></td></tr></table>
<!-- l. 757 --><p class='indent'>   i.e. </p><table class='equation'><tr><td>
<!-- l. 758 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 758 --><object id='x9-172001r46' data="svgs/eq-time-evo.svg" alt="diagram of eq:time-evo" class="svg-diagram"></object></td><td class='eq-no'>(7.46)</td></tr></table>
<!-- l. 761 --><p class='indent'>   We already know how to synthesise Pauli gadgets, so
we can build a nice Clifford+phase circuit, parametrised by
<!-- l. 761 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>t</mi></math>, that will
perform time evolution for a generic input state. Life is good. Unfortunately, if the Pauli
strings in <!-- l. 762 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math>
<span class='cmti-10x-x-109'>don’t </span>commute, we can’t use Proposition <a href='#x9-165004r2'>7.3.2<!-- tex4ht:ref: prop:exp-matrix-sum  --></a> to turn a sum in the exponent into a
product of matrix exponents. Nevertheless, we can power on and try to decompose
<!-- l. 762 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math> as a
product of Pauli exponentials, but we might introduce some errors along the way.
We’ll start with some Hamiltonian that is the sum of just two other Hamiltonians:
<!-- l. 763 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>H</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></math>. In
order to decompose its exponential into a composition of exponentials, we would
like it to be the case that: </p><table class='equation'><tr><td>
<!-- l. 764 --><p class='indent'>
</p><!-- l. 764 --><object id='x9-172002r47' data="svgs/eq-trotter.svg" alt="diagram of eq:trotter" class="svg-diagram"></object></td><td class='eq-no'>(7.47)</td></tr></table>
<!-- l. 767 --><p class='indent'>   for some <!-- l. 767 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>𝜖</mi></math>.
Note that here we introduced some new notation for <span class='cmbx-10x-x-109'>approximate rewriting </span>by writing
an <!-- l. 767 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>𝜖</mi></math> on
top of the <!-- l. 767 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-rel' stretchy='false'>≈</mo></mrow></math>
sign. By definition, this means: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 768 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                   <mo class='MathClass-rel' stretchy='false'>∥</mo><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>+</mo><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub>
          </mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub>
</mrow></msup><mo class='MathClass-rel' stretchy='false'>∥</mo><mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-rel' stretchy='false'>≤</mo><mspace class='nbsp' width='0.33em'></mspace><mi>𝜖</mi>
</mrow></math></td></tr></table>
<!-- l. 771 --><p class='indent'>   It turns out that the left-hand side is bounded by
<!-- l. 771 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup><mi>κ</mi></mrow></math> for
some <!-- l. 771 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>κ</mi> <mo class='MathClass-rel' stretchy='false'>&gt;</mo> <mn>0</mn></mrow></math>,
and hence to make this smaller than epsilon we can choose
<!-- l. 771 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>t</mi></math> small enough such that
<!-- l. 771 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup><mi>κ</mi> <mo class='MathClass-rel' stretchy='false'>≤</mo> <mi>𝜖</mi></mrow></math>. To see this is true, and
to find this number <!-- l. 772 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>κ</mi></math>,
we will need to introduce some new tools, and to understand these tools, we will
first do a warm-up exercise. We will prove that </p><table class='equation-star'><tr><td>
<!-- l. 773 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                        <mo class='MathClass-rel' stretchy='false'>∥</mo><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iA</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iB</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>∥</mo><mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-rel' stretchy='false'>≤</mo><mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-rel' stretchy='false'>∥</mo><mi>A</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>B</mi><mo class='MathClass-rel' stretchy='false'>∥</mo>
</mrow></math></td></tr></table>
<!-- l. 776 --><p class='indent'>   for <!-- l. 776 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math> and
<!-- l. 776 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>B</mi></math> self-adjoint. Then in
particular <!-- l. 776 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>∥</mo><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></msup><mo class='MathClass-rel' stretchy='false'>∥</mo><mo class='MathClass-rel' stretchy='false'>≤</mo><mo class='MathClass-rel' stretchy='false'>∥</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>∥</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mi>t</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-rel' stretchy='false'>∥</mo><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>−</mo> <msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>∥</mo></mrow></math>, so that
in this case the ‘<!-- l. 776 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>κ</mi></math>’
is <!-- l. 776 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>∥</mo><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>−</mo> <msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>∥</mo></mrow></math>. Define the
matrix-valued function <!-- l. 777 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>itA</mi></mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-bin' stretchy='false'>−</mo><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi>B</mi></mrow></msup></mrow></math>.
Then note that <!-- l. 777 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iB</mi></mrow></msup></mrow></math> and
<!-- l. 777 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iA</mi></mrow></msup></mrow></math>. We hence want to
calculate the expression <!-- l. 777 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>∥</mo><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>∥</mo></mrow></math>.
Now, for some of you this might bring back very old memories, but we will need to use
the <span class='cmbx-10x-x-109'>Fundamental Theorem of Calculus </span>to help us simplify this. Remember that this
says that <!-- l. 777 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>y</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo><msubsup><mrow> <mo>∫</mo>
 <!-- nolimits --><!-- nolimits --></mrow><mrow><mi>y</mi></mrow><mrow><mi>x</mi></mrow></msubsup><msup><mrow><mi>f</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-open' stretchy='false'>(</mo><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi mathvariant='italic'>dt</mi></mrow></math>
where <!-- l. 777 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>f</mi></mrow><mrow><mi>′</mi></mrow></msup></math> is
the derivative of the function. This also works for matrix-valued functions, so
that we get
                                                                     

                                                                     
<!-- tex4ht:inline --></p><!-- l. 778 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
      <mo class='MathClass-rel' stretchy='false'>∥</mo><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iA</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iB</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>∥</mo><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-rel' stretchy='false'>∥</mo><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>∥</mo><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace> <mrow><mo fence='true' form='prefix'>∥</mo><mrow><msubsup><mrow><mo>∫
 <!-- nolimits --></mo><!-- nolimits --></mrow><mrow><mn>0</mn></mrow><mrow><mn>1</mn></mrow></msubsup><msup><mrow><mi>f</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-open' stretchy='false'>(</mo><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi mathvariant='italic'>dt</mi></mrow><mo fence='true' form='postfix'>∥</mo></mrow><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>≤</mo><mspace class='nbsp' width='0.33em'></mspace><msubsup><mrow><mo>∫
 <!-- nolimits --></mo><!-- nolimits --></mrow><mrow><mn>0</mn></mrow><mrow><mn>1</mn></mrow></msubsup><mo class='MathClass-rel' stretchy='false'>∥</mo><msup><mrow><mi>f</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-open' stretchy='false'>(</mo><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>∥</mo><mi mathvariant='italic'>dt</mi><mo class='MathClass-punc' stretchy='false'>,</mo>
</mrow></math>
<!-- l. 778 --><p class='nopar'> where in the last step we used a version of the triangle inequality for
integrals (which is after all just a limit of sums). So let’s calculate what
<!-- l. 780 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>f</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-open' stretchy='false'>(</mo><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> is, which we will do
using the product rule <!-- l. 780 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>f</mi></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mi>f</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi>′</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msubsup><mrow><mi>f</mi></mrow><mrow><mn>1</mn></mrow><mrow><mi>′</mi></mrow></msubsup><msub><mrow><mi>f</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>f</mi></mrow><mrow><mn>1</mn></mrow></msub><msubsup><mrow><mi>f</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>′</mi></mrow></msubsup></mrow></math>:
</p><table class='equation-star'><tr><td>
<!-- l. 781 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
    <msup><mrow><mi>f</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-open' stretchy='false'>(</mo><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-open' stretchy='false'>(</mo><mi mathvariant='italic'>iA</mi><mo class='MathClass-close' stretchy='false'>)</mo><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>itA</mi></mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-bin' stretchy='false'>−</mo><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi>B</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>itA</mi></mrow></msup><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>iB</mi><mo class='MathClass-close' stretchy='false'>)</mo><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-bin' stretchy='false'>−</mo><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi>B</mi></mrow></msup><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mi>i</mi><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>itA</mi></mrow></msup><mo class='MathClass-open' stretchy='false'>(</mo><mi>A</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>B</mi><mo class='MathClass-close' stretchy='false'>)</mo><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-bin' stretchy='false'>−</mo><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi>B</mi></mrow></msup><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td></tr></table>
<!-- l. 784 --><p class='indent'>   Here in the last step we commuted
<!-- l. 784 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math> past
<!-- l. 784 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>itA</mi></mrow></msup></math> and grouped
the terms together. Now, also recall that the norm is unitarily invariant, meaning that
<!-- l. 784 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>∥</mo><mi mathvariant='italic'>UA</mi><mo class='MathClass-rel' stretchy='false'>∥</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>∥</mo><mi>A</mi><mo class='MathClass-rel' stretchy='false'>∥</mo></mrow></math> for any unitary
<!-- l. 784 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>U</mi></math> and arbitrary
matrix <!-- l. 784 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>.
As both <!-- l. 784 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>itA</mi></mrow></msup></math>
and <!-- l. 784 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-bin' stretchy='false'>−</mo><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi>B</mi></mrow></msup></math>
are unitaries, we can hence simplify the expression of the norm:
<!-- l. 784 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>∥</mo><msup><mrow><mi>f</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-open' stretchy='false'>(</mo><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>∥</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>∥</mo><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>itA</mi></mrow></msup><mo class='MathClass-open' stretchy='false'>(</mo><mi>A</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>B</mi><mo class='MathClass-close' stretchy='false'>)</mo><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-bin' stretchy='false'>−</mo><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo><mi>B</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>∥</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>∥</mo><mi>A</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>B</mi><mo class='MathClass-rel' stretchy='false'>∥</mo></mrow></math>.
Putting it all together, we see then that: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 785 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
<mo class='MathClass-rel' stretchy='false'>∥</mo><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iA</mi></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iB</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>∥</mo><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-rel' stretchy='false'>∥</mo><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>−</mo><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>∥</mo><mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-rel' stretchy='false'>≤</mo><mspace class='nbsp' width='0.33em'></mspace><msubsup><mrow><mo>∫
 <!-- nolimits --></mo><!-- nolimits --></mrow><mrow><mn>0</mn></mrow><mrow><mn>1</mn></mrow></msubsup><mo class='MathClass-rel' stretchy='false'>∥</mo><msup><mrow><mi>f</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-open' stretchy='false'>(</mo><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>∥</mo><mi mathvariant='italic'>dt</mi><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><msubsup><mrow><mo>∫
 <!-- nolimits --></mo><!-- nolimits --></mrow><mrow><mn>0</mn></mrow><mrow><mn>1</mn></mrow></msubsup><mo class='MathClass-rel' stretchy='false'>∥</mo><mi>A</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mi>B</mi><mo class='MathClass-rel' stretchy='false'>∥</mo><mi mathvariant='italic'>dt</mi><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-rel' stretchy='false'>∥</mo><mi>A</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mi>B</mi><mo class='MathClass-rel' stretchy='false'>∥</mo><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td></tr></table>
<!-- l. 788 --><p class='indent'>   Now, for the real deal:
</p>
   <div class='newtheorem'>
<!-- l. 789 --><p class='noindent'><span class='head'>
<a id='x9-172003r5'></a>
<span class='cmbx-10x-x-109'>Exercise* 7.5.</span>  </span> In this exercise we will show that </p><table class='equation'><tr><td>
<!-- l. 791 --><p class='indent'>
</p><!-- l. 791 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                    <mstyle class='label' id='x9-172004r48'></mstyle><!-- endlabel --><mo class='MathClass-rel' stretchy='false'>∥</mo><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>A</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mi>B</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iA</mi></mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iB</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>∥</mo><mo class='MathClass-rel' stretchy='false'>≤</mo> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><mo class='MathClass-rel' stretchy='false'>∥</mo><mo class='MathClass-open' stretchy='false'>[</mo><mi>A</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>B</mi><mo class='MathClass-close' stretchy='false'>]</mo><mo class='MathClass-rel' stretchy='false'>∥</mo><mo class='MathClass-punc' stretchy='false'>,</mo>
</mrow></math></td><td class='eq-no'>(7.48)</td></tr></table>
<!-- l. 794 --><p class='indent'>   for self-adjoint <!-- l. 794 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>
and <!-- l. 794 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>B</mi></math>, where
<!-- l. 795 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>[</mo><mi>A</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>B</mi><mo class='MathClass-close' stretchy='false'>]</mo> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mi mathvariant='italic'>AB</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi mathvariant='italic'>BA</mi></mrow></math> denotes the
<span class='cmbx-10x-x-109'>commutator </span>of <!-- l. 795 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>A</mi></math>
and <!-- l. 795 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>B</mi></math>. We start by
defining the function <!-- l. 796 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>itA</mi></mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>itB</mi></mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-bin' stretchy='false'>−</mo><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-open' stretchy='false'>(</mo><mi>A</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mi>B</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup></mrow></math>.
     </p><dl class='enumerate'><dt class='enumerate'>
  1.. </dt><dd class='enumerate'>
     <!-- l. 798 --><p class='noindent'>Using the product rule and commutations of matrix exponentials, show
     that <!-- l. 798 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>f</mi></mrow><mrow><mi>′</mi></mrow></msup><mo class='MathClass-open' stretchy='false'>(</mo><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>i</mi><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>itA</mi></mrow></msup><mo class='MathClass-open' stretchy='false'>[</mo><mi>A</mi><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>itB</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>]</mo><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mo class='MathClass-open' stretchy='false'>(</mo><mn>1</mn><mo class='MathClass-bin' stretchy='false'>−</mo><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-open' stretchy='false'>(</mo><mi>A</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mi>B</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup></mrow></math>.
     </p></dd><dt class='enumerate'>
  2.. </dt><dd class='enumerate'>
     <!-- l. 799 --><p class='noindent'>Show that hence <!-- l. 799 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>∥</mo><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>A</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mi>B</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iA</mi></mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iB</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>∥</mo><mo class='MathClass-rel' stretchy='false'>≤</mo><msubsup><mrow><mo>∫</mo>
 <!-- nolimits --><!-- nolimits --></mrow><mrow><mn>0</mn></mrow><mrow><mn>1</mn></mrow></msubsup><mo class='MathClass-rel' stretchy='false'>∥</mo><mo class='MathClass-open' stretchy='false'>[</mo><mi>A</mi><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>itB</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>]</mo><mo class='MathClass-rel' stretchy='false'>∥</mo><mi mathvariant='italic'>dt</mi></mrow></math>.
                                                                     

                                                                     
     </p></dd><dt class='enumerate'>
  3.. </dt><dd class='enumerate'>
     <!-- l. 800 --><p class='noindent'>Define another function <!-- l. 800 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>g</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>x</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>ixB</mi></mrow></msup><mi>A</mi><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>ixB</mi></mrow></msup></mrow></math>
     and show that we can write <!-- l. 800 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>∥</mo><mo class='MathClass-open' stretchy='false'>[</mo><mi>A</mi><mo class='MathClass-punc' stretchy='false'>,</mo><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>itB</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>]</mo><mo class='MathClass-rel' stretchy='false'>∥</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>∥</mo><mi>g</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>g</mi><mo class='MathClass-open' stretchy='false'>(</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>∥</mo></mrow></math>.
     </p></dd><dt class='enumerate'>
  4.. </dt><dd class='enumerate'>
     <!-- l. 801 --><p class='noindent'>By writing it as an integral, show that <!-- l. 801 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>∥</mo><mi>g</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>g</mi><mo class='MathClass-open' stretchy='false'>(</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>∥</mo><mo class='MathClass-rel' stretchy='false'>≤</mo> <mi>t</mi><mo class='MathClass-rel' stretchy='false'>∥</mo><mo class='MathClass-open' stretchy='false'>[</mo><mi>A</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>B</mi><mo class='MathClass-close' stretchy='false'>]</mo><mo class='MathClass-rel' stretchy='false'>∥</mo></mrow></math>.
     </p></dd><dt class='enumerate'>
  5.. </dt><dd class='enumerate'>
     <!-- l. 802 --><p class='noindent'>Combine what you have now shown to prove that <!-- l. 802 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>∥</mo><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>A</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mi>B</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iA</mi></mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iB</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>∥</mo><mo class='MathClass-rel' stretchy='false'>≤</mo><msubsup><mrow><mo>∫</mo>
 <!-- nolimits --><!-- nolimits --></mrow><mrow><mn>0</mn></mrow><mrow><mn>1</mn></mrow></msubsup><mi>t</mi><mo class='MathClass-rel' stretchy='false'>∥</mo><mo class='MathClass-open' stretchy='false'>[</mo><mi>A</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>B</mi><mo class='MathClass-close' stretchy='false'>]</mo><mo class='MathClass-rel' stretchy='false'>∥</mo><mi mathvariant='italic'>dt</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><mo class='MathClass-rel' stretchy='false'>∥</mo><mo class='MathClass-open' stretchy='false'>[</mo><mi>A</mi><mo class='MathClass-punc' stretchy='false'>,</mo><mi>B</mi><mo class='MathClass-close' stretchy='false'>]</mo><mo class='MathClass-rel' stretchy='false'>∥</mo></mrow></math>.
     </p></dd></dl>
   </div>
<!-- l. 804 --><p class='indent'>     Hence, setting <!-- l. 827 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>A</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-bin' stretchy='false'>−</mo><mi>t</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></math>
and <!-- l. 827 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>B</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-bin' stretchy='false'>−</mo><mi>t</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></math>
we get </p><table class='equation'><tr><td>
<!-- l. 828 --><p class='indent'>
</p><!-- l. 828 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
   <mstyle class='label' id='x9-172010r49'></mstyle><!-- endlabel --><mo class='MathClass-rel' stretchy='false'>∥</mo><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>+</mo><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub>
          </mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub>
</mrow></msup><mo class='MathClass-rel' stretchy='false'>∥</mo><mo class='MathClass-rel' stretchy='false'>≤</mo> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><mo class='MathClass-rel' stretchy='false'>∥</mo><mo class='MathClass-open' stretchy='false'>[</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mi>t</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mi>t</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>]</mo><mo class='MathClass-rel' stretchy='false'>∥</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-rel' stretchy='false'>∥</mo><mo class='MathClass-open' stretchy='false'>[</mo><msub><mrow><mi>H</mi></mrow><mrow>
<mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>]</mo><mo class='MathClass-rel' stretchy='false'>∥</mo><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td><td class='eq-no'>(7.49)</td></tr></table>
<!-- l. 831 --><p class='indent'>   Hence, setting <!-- l. 831 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>κ</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><mo class='MathClass-rel' stretchy='false'>∥</mo><mo class='MathClass-open' stretchy='false'>[</mo><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>]</mo><mo class='MathClass-rel' stretchy='false'>∥</mo></mrow></math>
we have what we set out to prove! This basic fact lets us take a Hamiltonian written in
terms of Pauli strings, and “peel off” the Pauli exponentials, one-by-one. That is, for
<!-- l. 835 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>H</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><msub><mrow> <mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>k</mi></mrow></msub><msub><mrow><mi>α</mi></mrow><mrow><mi>k</mi></mrow></msub><msub><mrow><mover accent='true'><mrow><mi>P</mi></mrow><mo accent='true'>→</mo></mover></mrow><mrow><mi>k</mi></mrow></msub></mrow></math>, there exist
some constants <!-- l. 835 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>κ</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>κ</mi></mrow><mrow><mi>m</mi></mrow></msub></mrow></math>
such that:
</p>
<div class='center'>
<!-- l. 837 --><p class='noindent'>
</p><!-- l. 838 --><p class='noindent'><object data="svgs/time-evo-approx.svg" alt="diagram of time-evo-approx" class="svg-diagram"></object> </p></div>
                                                                     

                                                                     
<!-- l. 841 --><p class='indent'>   By triangle inequality, we conclude: </p><table class='equation'><tr><td>
<!-- l. 842 --><p class='indent'>
</p><!-- l. 842 --><object id='x9-172011r50' data="svgs/eq-time-evo-approx.svg" alt="diagram of eq:time-evo-approx" class="svg-diagram"></object></td><td class='eq-no'>(7.50)</td></tr></table>
<!-- l. 845 --><p class='indent'>   where <!-- l. 845 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>κ</mi> <mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow> <mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>k</mi></mrow></msub><msub><mrow><mi>κ</mi></mrow><mrow><mi>k</mi></mrow></msub></mrow></math>. So,
we have managed to put a bound on our approximation, and hence the error we’ll give if we
try to simulate <!-- l. 846 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math>.
But is this bound any good? There is no reason
<!-- l. 846 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>κ</mi></math> needs
to be small, and in fact usually it won’t be.
</p>
   <div class='newtheorem'>
<!-- l. 847 --><p class='noindent'><span class='head'>
<a id='x9-172012r6'></a>
<span class='cmbx-10x-x-109'>Exercise 7.6.</span>  </span>Give             an             explicit             form             of
<!-- l. 848 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>κ</mi></math>
in Eq. (<a href='#x9-172011r50'>7.50<!-- tex4ht:ref: eq:time-evo-approx  --></a>) using Eq. (<a href='#x9-172004r48'>7.48<!-- tex4ht:ref: eq:exponential-bound  --></a>).
</p>
   </div>
<!-- l. 849 --><p class='indent'>    So, our best bet is taking <!-- l. 850 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>t</mi></math>
to be very small. But what if we don’t want to take
<!-- l. 850 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>t</mi></math> to be small, because
we want to simulate <!-- l. 850 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math>
for a larger amount of time? It turns out there is a nice trick for this: we perform
the decomposition (<a href='#x9-172011r50'>7.50<!-- tex4ht:ref: eq:time-evo-approx  --></a>) many times and compose the results. That is, we can
take advantage of the fact that
</p>
<div class='center'>
<!-- l. 853 --><p class='noindent'>
</p><!-- l. 854 --><p class='noindent'><object data="svgs/time-evo-split.svg" alt="diagram of time-evo-split" class="svg-diagram"></object> </p></div>
                                                                     

                                                                     
<!-- l. 857 --><p class='indent'>   then approximate each of the maps
<!-- l. 857 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi>i</mi> <mfrac><mrow><mi>t</mi></mrow>
<mrow><mi>d</mi></mrow></mfrac><mi>H</mi></mrow></msup></math>
individually using (<a href='#x9-172011r50'>7.50<!-- tex4ht:ref: eq:time-evo-approx  --></a>). Initially, we might think this is a stupid thing to do,
since now we’ll be making even more approximations, so maybe things will get
worse. The crucial point, however, is that the error in (<a href='#x9-172011r50'>7.50<!-- tex4ht:ref: eq:time-evo-approx  --></a>) depends not on
<!-- l. 858 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>t</mi></math>, but
on <!-- l. 858 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup></math>.
So, even though we have to make this approximation
<!-- l. 858 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>d</mi></math> times, we can still
bound the error by <!-- l. 858 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>d</mi> <mo class='MathClass-bin' stretchy='false'>⋅</mo> <msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo> <mfrac><mrow><mi>t</mi></mrow>
<mrow><mi>d</mi></mrow></mfrac><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mn>2</mn></mrow></msup><mi>κ</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mfrac><mrow><msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup></mrow> 
 <mrow><mi>d</mi></mrow></mfrac> <mi>κ</mi></mrow></math>.
Hence, we get: </p><table class='equation'><tr><td>
<!-- l. 859 --><p class='indent'>
</p><!-- l. 859 --><object id='x9-172013r51' data="svgs/eq-time-evo-approx-split.svg" alt="diagram of eq:time-evo-approx-split" class="svg-diagram"></object></td><td class='eq-no'>(7.51)</td></tr></table>
<!-- l. 862 --><p class='indent'>   Supposing we wish to approximate within some error
<!-- l. 862 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>𝜖</mi></math>, we should
choose <!-- l. 862 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>d</mi></math> such
that <!-- l. 862 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup></mrow>
 <mrow><mi>d</mi></mrow></mfrac> <mi>κ</mi> <mo class='MathClass-rel' stretchy='false'>≤</mo> <mi>𝜖</mi></mrow></math>. When
<!-- l. 862 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>t</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>, we should therefore
choose some <!-- l. 862 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>d</mi> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mfrac><mrow><mi>κ</mi></mrow> 
<mrow><mi>𝜖</mi></mrow></mfrac> </mrow></math>.
So, we now know how to build a quantum circuit
<!-- l. 863 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>C</mi></math> that approximates
<!-- l. 863 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>itH</mi></mrow></msup></math> up to some
parameter <!-- l. 863 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>𝜖</mi></math>. We
can use <!-- l. 863 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>C</mi></math> to do a
pretty good job at predicting how the real system behaves. That is, for a fixed input state
<!-- l. 863 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> and any measurement
outcome <!-- l. 863 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover></math>, the probabilities
of seeing <!-- l. 863 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover></math> on the “real”
system described by <!-- l. 863 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math>
and the “simulated” system described by
<!-- l. 863 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>C</mi></math> are
pretty close. To see this, we’ll compare the two probabilities: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 864 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow>
                 <mstyle class='text'><mtext class='textrm' mathvariant='normal'>Prob</mtext></mstyle></mrow><mrow><mstyle class='text'><mtext class='textit' mathvariant='italic'>real</mtext></mstyle></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mi>r</mi><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup><mspace class='qquad' width='2em'></mspace><mspace class='qquad' width='2em'></mspace><msub><mrow><mstyle class='text'><mtext class='textrm' mathvariant='normal'>Prob</mtext></mstyle></mrow><mrow><mstyle class='text'><mtext class='textit' mathvariant='italic'>sim</mtext></mstyle></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mi>s</mi><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup>
</mrow></math></td></tr></table>
<!-- l. 871 --><p class='indent'>   for amplitudes <!-- l. 871 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>r</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>⟨</mo><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>itH</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
and <!-- l. 871 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>s</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>⟨</mo><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo><mi>C</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>. First,
since <!-- l. 871 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
and <!-- l. 871 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
are normalised, we have: </p><table class='equation-star'><tr><td>
<!-- l. 872 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                 <msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>itH</mi></mrow></msup><mspace class='nbsp' width='0.33em'></mspace><mover class='overset'><mrow> <mo class='MathClass-rel' stretchy='false'>≈</mo></mrow><mrow><mi>𝜖</mi></mrow></mover><mspace class='nbsp' width='0.33em'></mspace><mi>C</mi><mspace class='thickpace' width='0.28em'></mspace><mo class='MathClass-rel' stretchy='false'>⟹</mo><mspace class='thickpace' width='0.28em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>itH</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='nbsp' width='0.33em'></mspace><mover class='overset'><mrow><mo class='MathClass-rel' stretchy='false'>≈</mo></mrow><mrow><mi>𝜖</mi></mrow></mover><mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo><mi>C</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo>
</mrow></math></td></tr></table>
<!-- l. 879 --><p class='indent'>   so <!-- l. 879 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>r</mi><mover class='overset'><mrow> <mo class='MathClass-rel' stretchy='false'>≈</mo></mrow><mrow><mi>𝜖</mi></mrow></mover><mi>s</mi></mrow></math>.
Since taking the adjoint preserves norms, we also have
<!-- l. 879 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='false' class='mml-overline'><mrow><mi>r</mi></mrow><mo accent='true'>¯</mo></mover><mover class='overset'><mrow> <mo class='MathClass-rel' stretchy='false'>≈</mo></mrow><mrow><mi>𝜖</mi></mrow></mover><mover accent='false' class='mml-overline'><mrow><mi>s</mi></mrow><mo accent='true'>¯</mo></mover></mrow></math>.
Since <!-- l. 879 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>r</mi><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>
and <!-- l. 879 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>s</mi><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>
must both be less than 1, we have: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 880 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                      <mo class='MathClass-rel' stretchy='false'>|</mo><mi>r</mi><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='false' class='mml-overline'><mrow><mi>r</mi></mrow><mo accent='true'>¯</mo></mover><mi>r</mi><mover class='overset'><mrow> <mo class='MathClass-rel' stretchy='false'>≈</mo></mrow><mrow><mi>𝜖</mi></mrow></mover><mover accent='false' class='mml-overline'><mrow><mi>r</mi></mrow><mo accent='true'>¯</mo></mover><mi>s</mi><mover class='overset'><mrow> <mo class='MathClass-rel' stretchy='false'>≈</mo></mrow><mrow><mi>𝜖</mi></mrow></mover><mover accent='false' class='mml-overline'><mrow><mi>s</mi></mrow><mo accent='true'>¯</mo></mover><mi>s</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mi>s</mi><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup>
</mrow></math></td></tr></table>
<!-- l. 887 --><p class='indent'>   Applying the triangle inequality, we have
<!-- l. 887 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>r</mi><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup><mover class='overset'><mrow> <mo class='MathClass-rel' stretchy='false'>≈</mo></mrow><mrow><mn>2</mn><mi>𝜖</mi></mrow></mover><mo class='MathClass-rel' stretchy='false'>|</mo><mi>s</mi><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup></mrow></math>.
Hence: </p><table class='equation-star'><tr><td>
<!-- l. 888 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow>
                    <mstyle class='text'><mtext class='textrm' mathvariant='normal'>Prob</mtext></mstyle></mrow><mrow><mstyle class='text'><mtext class='textit' mathvariant='italic'>real</mtext></mstyle></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo><mover class='overset'><mrow> <mo class='MathClass-rel' stretchy='false'>≈</mo></mrow><mrow><mn>2</mn><mi>𝜖</mi></mrow></mover><msub><mrow><mstyle class='text'><mtext class='textrm' mathvariant='normal'>Prob</mtext></mstyle></mrow><mrow><mstyle class='text'><mtext class='textit' mathvariant='italic'>sim</mtext></mstyle></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>b</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo>
</mrow></math></td></tr></table>
<!-- l. 893 --><p class='noindent'>
</p>
   <h3 class='sectionHead' id='simplifying-universal-diagrams'><span class='titlemark'>7.6   </span> <a id='x9-1730007.6'></a>Simplifying universal diagrams</h3>
<!-- l. 894 --><p class='noindent'>In this chapter our focus has been on universal <span class='cmti-10x-x-109'>circuits</span>. But we of course
shouldn’t be neglecting our <span class='cmti-10x-x-109'>diagrams</span>. A universal ZX-diagram is one where we
put no restriction on the phases the spiders may contain. It turns out that we
can apply some of the tricks we’ve been developing for reasoning about
universal circuits to universal ZX-diagrams. In particular, phase gadgets are
also really useful in this broader context. For one, we can use them to
power-up the simplification strategy of Clifford diagrams of the previous
chapter. Let’s recap this strategy. Recall from Sections <a href='main_htmlch5.html#simplifying-clifford-diagrams'>5.2<!-- tex4ht:ref: sec:cliff-simp  --></a> and <a href='main_htmlch5.html#clifford-normal-forms'>5.3<!-- tex4ht:ref: sec:Clifford-nf  --></a> that we
have two simplification rules, local complementation and pivoting, that
allow us to remove certain spiders with a Clifford phase. We then do the
following:
     </p><dl class='enumerate'><dt class='enumerate'>
  1.. </dt><dd class='enumerate'>
     <!-- l. 897 --><p class='noindent'>First we rewrite the diagram to a graph-like diagram, so that all spiders
     are <!-- l. 897 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math>-spiders
     and they are only connected via Hadamard edges.
                                                                     

                                                                     
     </p></dd><dt class='enumerate'>
  2.. </dt><dd class='enumerate'>
     <!-- l. 898 --><p class='noindent'>Then using local complementation we remove all internal spiders with
     a <!-- l. 898 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>±</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>
     phase.
     </p></dd><dt class='enumerate'>
  3.. </dt><dd class='enumerate'>
     <!-- l. 899 --><p class='noindent'>Similarly, using pivoting we remove any pair of connected spiders that
     are both internal and have a <!-- l. 899 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math>
     or <!-- l. 899 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math>
     phase. </p></dd></dl>
<!-- l. 901 --><p class='noindent'>Since we’ll need to refer to spiders with a phase of
<!-- l. 901 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>0</mn></math> or
<!-- l. 901 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>π</mi></math> a lot
in this section, we’ll give them a name. We will call such a spider a <span class='cmbx-10x-x-109'>Pauli
spider</span>. Now, using this strategy, if the diagram is Clifford, the only remaining
internal spiders will be Pauli spiders that are only connected to boundary
spiders. In Section <a href='main_htmlch5.html#gslc-normal-form'>5.3.2<!-- tex4ht:ref: sec:GSLC-nf  --></a> it is described how we can also get rid of these spiders,
so that <span class='cmti-10x-x-109'>all </span>internal spiders are removed, and the diagram will be in GSLC form.
Now, let’s look at what happens if we do the same strategy for a <span class='cmti-10x-x-109'>non</span>-Clifford
diagram, i.e. where our spiders are allowed to be labelled by arbitrary
phases. Such a diagram we can still rewrite to graph-like form using
Proposition <a href='main_htmlch5.html#x7-109006r8'>5.1.8<!-- tex4ht:ref: prop:to-graph-like  --></a>, but now the spiders might carry a Clifford phase (a multiple of
<!-- l. 903 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>), or a
non-Clifford phase (any other value). We can apply the local complementation
and pivoting rewrites as before to remove any internal spider with a
<!-- l. 903 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow> <mo class='MathClass-bin' stretchy='false'>±</mo><mfrac><mrow><mi>π</mi></mrow> 
<mrow><mn>2</mn></mrow></mfrac> </mrow></math> phase and
a connected pair of internal Pauli spiders. When we do this we have several types of
internal spiders that can remain. First, none of these rewrites remove spiders that
have a non-Clifford phase, so if an internal spider has a phase that is not a multiple
of <!-- l. 904 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>,
then it will still be in the diagram. Second, we can only remove the Pauli spiders
that are connected to other Clifford spiders (either an internal Pauli spider, or an
arbitrary boundary Clifford spider). Hence, we can also have internal Pauli
spiders remaining that are connected only to non-Clifford spiders. We cannot
actually remove these Pauli spiders, but we can do something interesting with
them: transform them into phase gadgets. As we are working here with
graph-like ZX-diagrams, the phase gadgets will look slightly different:
</p><table class='equation'><tr><td>
<!-- l. 907 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 907 --><object id='x9-173004r52' data="svgs/phase-gadget.svg" alt="diagram of phase-gadget" class="svg-diagram"></object></td><td class='eq-no'>(7.52)</td></tr></table>
   <div class='newtheorem'>
<!-- l. 910 --><p class='noindent'><span class='head'>
<a id='x9-173005r1'></a>
<span class='cmbx-10x-x-109'>Lemma 7.6.1.</span>  </span> We can transform an internal Pauli spider connected to another
internal spider into a phase gadget using pivoting: </p><table class='equation-star'><tr><td>
<!-- l. 912 --><object data="svgs/pivot-gadget-simp.svg" alt="diagram of pivot-gadget-simp" class="svg-diagram"></object></td></tr></table>
   </div>
<!-- l. 915 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 917 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>First                                    push                                    the
<!-- l. 917 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='italic'>jπ</mi></mrow></math>
phase        to        the        right,        and        then        unfuse        the
<!-- l. 917 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>γ</mi></math>
phase onto its own spider:
</p>
                                                                     

                                                                     
<div class='center'>
<!-- l. 919 --><p class='noindent'>
</p><!-- l. 920 --><p class='noindent'><object data="svgs/pivot-gadget-simp-pf.svg" alt="diagram of pivot-gadget-simp-pf" class="svg-diagram"></object> </p></div>
<!-- l. 923 --><p class='indent'>   Now just apply the regular pivot Lemma <a href='main_htmlch5.html#x7-114005r11'>5.2.11<!-- tex4ht:ref: lem:pivot-simp  --></a> to the two spiders marked
by *.                                                                                          □
</p>
   </div>
<!-- l. 925 --><p class='indent'>   We see that we end up with the same number of spiders, but that they are connected
differently. The <!-- l. 925 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>γ</mi></math>
phase is now isolated on a spider that only has arity 1, i.e. it has become a phase
gadget. This turns out to have several benefits. But first, note that if the internal
Pauli spider is only connected to boundaries that we can do a similar
rewrite.
</p>
   <div class='newtheorem'>
<!-- l. 927 --><p class='noindent'><span class='head'>
<a id='x9-173006r2'></a>
<span class='cmbx-10x-x-109'>Lemma 7.6.2.</span>  </span> The following boundary pivot simplification holds: </p><table class='equation-star'><tr><td>
<!-- l. 929 --><object data="svgs/pivot-boundary-simp.svg" alt="diagram of pivot-boundary-simp" class="svg-diagram"></object></td></tr></table>
<!-- l. 932 --><p class='indent'>   Here we take the spider with the <!-- l. 932 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>γ</mi></math>
phase to be a boundary spider with the top wires being inputs and outputs to the
diagram.
</p>
   </div>
<!-- l. 933 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 935 --><p class='indent'>   <span class='head'>
                                                                     

                                                                     
<span class='cmti-10x-x-109'>Proof.</span> </span>First       add       spiders       to       the       outputs       of       the
<!-- l. 935 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>γ</mi></math>
spider as in Eq. (<a href='main_htmlch5.html#x7-117002r15'>5.15<!-- tex4ht:ref: eq:pivot-boundary-unfuse  --></a>) and then use Lemma <a href='#x9-173005r1'>7.6.1<!-- tex4ht:ref: lem:pivot-gadget-simp  --></a>.                              □
</p>
   </div>
<!-- l. 937 --><p class='indent'>   As in Section <a href='main_htmlch5.html#gslc-normal-form'>5.3.2<!-- tex4ht:ref: sec:GSLC-nf  --></a>, doing operations on the boundary introduces Hadamards
on the input and output wires of the diagram so that we are working with
graph-like diagrams with Hadamards. After we’ve applied the rewrites of
Lemmas <a href='#x9-173005r1'>7.6.1<!-- tex4ht:ref: lem:pivot-gadget-simp  --></a> and <a href='#x9-173006r2'>7.6.2<!-- tex4ht:ref: lem:pivot-boundary-simp  --></a> to all the internal Pauli spiders we see that these
internal Pauli spiders are now all part of a phase gadget. As a side-note, in order
to not get stuck in an infinite loop in doing these rewrites, we should only be
applying these lemmas to Pauli spiders that are not already part of a
phase gadget (i.e. we should check if they do not have any single-arity
neighbours).
</p>
   <div class='newtheorem'>
<!-- l. 939 --><p class='noindent'><span class='head'>
<a id='x9-173007r3'></a>
<span class='cmbx-10x-x-109'>Example 7.6.3.</span>  </span>After we apply the rewrite strategy we described above,
we might be left with a diagram that looks something like the following:
</p>
<div class='center'>
<!-- l. 942 --><p class='noindent'>
</p><!-- l. 943 --><p class='noindent'><object data="svgs/graph-with-gadgets-example.svg" alt="diagram of graph-with-gadgets-example" class="svg-diagram"></object> </p></div>
<!-- l. 946 --><p class='indent'>   Every internal spider is either part of a phase gadget or has a non-Clifford
phase.
</p>
   </div>
<!-- l. 947 --><p class='indent'>
</p>
   <div class='newtheorem'>
<!-- l. 948 --><p class='noindent'><span class='head'>
<a id='x9-173008r4'></a>
                                                                     

                                                                     
<span class='cmbx-10x-x-109'>Remark 7.6.4.</span>  </span> In the diagrams we get from this rewrite strategy, none of
the phase gadgets will be connected to each other. To see why this is, note
that in Lemmas <a href='#x9-173005r1'>7.6.1<!-- tex4ht:ref: lem:pivot-gadget-simp  --></a> and <a href='#x9-173006r2'>7.6.2<!-- tex4ht:ref: lem:pivot-boundary-simp  --></a> the phase gadget we create is connected
to precisely those spiders that the original Pauli spider was connected to.
Our starting assumption was that no Pauli spider is connected to any other
internal Pauli spider, since if that was the case, then we could have just
applied a regular pivot to them to remove them. As each phase gadget is
hence connected to what a Pauli spider was connected to, none of them will
be connected to each other. Conversely, if we were given a diagram where
two phase gadgets are connected to each other, then we could apply a regular
pivot to them, and this would remove the ‘base’ of these gadgets, and change
the phases into ‘regular’ internal spiders.
</p>
   </div>
<!-- l. 951 --><p class='indent'>    While these ‘gadgetisation’ rewrites don’t get rid of more spiders, it is
still very useful to do them. First, it turns out that the diagrams we
can bound the size of the diagrams we get in terms of the number of
non-Clifford phases, and second, there are interesting new rewrites that we can
apply to the phase gadgets. For the first point, note first that if the phase
<!-- l. 953 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>γ</mi></math> in
the phase gadget is Clifford that we can remove the phase gadget.
</p>
   <div class='newtheorem'>
<!-- l. 954 --><p class='noindent'><span class='head'>
<a id='x9-173009r7'></a>
<span class='cmbx-10x-x-109'>Exercise 7.7.</span>  </span>Show that if we have a phase gadget in a graph-like diagram
with a phase that is a multiple of <!-- l. 955 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> </mrow></math>,
that we can remove it using a series of local complementation or pivots.
</p>
   </div>
<!-- l. 956 --><p class='indent'>     Hence, the only remaining internal spiders are either non-Clifford or are
Pauli spiders part of a non-Clifford phase gadget. As none of our rewrites
introduce new non-Clifford phases, this means that the number of internal
spiders we end up with is bounded by the number of non-Clifford phases we
started out with.
</p>
   <div class='newtheorem'>
<!-- l. 962 --><p class='noindent'><span class='head'>
<a id='x9-173010r5'></a>
                                                                     

                                                                     
<span class='cmbx-10x-x-109'>Proposition 7.6.5.</span>  </span>Let
<!-- l. 963 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>D</mi></math>
be                        a                        ZX-diagram                        with
<!-- l. 963 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
inputs,
<!-- l. 963 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>m</mi></math>
outputs                                                                                    and
<!-- l. 963 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
non-Clifford      phases.      Then      we      can      efficiently      rewrite
<!-- l. 963 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>D</mi></math>
to                                          a                                          diagram
<!-- l. 963 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>D</mi></mrow><mrow><mi>′</mi></mrow></msup></math>
which                          has                          at                          most
<!-- l. 963 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>m</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>2</mn><mi>k</mi></mrow></math>
spiders                                                                                     and
<!-- l. 963 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>m</mi></mrow></math>
Hadamards on the inputs and outputs.
</p>
   </div>
<!-- l. 964 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 966 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>Transform
<!-- l. 966 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>D</mi></math>
into                       graph-like                       form                       and
apply the rewrites described above. When we are done with the rewrites we
can have a spider for each of the inputs and outputs, contributing at most
<!-- l. 967 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>m</mi></mrow></math>
spiders. Each of the remaining internal spiders is either non-Clifford, or is a
Pauli
spider that is part of a non-Clifford phase gadget, so that there are at most
<!-- l. 967 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>2</mn><mi>k</mi></mrow></math>
internal spiders. Since the resulting diagram is graph-like with Hadamards
we can potentially also have Hadamards on the input and output wires.    □
</p>
   </div>
<!-- l. 969 --><p class='indent'>   This result is in a sense a more fine-grained version of Proposition <a href='main_htmlch5.html#x7-117004r7'>5.3.7<!-- tex4ht:ref: prop:clifford-to-GSLC  --></a>
that shows that we can rewrite any Clifford diagram to GSLC form: if
                                                                     

                                                                     
<!-- l. 969 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>
in the proposition above, then the result is a GSLC form diagram. We
can in fact view all the internal spiders and phase gadgets as additional
states and effects plugged into a GSLC diagram (see also Exercise <a href='main_htmlch5.html#x7-110006r5'>5.5<!-- tex4ht:ref: exer:graph-like-to-graph-state  --></a>):
</p><table class='equation'><tr><td>
<!-- l. 970 --><p class='indent'>
</p><!-- l. 970 --><object id='x9-173011r53' data="svgs/graph-with-gadgets-to-graph-state.svg" alt="diagram of graph-with-gadgets-to-graph-state" class="svg-diagram"></object></td><td class='eq-no'>(7.53)</td></tr></table>
<!-- l. 973 --><p class='indent'>   This is pointing in the direction of how we can do arbitrary quantum
computations by preparing the right graph state and doing the right
measurements. We will explore this type of measurement-based quantum
computing in detail in Chapter <a href='main_htmlch8.html#measurementbased-quantum-computation'>8<!-- tex4ht:ref: ch:mbqc  --></a>. The fact that the size of our diagram is
bounded by the number of non-Clifford gates, and not by the overall number of
spiders in the starting diagram turns out to be useful when we want to simulate
universal quantum circuits (see Section <a href='#simulating-universal-circuits'>7.8.1<!-- tex4ht:ref: sec:stab-decomp  --></a>).
</p>
   <div class='newtheorem'>
<!-- l. 975 --><p class='noindent'><span class='head'>
<a id='x9-173012r6'></a>
<span class='cmbx-10x-x-109'>Remark* 7.6.6.</span>  </span>So if we can rewrite our diagram to a form that is bounded
in  size  by  the  number  of  non-Clifford  spiders,  and  if  the  phase  gadget
rewrites we need to do to get there don’t remove any spiders, does that
mean that we could have already bounded the size of the diagram <span class='cmti-10x-x-109'>before</span>
doing these rewrites? Well, no. This is because Lemmas <a href='#x9-173005r1'>7.6.1<!-- tex4ht:ref: lem:pivot-gadget-simp  --></a> and <a href='#x9-173006r2'>7.6.2<!-- tex4ht:ref: lem:pivot-boundary-simp  --></a> <span class='cmti-10x-x-109'>can</span>
actually result in spiders being removed from the diagram. This happens
when we have two Pauli spiders that are connected to exactly the same set
of non-Clifford spiders. In this case, when we apply Lemma <a href='#x9-173005r1'>7.6.1<!-- tex4ht:ref: lem:pivot-gadget-simp  --></a> to one
of the Pauli spiders and one of its neighbours, the other Pauli spider gets
completely disconnected and becomes a scalar, which we can then ignore.
In general, Lemma <a href='#x9-173005r1'>7.6.1<!-- tex4ht:ref: lem:pivot-gadget-simp  --></a> will change the connectivity of the Pauli spiders
in the diagram, and hence through a sequence of rewrites we could end up
with Pauli spiders that are connected to the same set of non-Clifford spiders,
resulting in more spiders getting removed by these rewrites.
                                                                     

                                                                     
</p>
   </div>
<!-- l. 978 --><p class='indent'>
</p>
   <h4 class='subsectionHead' id='removing-nonclifford-spiders'><span class='titlemark'>7.6.1   </span> <a id='x9-1740007.6.1'></a>Removing non-Clifford spiders</h4>
<!-- l. 980 --><p class='noindent'>Once we have simplified our diagram to a point where all internal spiders are
either non-Clifford or phase gadgets, there are a couple more useful rewrite rules
we can apply that remove additional spiders. The first is very simple, as it is just
a case of removing an identity spider.
</p>
   <div class='newtheorem'>
<!-- l. 982 --><p class='noindent'><span class='head'>
<a id='x9-174001r7'></a>
<span class='cmbx-10x-x-109'>Lemma 7.6.7.</span>  </span> We can fuse a one-legged phase gadget with its neighbour:
</p>
<div class='center'>
<!-- l. 985 --><p class='noindent'>
</p><!-- l. 986 --><p class='noindent'><object data="svgs/gadget-id-simp.svg" alt="diagram of gadget-id-simp" class="svg-diagram"></object> </p></div>
   </div>
<!-- l. 989 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 990 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>  </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 991 --><object data="svgs/gadget-id-simp-pf.svg" alt="diagram of gadget-id-simp-pf" class="svg-diagram"></object></td></tr></table>
                                                                   □
   </div>
<!-- l. 995 --><p class='indent'>   So whenever we have a phase gadget in our diagram that is connected to
exactly one spider, we can fuse it with its neighbour. There is really nothing
special about phase gadgets here: as noted in Remark <a href='#x9-173008r4'>7.6.4<!-- tex4ht:ref: rem:phase-gadget-not-connected  --></a>, the phase gadget is
connected to what the original Pauli spider was connected to. So if we have a
one-legged phase gadget in our diagram, then the original Pauli spider must have
also already have been an identity spider, and we could have removed it then and
there. The other rewrite rule we can apply to phase gadgets is one we have
already seen: gadget fusion.
</p>
   <div class='newtheorem'>
<!-- l. 997 --><p class='noindent'><span class='head'>
<a id='x9-174002r8'></a>
<span class='cmbx-10x-x-109'>Lemma 7.6.8.</span>  </span> We can fuse two phase gadgets connected to the same set
of spiders:
</p>
<div class='center'>
<!-- l. 1000 --><p class='noindent'>
</p><!-- l. 1001 --><p class='noindent'><object data="svgs/gadget-simp.svg" alt="diagram of gadget-simp" class="svg-diagram"></object> </p></div>
   </div>
<!-- l. 1004 --><p class='indent'>
</p>
   <div class='proof'>
<!-- l. 1005 --><p class='indent'>   <span class='head'>
<span class='cmti-10x-x-109'>Proof.</span> </span>  </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 1006 --><object data="svgs/gadget-simp-pf.svg" alt="diagram of gadget-simp-pf" class="svg-diagram"></object></td></tr></table>
                                                                   □
   </div>
<!-- l. 1010 --><p class='indent'>   So why do we point out these two rewrite rules for getting rid of phase
gadgets? Two reasons: first, note that this phase gadget fusion rule is a
generalisation of the phase-folding we can do in the phase polynomial framework.
Second, the rewrites of Lemmas <a href='#x9-174001r7'>7.6.7<!-- tex4ht:ref: lem:gadget-id-simp  --></a> and <a href='#x9-174002r8'>7.6.8<!-- tex4ht:ref: lem:gadget-simp  --></a> are essentially the <span class='cmti-10x-x-109'>only </span>rewrite
rules we can do to get rid of additional non-Clifford phases in a diagram. Or that
is, this is the case when we treat the non-Clifford phases as ‘black boxes’,
where we treat the phase as some arbitrary angle that we don’t know
anything else about. See the References of this chapter for more details. If
we know more about the phases, such as that they are all multiples of
<!-- l. 1012 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>, then
there are other potential rewrites we could apply that simplify the diagram
further. We look at this in detail in Chapter <a href='main_htmlch10.html#cliffordt'>10<!-- tex4ht:ref: ch:clifford-t  --></a>.
</p>
   <h4 class='subsectionHead' id='circuits-from-universal-diagrams'><span class='titlemark'>7.6.2   </span> <a id='x9-1750007.6.2'></a>Circuits from universal diagrams</h4>
<!-- l. 1014 --><p class='noindent'>In previous chapters we have seen that certain gate sets have a natural
diagrammatic counterpart, and that for unitary diagrams we can always
transform them back into circuits over this gate set. In Chapter <a href='main_htmlch4.html#cnot-circuits-and-phasefree-zxdiagrams'>4<!-- tex4ht:ref: ch:phasefree  --></a> we saw that
any unitary phase-free diagram can be rewritten into a CNOT circuit, and in
Chapter <a href='main_htmlch5.html#clifford-circuits-and-diagrams'>5<!-- tex4ht:ref: ch:clifford  --></a> we saw that any unitary Clifford diagram can be turned back into a
Clifford circuit. This then raises the question of how we can transform these
universal diagrams back into universal circuits when they are unitary. Perhaps
disappointingly, but not too surprisingly, this does not turn out to be efficiently
doable <span class='cmti-10x-x-109'>in general</span>.
</p>
   <div class='newtheorem'>
<!-- l. 1016 --><p class='noindent'><span class='head'>
<a id='x9-175001r8'></a>
                                                                     

                                                                     
<span class='cmbx-10x-x-109'>Exercise* 7.8.</span>  </span> In this exercise we will see that if we had some function
<span class='cmbx-10x-x-109'>CircuitExtraction </span>that takes in a poly-size unitary ZX-diagram and spits out a
poly-size circuit implementing it, that then we could solve NP-complete problems
with it. Hence, there is probably no implementation of <span class='cmbx-10x-x-109'>CircuitExtraction </span>that is
efficient. In particular, what we will show is how to determine whether a Boolean
formula <!-- l. 1017 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi> <mo class='MathClass-punc' stretchy='false'>:</mo> <mi>𝔽</mi><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>→</mo> <mi>𝔽</mi><mn>2</mn></mrow></math>
has a solution using <span class='cmbx-10x-x-109'>CircuitExtraction</span>.
     </p><dl class='enumerate'><dt class='enumerate'>
  1.. </dt><dd class='enumerate'>
     <!-- l. 1019 --><p class='noindent'>Let <!-- l. 1019 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>L</mi></mrow><mrow><mi>f</mi></mrow></msub></math> be the linear
     map defined by <!-- l. 1019 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>L</mi></mrow><mrow><mi>f</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
     We will see in Chapter <a href='main_htmlch9.html#controlled-gates-and-classical-oracles'>9<!-- tex4ht:ref: ch:midlevel  --></a> how we can construct maps like
     <!-- l. 1019 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>L</mi></mrow><mrow><mi>f</mi></mrow></msub></math>
     efficiently as a ZX-diagram. Argue that </p><table class='equation'><tr><td>
     <!-- l. 1020 --><p class='noindent'>
     </p><!-- l. 1020 --><object id='x9-175003r54' data="svgs/eq-extraction-hardness-1.svg" alt="diagram of eq:extraction-hardness-1" class="svg-diagram"></object></td><td class='eq-no'>(7.54)</td></tr></table>
     <!-- l. 1023 --><p class='noindent'>where <!-- l. 1023 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>N</mi></mrow><mrow><mi>a</mi></mrow></msub></math> is the
     number of values <!-- l. 1023 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></math>
     for which <!-- l. 1023 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>a</mi></mrow></math>.
     </p></dd><dt class='enumerate'>
  2.. </dt><dd class='enumerate'>
     <!-- l. 1024 --><p class='noindent'>If we could calculate the value of Eq. (<a href='#x9-175003r54'>7.54<!-- tex4ht:ref: eq:extraction-hardness-1  --></a>) then we could determine whether
     <!-- l. 1024 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math>
     has a solution. However, <span class='cmbx-10x-x-109'>CircuitExtraction </span>expects a unitary
     diagram as input, which Eq. (<a href='#x9-175003r54'>7.54<!-- tex4ht:ref: eq:extraction-hardness-1  --></a>) is not. So we need to construct a
     unitary diagram containing Eq. (<a href='#x9-175003r54'>7.54<!-- tex4ht:ref: eq:extraction-hardness-1  --></a>) that allows us to determine
     <!-- l. 1024 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>N</mi></mrow><mrow><mn>1</mn></mrow></msub></math>. Using the fact that
     a superposition <!-- l. 1024 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>λ</mi></mrow><mrow><mn>0</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>λ</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
     can be written as <!-- l. 1024 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Y</mi> <mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
     show that </p><table class='equation'><tr><td>
                                                                     

                                                                     
     <!-- l. 1025 --><p class='noindent'>
     </p><!-- l. 1025 --><object id='x9-175005r55' data="svgs/eq-extraction-hardness-2.svg" alt="diagram of eq:extraction-hardness-2" class="svg-diagram"></object></td><td class='eq-no'>(7.55)</td></tr></table>
     <!-- l. 1028 --><p class='noindent'>and determine <!-- l. 1028 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>α</mi></math>
     in terms of <!-- l. 1028 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>N</mi></mrow><mrow><mn>1</mn></mrow></msub></math>.
     </p></dd><dt class='enumerate'>
  3.. </dt><dd class='enumerate'>
     <!-- l. 1029 --><p class='noindent'>The left-hand side of Eq. (<a href='#x9-175005r55'>7.55<!-- tex4ht:ref: eq:extraction-hardness-2  --></a>) is proportional to a unitary
     diagram, and hence when given to <span class='cmbx-10x-x-109'>CircuitExtraction </span>will spit
     out a 1-qubit circuit equal to the right-hand side of Eq. (<a href='#x9-175005r55'>7.55<!-- tex4ht:ref: eq:extraction-hardness-2  --></a>).
     Argue that with such a circuit we can efficiently determine
     <!-- l. 1029 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>α</mi></math> and
     hence <!-- l. 1029 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>N</mi></mrow><mrow><mn>1</mn></mrow></msub></math>
     (you may ignore issues about numerical precision and the precise gate set
     that <span class='cmbx-10x-x-109'>CircuitExtraction </span>is using).
     </p></dd><dt class='enumerate'>
  4.. </dt><dd class='enumerate'>
     <!-- l. 1030 --><p class='noindent'>Give the full algorithm that takes in a Boolean function
     <!-- l. 1030 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math>
     and with a single call to <span class='cmbx-10x-x-109'>CircuitExtraction </span>tells you whether
     <!-- l. 1030 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math>
     has a solution or not. </p></dd></dl>
<!-- l. 1032 --><p class='noindent'>In this procedure we described we actually know more than just whether
<!-- l. 1032 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>f</mi></math> has <span class='cmti-10x-x-109'>a </span>solution:
we get <!-- l. 1032 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>N</mi></mrow><mrow><mn>1</mn></mrow></msub></math>,
the <span class='cmti-10x-x-109'>total number </span>of solutions. <span class='cmbx-10x-x-109'>CircuitExtraction </span>hence doesn’t just allow us to
solve NP-complete problems, it allows us to solve #P-complete problems, which
are generally considered to be much harder.
</p>
   </div>
                                                                     

                                                                     
<!-- l. 1033 --><p class='indent'>     Universal diagrams can just become too complicated, making it
impossible to efficiently see what circuit it is equal to. Luckily for us though,
for many diagrams we care about we can tame these complications and
efficiently extract out a circuit. This is made possible by a strong connection
between graph-like ZX-diagrams and <span class='cmti-10x-x-109'>measurement patterns</span>. The ability
to extract a circuit from the diagram then corresponds to whether the
measurement pattern can be made deterministic. We will explain all of this
and more in detail in the next chapter on measurement-based quantum
computing.
</p>
   <h3 class='sectionHead' id='summary-what-to-remember5'><span class='titlemark'>7.7   </span> <a id='x9-1760007.7'></a>Summary: What to remember</h3>
<!-- l. 1052 --><p class='noindent'>
     </p><dl class='enumerate'><dt class='enumerate'>
  1.. </dt><dd class='enumerate'>
     <!-- l. 1052 --><p class='noindent'>A circuit consisting of CNOT and <!-- l. 1052 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math>
     phase gates can be represented by a <span class='cmti-10x-x-109'>phase polynomial </span>followed by a
     linear Boolean map acting on the computational basis states.
     </p></dd><dt class='enumerate'>
  2.. </dt><dd class='enumerate'>
     <!-- l. 1053 --><p class='noindent'>In the ZX-calculus a phase polynomial looks like a collection of <span class='cmti-10x-x-109'>phase
     gadgets</span>.
     </p></dd><dt class='enumerate'>
  3.. </dt><dd class='enumerate'>
     <!-- l. 1054 --><p class='noindent'>The phase-polynomial representation can be synthesised back into a
     CNOT+Phases circuit using a variation on the Gaussian elimination
     algorithm of Chapter <a href='main_htmlch4.html#cnot-circuits-and-phasefree-zxdiagrams'>4<!-- tex4ht:ref: ch:phasefree  --></a>.
     </p></dd><dt class='enumerate'>
  4.. </dt><dd class='enumerate'>
     <!-- l. 1055 --><p class='noindent'>The <span class='cmti-10x-x-109'>pathsum  </span>technique allows us to incorporate Hadamards in the
     phase-polynomial representation. Each Hadamard gate introduces a
     new <span class='cmti-10x-x-109'>path variable </span>that replaces the current variable on that qubit. By
     thinking about pathsums we can synthesise complex unitaries like the
     Quantum Fourier Transform.
     </p></dd><dt class='enumerate'>
  5.. </dt><dd class='enumerate'>
                                                                     

                                                                     
     <!-- l. 1056 --><p class='noindent'>A  different  way  to  think  about  universal  circuits  is  through  <span class='cmti-10x-x-109'>Pauli
     exponentials</span>.  Any  quantum  circuit  can  be  written  as  a  series  of
     (non-Clifford) Pauli exponentials, followed by a Clifford circuit.
     </p></dd><dt class='enumerate'>
  6.. </dt><dd class='enumerate'>
     <!-- l. 1057 --><p class='noindent'>The Pauli exponential representation allows us to bound the size of an
     <!-- l. 1057 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit
     circuit with <!-- l. 1057 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>
     non-Clifford gates by <!-- l. 1057 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi mathvariant='italic'>kn</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>n</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
     </p></dd><dt class='enumerate'>
  7.. </dt><dd class='enumerate'>
     <!-- l. 1058 --><p class='noindent'>We can construct a quantum circuit for a Hamiltonian evolution <!-- l. 1058 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>itH</mi></mrow></msup></math>
     by splitting it up into small time-slices <!-- l. 1058 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi>i</mi> <mfrac><mrow><mi>t</mi></mrow>
<mrow><mi>n</mi></mrow></mfrac><mi>H</mi></mrow></msup></math>
     and approximating each of these by a series of Pauli exponentials.
     </p></dd><dt class='enumerate'>
  8.. </dt><dd class='enumerate'>
     <!-- l. 1059 --><p class='noindent'>We  can  use  the  Clifford  simplification  strategy  of  Chapter <a href='main_htmlch5.html#clifford-circuits-and-diagrams'>5<!-- tex4ht:ref: ch:clifford  --></a>  to
     optimise universal diagrams. By using a variation on pivoting we can
     introduce  phase  gadgets  in  such  diagrams,  and  these  can  then  be
     merged together.
     </p></dd><dt class='enumerate'>
  9.. </dt><dd class='enumerate'>
     <!-- l. 1060 --><p class='noindent'>In these optimised graph-like diagrams, the only internal spiders are
     those with non-Clifford phases, or they form the ‘base’ of a phase
     gadget.
     </p></dd><dt class='enumerate'>
 10.. </dt><dd class='enumerate'>
     <!-- l. 1061 --><p class='noindent'>In general, extracting a circuit out of a unitary ZX-diagram is a hard
     problem (though in certain special cases we can do it efficiently). </p></dd></dl>
<!-- l. 1063 --><p class='noindent'>
</p>
   <h3 class='sectionHead' id='advanced-material3'><span class='titlemark'>7.8   </span> <a id='x9-1770007.8'></a>Advanced material*</h3>
                                                                     

                                                                     
<!-- l. 1064 --><p class='noindent'>
</p>
   <h4 class='subsectionHead' id='simulating-universal-circuits'><span class='titlemark'>7.8.1   </span> <a id='x9-1780007.8.1'></a>Simulating universal circuits*</h4>
<!-- l. 1065 --><p class='noindent'>Each of the gates we have considered in this
chapter—<!-- l. 1065 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math>
phase gates, CNOTs, and Hadamards—has a different interaction with the
path-sum expression of the circuit. </p>
     <ul class='itemize1'>
     <li class='itemize'>A <!-- l. 1067 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math>
     phase gate looks at the expression that is currently in the qubit it acts
     on, and puts that expression into a phase.
     </li>
     <li class='itemize'>A CNOT takes the expression in its control qubit, and XORs it with
     that of its target qubit.
     </li>
     <li class='itemize'>A Hadamard introduces a new path-variable, adds a phase term using
     it and the expression in the qubit it acts on, and finally replaces the
     expression with the new variable. </li></ul>
<!-- l. 1071 --><p class='noindent'>What is interesting about these three types of gates is that we truly need <span class='cmti-10x-x-109'>all </span>of them
in order to do interesting quantum computations. If we only had phase gates and
CNOTs, then as we saw in Section <a href='#phase-polynomials'>7.1.1<!-- tex4ht:ref: sec:phase-polys  --></a> we can efficiently evaluate what it does
on a computational basis state, as there is just one path involved. If we instead
only had phase gates and Hadamards, then all the qubits would be acting
on their own, and so there wouldn’t be any complex behaviour and we
could directly calculate the matrices involved. And finally, if we only had
CNOTs and Hadamards, then the circuit would be Clifford, so that we
can also efficiently calculate the outcomes. The interesting behaviour
then comes from a multitude of paths (because of Hadamards) which are
non-trivially using all parts of the available Hilbert space (because of
CNOTs), and each of which can have a different phase so that when we do a
measurement the paths interfere in non-trivial ways. While these arguments
only show that you need at least <span class='cmti-10x-x-109'>some </span>of each type of gates, it turns
out that we can prove a bit more. Suppose for instance that we have a
<!-- l. 1075 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit
circuit with a polynomial number of CNOT, Hadamard and
<!-- l. 1075 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math> phase gates, but that
we only have <!-- l. 1075 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi><mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --><mi>n</mi></mrow></math> CNOT
                                                                     

                                                                     
gates for some <!-- l. 1075 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>.
Then this means that most qubits don’t have <span class='cmti-10x-x-109'>any</span> CNOT on them: at most
<!-- l. 1075 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>2</mn><mi>k</mi><mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --><mi>n</mi></mrow></math> qubits
can be connected by CNOTs. The size of the matrix associated to these qubits is
then <!-- l. 1075 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mn>2</mn></mrow><mrow><mn>2</mn><mi>k</mi><mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --><mi>n</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>n</mi></mrow><mrow><mn>2</mn><mi>k</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
So calculating what this circuit is doing can be done in polynomial
time just by directly representing the matrix and calculating the
action of all the gates on it one-by-one. Analogously, if we have only
<!-- l. 1076 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi><mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --><mi>n</mi></mrow></math> Hadamard
gates, then using the path-sum representation of the circuit we only have to keep
track of <!-- l. 1076 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mn>2</mn></mrow><mrow><mi>k</mi><mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --><mi>n</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>n</mi></mrow><mrow><mi>k</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
different paths, so that we can efficiently simulate the action of the circuit as
well, just by sampling from this polynomial number of paths. These two
simulation techniques, based on a cost that scales based on the number of
Hadamards or CNOTs are not seriously considered (though lots of tricks for
tensor network contractions are based on understanding where entanglement is
created and how, and so counting where the CNOTs are is definitely implicitly
part of that), but one that is based on a limited number of non-Clifford phases
turns out to work quite nicely.
</p>
   <h5 class='subsubsectionHead' id='stabiliser-decompositions'><span class='titlemark'>7.8.1.1   </span> <a id='x9-1790007.8.1.1'></a>Stabiliser Decompositions</h5>
<!-- l. 1079 --><p class='noindent'>As it turns out, if we only have <!-- l. 1079 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi><mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --><mi>n</mi></mrow></math>
non-Clifford <!-- l. 1079 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math>
phase gates, then we can also efficiently strongly simulate the circuit. To see this,
let’s assume that we have some polynomial size circuit of CNOT, Hadamard and
<!-- l. 1080 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>Z</mi></math> phase gates
of which <!-- l. 1080 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>t</mi></math>
are non-Clifford phases, and that we wish to calculate a specific
amplitude of this circuit (let’s say the amplitude of observing
<!-- l. 1080 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>⟨</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math> on input
of <!-- l. 1080 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-rel' stretchy='false'>⋯</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>).
Then we can write this as a scalar ZX-diagram. We can rewrite this diagram into
graph-like form, and simplify it further to remove all the Clifford spiders. As
described in Section <a href='#removing-nonclifford-spiders'>7.6.1<!-- tex4ht:ref: sec:non-Clifford-simp  --></a>, the number of spiders in the resulting diagram is then
<!-- l. 1080 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mn>2</mn><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> as
each spider either carries a non-Clifford phase, or is part of a phase gadget which
has a non-Clifford phase. In such a diagram, we can’t remove any more Clifford
spiders, since there aren’t any. However, it turns out we can decompose a
non-Clifford spider into a sum of Cliffords, so that then the whole diagram
becomes a sum of ‘slightly more Clifford’ diagrams. To do this in a nice
generalisable way we first unfuse the non-Clifford phase onto its own spider:
                                                                     

                                                                     
</p><table class='equation-star'><tr><td>
<!-- l. 1082 --><object data="svgs/spider-to-magic-state.svg" alt="diagram of spider-to-magic-state" class="svg-diagram"></object></td></tr></table>
<!-- l. 1085 --><p class='indent'>   The remaining phase is then Clifford Now, this state with the
<!-- l. 1086 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>α</mi></math> phase is
equal to <!-- l. 1086 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iα</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
and hence can be decomposed into a sum of two Clifford spiders corresponding to these
terms <!-- l. 1086 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
and <!-- l. 1086 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>:
</p><table class='equation-star'><tr><td>
<!-- l. 1087 --><object data="svgs/magic-state-alpha.svg" alt="diagram of magic-state-alpha" class="svg-diagram"></object></td></tr></table>
<!-- l. 1090 --><p class='indent'>   When we do this unfuse-and-decompose to a single
<!-- l. 1090 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>α</mi></math> phase
in a bigger diagram, we are then left with two diagrams that each have one
fewer non-Clifford phase. We can however do this decomposition to <span class='cmti-10x-x-109'>all </span>of
the non-Clifford phases in the larger diagram at the same time, giving
<!-- l. 1090 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mn>2</mn></mrow><mrow><mi>t</mi></mrow></msup></math>
different diagrams that are now completely Clifford. Each of these diagrams had
<!-- l. 1090 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
spiders, and hence to completely ‘simplify away’ these diagrams into a single
scalar number using the Clifford simplification strategy of Chapter <a href='main_htmlch5.html#clifford-circuits-and-diagrams'>5<!-- tex4ht:ref: ch:clifford  --></a>, requires
<!-- l. 1090 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>t</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
graph operations. As we have to do this for each of the
                                                                     

                                                                     
<!-- l. 1090 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mn>2</mn></mrow><mrow><mi>t</mi></mrow></msup></math> diagrams, the
total cost is then <!-- l. 1090 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>t</mi></mrow><mrow><mn>3</mn></mrow></msup><msup><mrow><mn>2</mn></mrow><mrow><mi>t</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
Hence, if we have a logarithmic number of non-Clifford phases
<!-- l. 1090 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>t</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>k</mi><mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --><mi>n</mi></mrow></math>, then the simulation
cost is <!-- l. 1090 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>k</mi></mrow><mrow><mn>3</mn></mrow></msup><msup><mrow><mi>n</mi></mrow><mrow><mi>k</mi></mrow></msup><msup><mrow> <mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --></mrow><mrow><mn>3</mn></mrow></msup><mi>n</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>, which is
polynomial in <!-- l. 1090 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>
for a fixed <!-- l. 1090 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>.
We could also decide not to decompose all phases simultaneously, but instead try
to simplify the diagram further after every decomposition. Since a decomposition
makes the diagram look a little more Clifford, the Clifford rewrites could make
the diagram a bit simpler. More importantly, they might reveal places where
the non-Clifford removing rewrites of Section <a href='#removing-nonclifford-spiders'>7.6.1<!-- tex4ht:ref: sec:non-Clifford-simp  --></a> might apply, so that
there are fewer terms we need to decompose in the first place. If all the
non-Clifford phases are arbitrary, with all the non-Clifford phases not
being equal to each other then this decompose-optimise-repeat strategy
is pretty much the best we can do with this method. However, if the
non-Clifford phases are some specific angles, then there is more interesting stuff
we can do! In particular, if all the non-Clifford phases are multiples of
<!-- l. 1092 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>,
for instance when the circuit we start out with is
Clifford+<!-- l. 1092 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>,
then it turns out that we can decompose a <span class='cmti-10x-x-109'>group </span>of
<!-- l. 1092 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></math> phases
simultaneously, and this requires fewer terms. For instance, if we have a pair of
<!-- l. 1093 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msqrt><mrow><mn>2</mn></mrow></msqrt><mi>T</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-bin' stretchy='false'>+</mo><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mn>0</mn><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
states, then:
</p><!-- tex4ht:inline --><!-- l. 1097 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mtable class='align-star' columnalign='left' displaystyle='true'>
            <mtr><mtd class='align-odd' columnalign='right'><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='nbsp' width='0.33em'></mspace></mtd>            <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-rel' stretchy='false'>|</mo><mn>00</mn><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mn>01</mn><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mn>10</mn><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> </mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mn>11</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace width='2em'></mspace></mtd>             <mtd class='align-label' columnalign='right'></mtd>            <mtd class='align-label'>
            <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'><mspace class='nbsp' width='0.33em'></mspace></mtd>                     <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>00</mn><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> </mrow></msup><mo class='MathClass-rel' stretchy='false'>|</mo><mn>11</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></msup><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mn>01</mn><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mn>10</mn><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-punc' stretchy='false'>.</mo><mspace width='2em'></mspace></mtd>            <mtd class='align-label' columnalign='right'></mtd>            <mtd class='align-label'>
   <mspace width='2em'></mspace></mtd></mtr></mtable></math>
<!-- l. 1098 --><p class='noindent'>Here we’ve grouped the terms together into two Bell-like maximally entangled
states. Written in diagrams we hence have: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 1099 --><object data="svgs/2-T-decomposition.svg" alt="diagram of 2-T-decomposition" class="svg-diagram"></object></td></tr></table>
<!-- l. 1102 --><p class='indent'>   Naively decomposing these two non-Clifford
<!-- l. 1102 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>
phases would give us 4 terms, but by grouping them into these
Clifford states we require only 2 terms. Hence, if we have
<!-- l. 1102 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>t</mi></math> of these
<!-- l. 1102 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></math> phases,
then the amount of terms we get when we decompose all of them in terms of pairs like
this is <!-- l. 1102 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mn>2</mn></mrow><mrow><mfrac><mrow><mn>1</mn></mrow>
<mrow><mn>2</mn></mrow></mfrac><mi>t</mi></mrow></msup></math>
(assuming <!-- l. 1102 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>t</mi></math>
is even for simplicity). This hence scales quadratically better than
decomposing them all separately! This is an example of a <span class='cmbx-10x-x-109'>stabiliser
decomposition </span>and there are many interesting things to say about
them. A stabiliser decomposition is any decomposition of a quantum state
into a sum of Clifford states. This is always possible to do, but for an
<!-- l. 1103 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math>-qubit state will
require in general <!-- l. 1103 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mn>2</mn></mrow><mrow><mi>n</mi></mrow></msup></math>
stabiliser terms. Finding more efficient decompositions is generally a
hard problem. However, for very special states, like a tensor product
<!-- l. 1103 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo><mo class='MathClass-bin' stretchy='false'>⊗</mo><mo class='MathClass-rel' stretchy='false'>⋯</mo> <mo class='MathClass-bin' stretchy='false'>⊗</mo><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>, much
better decompositions are known. For instance, it turns out we can decompose six
copies of <!-- l. 1103 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
into just 6 terms, meaning we only require
<!-- l. 1103 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mn>6</mn></mrow><mrow><mi>t</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>6</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mn>2</mn></mrow><mrow><mi>t</mi><mfrac><mrow><mn>1</mn></mrow>
<mrow><mn>6</mn></mrow></mfrac><msub><mrow> <mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --></mrow><mrow><mn>2</mn></mrow></msub><mn>6</mn></mrow></msup> <mo class='MathClass-rel' stretchy='false'>≈</mo> <msup><mrow><mn>2</mn></mrow><mrow><mn>0.43</mn><mi>t</mi></mrow></msup></mrow></math>. There are also specific
configurations of <!-- l. 1103 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> </mrow></math>
phases that allow for more efficient decompositions.
</p>
   <h5 class='subsubsectionHead' id='gatebygate-simulation'><span class='titlemark'>7.8.1.2   </span> <a id='x9-1800007.8.1.2'></a>Gate-by-gate simulation</h5>
<!-- l. 1105 --><p class='noindent'>Note that this stabiliser decomposition simulation technique allows us to
calculate an <span class='cmti-10x-x-109'>amplitude</span>. If we want to calculate a marginal probability
(cf. Section <a href='main_htmlch5.html#weak-vs-strong-simulation'>5.4.2<!-- tex4ht:ref: sec:simulation-weak-strong  --></a>), then we need to ‘double’ the diagram. This doubles the
number of non-Clifford phases, which is a big problem since this method scales
exponentially in the number of non-Cliffords. In practice, the interleaved
                                                                     

                                                                     
optimisation steps do get rid of some of the redundancy in this doubled
representation, but the problem does persist. Usually we are doing strong
simulation, and hence calculation of marginal probabilities, because we are
actually trying to do weak simulation (i.e. sampling). In that case there are
ways around having to double the diagram. One way is to not even try
to calculate amplitudes, but instead directly do sampling by writing
our circuit as a stochastic combination of Clifford computations. We
will say a bit more about this when we are talking about <span class='cmti-10x-x-109'>computational
universality </span>in Section <a href='main_htmlch10.html#computational-universality-via-catalysis'>10.5.2<!-- tex4ht:ref: sec:comp-universal  --></a>. When doing this, we no longer care about the
number of terms in the decomposition, but instead we care about the
total <span class='cmti-10x-x-109'>weight </span>of the terms, i.e. the scalar factors in front of them. This
weight is known as the <span class='cmbx-10x-x-109'>robustness of magic </span>or the <span class='cmbx-10x-x-109'>stabiliser extent </span>of
the state (which one is used depends on <span class='cmti-10x-x-109'>which </span>weights exactly we are
talking about, see the References of this chapter). But there is another
way, where it turns out to be sufficient to calculate just amplitudes, no
marginals necessary. This is known as the <span class='cmbx-10x-x-109'>gate-by-gate simulation</span>
method. This does come at the cost of having to calculate a number of
amplitudes that scales with the number of <span class='cmti-10x-x-109'>gates </span>instead of in the number of
qubits. To see how this works, let’s suppose our circuit consists of unitaries
<!-- l. 1109 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>U</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>U</mi></mrow><mrow><mi>k</mi></mrow></msub></mrow></math> and write
<!-- l. 1109 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>C</mi></mrow><mrow><mi>t</mi></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>U</mi></mrow><mrow><mi>t</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>U</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></math> for the circuit consisting
of just the first <!-- l. 1109 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>t</mi></math> unitaries.
Hence <!-- l. 1109 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>C</mi></mrow><mrow><mn>0</mn></mrow></msub></math> is the identity,
and <!-- l. 1109 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>C</mi></mrow><mrow><mi>k</mi></mrow></msub></math> is the final circuit.
Write <!-- l. 1109 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>P</mi></mrow><mrow><mi>t</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-open' stretchy='false'>⟨</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>C</mi></mrow><mrow><mi>t</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mn>0</mn></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup></mrow></math> for the probability
of measuring the <!-- l. 1109 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover></math>
outcome when applying <!-- l. 1109 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>U</mi></mrow><mrow><mi>t</mi></mrow></msub></math>
to the all-zero state <!-- l. 1109 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mn>0</mn></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
Our goal is to sample bit strings from the final distribution
<!-- l. 1110 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>P</mi></mrow><mrow><mi>k</mi></mrow></msub></math>.
We are going to do that by starting with a sample from
<!-- l. 1110 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>P</mi></mrow><mrow><mn>0</mn></mrow></msub></math> and
then transforming this into a sample that matches the distribution of
<!-- l. 1110 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>P</mi></mrow><mrow><mn>1</mn></mrow></msub></math>, and
then <!-- l. 1110 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>P</mi></mrow><mrow><mn>2</mn></mrow></msub></math>,
and so on until we get a sample distributed according to
<!-- l. 1110 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>P</mi></mrow><mrow><mi>k</mi></mrow></msub></math>.
The reason this is a beneficial thing to do is because sampling from
<!-- l. 1110 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>P</mi></mrow><mrow><mn>0</mn></mrow></msub></math>
is trivial (just always output the all-zero bit string
<!-- l. 1110 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mn>0</mn></mrow><mo accent='true'>→</mo></mover></math>),
and the update process from a distribution over
<!-- l. 1110 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>P</mi></mrow><mrow><mi>t</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msub></math> to one over
<!-- l. 1110 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>P</mi></mrow><mrow><mi>t</mi></mrow></msub></math> turns out
                                                                     

                                                                     
to not require any marginal probability calculations. The reason for that is because the
distributions <!-- l. 1111 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>P</mi></mrow><mrow><mi>t</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msub></math>
and <!-- l. 1111 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>P</mi></mrow><mrow><mi>t</mi></mrow></msub></math>
are the same for most qubits. They are based on two circuits
<!-- l. 1111 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>C</mi></mrow><mrow><mi>t</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msub></math> and
<!-- l. 1111 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>C</mi></mrow><mrow><mi>t</mi></mrow></msub></math> that are related
via <!-- l. 1111 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>C</mi></mrow><mrow><mi>t</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>U</mi></mrow><mrow><mi>t</mi></mrow></msub><msub><mrow><mi>C</mi></mrow><mrow><mi>t</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msub></mrow></math>. Let’s assume
for now that <!-- l. 1111 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>U</mi></mrow><mrow><mi>t</mi></mrow></msub></math> is a
single-qubit gate acting on the first qubit. Then it turns out the distributions marginalising
over <!-- l. 1111 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub></math>
are actually equal: </p><table class='equation'><tr><td>
<!-- l. 1112 --><p class='indent'>
</p><!-- l. 1112 --><object id='x9-180001r56' data="svgs/eq-gate-by-gate-marginal.svg" alt="diagram of eq:gate-by-gate-marginal" class="svg-diagram"></object></td><td class='eq-no'>(7.56)</td></tr></table>
<!-- l. 1115 --><p class='indent'>   Hence, to update a bit string <!-- l. 1115 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></math>
distributed according to <!-- l. 1115 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>P</mi></mrow><mrow><mi>t</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msub></math>
to one distributed over <!-- l. 1115 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>P</mi></mrow><mrow><mi>t</mi></mrow></msub></math>,
we only need to resample the first bit
<!-- l. 1115 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>y</mi></mrow><mrow><mn>1</mn></mrow></msub></math> according to the
conditional distribution <!-- l. 1115 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>P</mi></mrow><mrow><mi>t</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>y</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>y</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
When we do this we indeed get a correct sample, as </p><table class='equation-star'><tr><td>
<!-- l. 1116 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
             <msub><mrow><mi>P</mi></mrow><mrow><mi>t</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><msub><mrow><mi>P</mi></mrow><mrow><mi>t</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><msub><mrow><mi>P</mi></mrow><mrow><mi>t</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td></tr></table>
<!-- l. 1119 --><p class='indent'>   Rewriting this a bit, we recall that the conditional distribution is defined as:
</p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 1120 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
         <msub><mrow><mi>P</mi></mrow><mrow><mi>t</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>y</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>y</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>x</mi></mrow><mrow><mi>n</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>y</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace>    <mfrac><mrow><msub><mrow><mi>P</mi></mrow><mrow><mi>t</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>y</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>y</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>y</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow> 
<mrow><munder class='msub'><mrow><mo>∑</mo>
  </mrow><mrow><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></munder><msub><mrow><mi>P</mi></mrow><mrow><mi>t</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>y</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>y</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></mfrac><mo class='MathClass-punc' stretchy='false'>,</mo>
</mrow></math></td></tr></table>
<!-- l. 1123 --><p class='indent'>   and hence sampling from it is straightforward: we just calculate
<!-- l. 1123 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>p</mi></mrow><mrow><mi>a</mi></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>P</mi></mrow><mrow><mi>t</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>a</mi><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>y</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>y</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> for
both <!-- l. 1123 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>
and <!-- l. 1123 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>a</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>,
both of which can be done by amplitude calculations, and then we set
<!-- l. 1123 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>y</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math> with
probability <!-- l. 1123 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>p</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>∕</mo><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>p</mi></mrow><mrow><mn>0</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>p</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
We hence don’t require any calculation of marginals! We assumed
<!-- l. 1124 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>U</mi></mrow><mrow><mi>t</mi></mrow></msub></math> was a single-qubit gate.
If it is instead an <!-- l. 1124 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>l</mi></math>-qubit
gate, then in Eq. (<a href='#x9-180001r56'>7.56<!-- tex4ht:ref: eq:gate-by-gate-marginal  --></a>) we would have an
<!-- l. 1124 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>l</mi></math>-qubit marginal
on those <!-- l. 1124 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>l</mi></math>
qubits that <!-- l. 1124 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>U</mi></mrow><mrow><mi>t</mi></mrow></msub></math>
is acting on. Then instead of resampling just a single bit, we would resample these
<!-- l. 1124 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>l</mi></math> bits, which would
require the calculation of <!-- l. 1124 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mn>2</mn></mrow><mrow><mi>l</mi></mrow></msup></math>
amplitudes. If our gate set consists of just single-qubit gates
and the CNOT, then this would hence require at most
<!-- l. 1124 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mn>4</mn></math>
amplitudes calculations per gate, with the two-qubit CNOT
being more expensive. But we can in fact do a bit better. If
<!-- l. 1125 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>U</mi></mrow><mrow><mi>t</mi></mrow></msub></math>
is a <span class='cmti-10x-x-109'>classical </span>gate, like the CNOT, that maps a computational
basis state to a computational basis state, then the distributions
<!-- l. 1125 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>P</mi></mrow><mrow><mi>t</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msub></math> and
<!-- l. 1125 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>P</mi></mrow><mrow><mi>t</mi></mrow></msub></math> are
related to each other by a simple relabelling of the outcomes: </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
<!-- l. 1126 --><object data="svgs/gate-by-gate-classical.svg" alt="diagram of gate-by-gate-classical" class="svg-diagram"></object></td></tr></table>
<!-- l. 1129 --><p class='indent'>   Here in the last step we absorbed the first CNOT into
<!-- l. 1129 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>C</mi></mrow><mrow><mi>t</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msub></math> to
get <!-- l. 1129 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>C</mi></mrow><mrow><mi>t</mi></mrow></msub></math>,
and we absorbed the second CNOT into the effect by setting
<!-- l. 1129 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msubsup><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>′</mi></mrow></msubsup> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>⊕</mo> <msub><mrow><mi>x</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></math>. Hence, when we have
a sample according to <!-- l. 1130 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>P</mi></mrow><mrow><mi>t</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msub></math>,
we can map it to <!-- l. 1130 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>P</mi></mrow><mrow><mi>t</mi></mrow></msub></math>
by just applying the classical gate to the sample directly, no calculation of amplitudes
necessary. This also works for for instance the Toffoli gate, or even an entire complicated
classical oracle. There are also other cases where updating the sample comes for free.
If <!-- l. 1132 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>U</mi></mrow><mrow><mi>t</mi></mrow></msub></math> preserves
the computational basis states, i.e. it is a diagonal phase gate, then the distributions
<!-- l. 1132 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>P</mi></mrow><mrow><mi>t</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msub></math> and
<!-- l. 1132 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>P</mi></mrow><mrow><mi>t</mi></mrow></msub></math>
are exactly equal, and so then no updating is necessary at
all! Hence, if our gate set consists of CNOT, Hadamard and
<!-- l. 1133 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> phase
gates, then the only time we have to actually calculate amplitudes in order to
update our sample is when we encounter a Hadamard gate. Putting this all together,
we get Algorithm <a href='#x9-180002r3'>3<!-- tex4ht:ref: alg:simulate-gate-by-gate  --></a>, which allows us to sample a bit string from a CNOT
+Hadamard+<!-- l. 1134 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
gate set. <a id='x9-180002r3'></a>
                                                                     

                                                                     
</p><!-- l. 1135 --><p class='indent'>   </p><figure class='float' id='x9-180004'><span id='gatebygate-weak-simulation-by-calculating-amplitudes'></span>
                                                                     

                                                                     
                                                                     

                                                                     
_____________________________________________________________________
  <span class='cmbx-10x-x-109'>Algorithm 3:</span> Gate-by-gate   weak   simulation   by   calculating
  amplitudes__________________________________________________________________________________ 
     <span class='cmbx-10x-x-109'>Input:</span> A
               circuit
               <!-- l. 1138 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>C</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>U</mi></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>U</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></math>
                   consisting
               of
               CNOT,
               Hadamard
               and
               <!-- l. 1138 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
               gates
     <span class='cmbx-10x-x-109'>Output:</span> A
                  sample
                  from
                  the
                  distribution
                  <!-- l. 1139 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-open' stretchy='false'>⟨</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo><mi>C</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mn>0</mn></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup></mrow></math>
      <span class='cmbx-10x-x-109'>Procedure</span> <span class='cmbx-10x-x-109'>SAMPLE</span><span class='cmti-10x-x-109'>(</span><!-- l. 1160 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>U</mi></mrow><mrow><mn>1</mn></mrow></msub></math><span class='cmti-10x-x-109'>,…,</span>
      <!-- l. 1160 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>U</mi></mrow><mrow><mi>k</mi></mrow></msub></math><span class='cmti-10x-x-109'>)</span>
      
   let
     <!-- l. 1160 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>C</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>I</mi></mrow></math>
   let
     <!-- l. 1160 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-rel' stretchy='false'>=</mo> <mover accent='true'><mrow><mn>0</mn></mrow><mo accent='true'>→</mo></mover></mrow></math>
   <span class='cmbx-10x-x-109'>for</span> <!-- l. 1160 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>t</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>
     <span class='cmbx-10x-x-109'>to</span>
    <!-- l. 1160 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math> <span class='cmbx-10x-x-109'>do
    </span><span class='cmti-10x-x-109'>// forward
    part</span>
    
   let 
<!-- l. 1160 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>C</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>U</mi></mrow><mrow><mi>t</mi></mrow></msub><mi>C</mi></mrow></math>
   <span class='cmbx-10x-x-109'>if</span> <!-- l. 1160 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>U</mi></mrow><mrow><mi>t</mi></mrow></msub></math> 
<span class='cmti-10x-x-109'>is 
CNOT</span> <span class='cmbx-10x-x-109'>then 
   </span><span class='cmti-10x-x-109'>// Update
       the
       sample
       classically</span>
   <!-- l. 1160 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>U</mi></mrow><mrow><mi>t</mi></mrow></msub><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></mrow></math>
   <span class='cmbx-10x-x-109'>end
   if</span> <!-- l. 1160 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>U</mi></mrow><mrow><mi>t</mi></mrow></msub></math> 
<span class='cmti-10x-x-109'>is 
Hadamard</span> <span class='cmbx-10x-x-109'>then 
   </span><span class='cmti-10x-x-109'>// We
       calculate
       some
       amplitudes
       in
       order
       to
       update
       the
       sample</span>
   let 
<!-- l. 1160 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>q</mi></math> 
be 
target 
qubit 
of 
<!-- l. 1160 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>U</mi></mrow><mrow><mi>t</mi></mrow></msub></math>
   let 
<!-- l. 1160 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>z</mi></mrow><mrow><mn>0</mn></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>⟨</mo><msub><mrow><mi>y</mi></mrow><mrow><mn>0</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>y</mi></mrow><mrow><mi>q</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msub><mn>0</mn><msub><mrow><mi>y</mi></mrow><mrow><mi>q</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mn>1</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>y</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><mi>U</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mn>0</mn></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
 let 
<!-- l. 1160 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>z</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-open' stretchy='false'>⟨</mo><msub><mrow><mi>y</mi></mrow><mrow><mn>0</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>y</mi></mrow><mrow><mi>q</mi><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msub><mn>1</mn><msub><mrow><mi>y</mi></mrow><mrow><mi>q</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mn>1</mn></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>y</mi></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><mi>U</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mn>0</mn></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
 let 
<!-- l. 1160 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>p</mi> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>z</mi></mrow><mrow><mn>0</mn></mrow></msub><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-bin' stretchy='false'>∕</mo><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>z</mi></mrow><mrow><mn>0</mn></mrow></msub><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>z</mi></mrow><mrow><mn>1</mn></mrow></msub><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
   with 
probability 
<!-- l. 1160 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>p</mi></math> 
set 
<!-- l. 1160 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>y</mi></mrow><mrow><mi>q</mi></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mn>0</mn></mrow></math>, 
otherwise 
set 
<!-- l. 1160 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>y</mi></mrow><mrow><mi>q</mi></mrow></msub> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>
   <span class='cmbx-10x-x-109'>end
   </span><span class='cmti-10x-x-109'>// If</span>
       <!-- l. 1160 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>U</mi></mrow><mrow><mi>t</mi></mrow></msub></math>
        <span class='cmti-10x-x-109'>is</span>
       <!-- l. 1160 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
       <span class='cmti-10x-x-109'>we
       don’t
       have
       to
       do
       anything
   </span><span class='cmbx-10x-x-109'>end
   return</span>
    <!-- l. 1160 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mover accent='true'><mrow><mi>y</mi></mrow><mo accent='true'>→</mo></mover></math>
    <span class='cmbx-10x-x-109'>end</span>_____________________________________________________________________________

                                                                     
                                                                     

                                                                     
   </figure>
   <div class='newtheorem'>
<!-- l. 1161 --><p class='noindent'><span class='head'>
<a id='x9-180005r1'></a>
<span class='cmbx-10x-x-109'>Theorem 7.8.1.</span>  </span>Let <!-- l. 1162 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>C</mi></math>
be a CNOT+Hadamard+<!-- l. 1162 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>Z</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>α</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
circuit with <!-- l. 1162 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>h</mi></math>
Hadamard  gates.  Then  we  can  produce  a  sample  from  the  distribution
<!-- l. 1162 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>P</mi><mo class='MathClass-open' stretchy='false'>(</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mo class='MathClass-rel' stretchy='false'>|</mo><mo class='MathClass-open' stretchy='false'>⟨</mo><mover accent='true'><mrow><mi>x</mi></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-rel' stretchy='false'>|</mo><mi>C</mi><mo class='MathClass-rel' stretchy='false'>|</mo><mover accent='true'><mrow><mn>0</mn></mrow><mo accent='true'>→</mo></mover><mo class='MathClass-close' stretchy='false'>⟩</mo><msup><mrow><mo class='MathClass-rel' stretchy='false'>|</mo></mrow><mrow><mn>2</mn></mrow></msup></mrow></math>
using <!-- l. 1162 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>2</mn><mi>h</mi></mrow></math>
calculations of amplitudes.
</p>
   </div>
<!-- l. 1163 --><p class='indent'>    Now recalling that the cost of calculating an amplitude of a
Clifford+<!-- l. 1164 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
circuit with <!-- l. 1164 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>t</mi></math>
<!-- l. 1164 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates was
<!-- l. 1164 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>t</mi></mrow><mrow><mn>3</mn></mrow></msup><msup><mrow><mn>2</mn></mrow><mrow><mi mathvariant='italic'>αt</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> for some
number <!-- l. 1164 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>α</mi> <mo class='MathClass-rel' stretchy='false'>≈</mo> <mn>0.43</mn></mrow></math>,
we see that we can sample from such a circuit with cost
<!-- l. 1164 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi>h</mi><msup><mrow><mi>t</mi></mrow><mrow><mn>3</mn></mrow></msup><msup><mrow><mn>2</mn></mrow><mrow><mi mathvariant='italic'>αt</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> where
<!-- l. 1164 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>h</mi></math> is the
number of Hadamard gates. Moreover, assuming that the Hadamards and
<!-- l. 1164 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math>
gates are roughly evenly distributed throughout the circuit, most of these
amplitude calculations will be of circuits that contain significantly fewer
<!-- l. 1164 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>T</mi></math> gates,
so that their cost of calculation is a lot cheaper.
</p>
   <h4 class='subsectionHead' id='higherorder-trotterisation'><span class='titlemark'>7.8.2   </span> <a id='x9-1810007.8.2'></a>Higher-order Trotterisation*</h4>
<!-- l. 1166 --><p class='noindent'>The approximation of <!-- l. 1166 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>itH</mi></mrow></msup></math>
we found in Section <a href='#hamiltonian-simulation'>7.5<!-- tex4ht:ref: sec:hammy-sim  --></a> required a number of decompositions
<!-- l. 1166 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math> that
scaled as <!-- l. 1166 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>𝜀</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
This is fine. But it does raise the question of whether we could
do better. Let’s look back at the case with just two terms
<!-- l. 1167 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub></math> and
<!-- l. 1167 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub></math>. The reason we didn’t
get better scaling than <!-- l. 1167 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>𝜀</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
                                                                     

                                                                     
is because <!-- l. 1167 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></msup></mrow></math> only
approximates <!-- l. 1167 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>+</mo><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup></math>
up to a <!-- l. 1167 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
term (Eq. (<a href='#x9-172010r49'>7.49<!-- tex4ht:ref: eq:Hamiltonian-approx  --></a>)). If we could somehow boost their agreement up to some
<!-- l. 1167 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>t</mi></mrow><mrow><mi>k</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> for a
<!-- l. 1167 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>&gt;</mo> <mn>2</mn></mrow></math>,
then we would get better scaling. Let’s expand both
<!-- l. 1168 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></msup></mrow></math> and
<!-- l. 1168 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>+</mo><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup></math> to see
where this <!-- l. 1168 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
approximation error comes from. Recall that we have by definition: </p><table class='equation'><tr><td>
<!-- l. 1170 --><p class='indent'>
</p><!-- l. 1170 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                      <mstyle class='label' id='x9-181001r57'></mstyle><!-- endlabel --><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>itH</mi></mrow></msup> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo><munderover accent='false' accentunder='false'><mrow><mo> ∑</mo>
  </mrow><mrow><mi>j</mi><mo class='MathClass-rel' stretchy='false'>=</mo><mn>0</mn></mrow><mrow><mi>∞</mi></mrow></munderover><mfrac><mrow><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>itH</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi>j</mi></mrow></msup></mrow>
     <mrow><mi>j</mi><mo class='MathClass-punc' stretchy='false'>!</mo></mrow></mfrac>
</mrow></math></td><td class='eq-no'>(7.57)</td></tr></table>
<!-- l. 1173 --><p class='indent'>   When we apply this to the expression we want, we get:
</p><!-- tex4ht:inline --><!-- l. 1177 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mtable class='align' columnalign='left' displaystyle='true'>
 <mtr><mtd class='align-odd' columnalign='right'><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi>i</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>+</mo><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mi>t</mi></mrow></msup><mspace class='nbsp' width='0.33em'></mspace></mtd> <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mi>I</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>i</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>H</mi></mrow><mrow>
<mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mi>t</mi> <mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>H</mi></mrow><mrow>
<mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mn>2</mn></mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>t</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo><mspace class='nbsp' width='0.33em'></mspace><mspace width='2em'></mspace></mtd>                  <mtd class='align-label' columnalign='right'></mtd> <mtd class='align-label'>
 <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>           <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mi>I</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>i</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo><mi>t</mi> <mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-open' stretchy='false'>(</mo><msubsup><mrow><mi>H</mi></mrow><mrow>
<mn>1</mn></mrow><mrow><mn>2</mn></mrow></msubsup> <mo class='MathClass-bin' stretchy='false'>+</mo> <msubsup><mrow><mi>H</mi></mrow><mrow>
<mn>2</mn></mrow><mrow><mn>2</mn></mrow></msubsup> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>H</mi></mrow><mrow>
<mn>1</mn></mrow></msub><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>t</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo><mspace width='2em'></mspace></mtd>  <mtd class='align-label' columnalign='right'>
<mstyle class='label' id='x9-181002r58'></mstyle><!-- endlabel --><mstyle class='maketag'><mtext>(7.58) </mtext></mstyle><mspace class='nbsp' width='0.33em'></mspace>
   </mtd></mtr></mtable></math>
<!-- l. 1178 --><p class='noindent'>Doing the same on the approximation, we get:
                                                                     

                                                                     
</p><!-- tex4ht:inline --><!-- l. 1183 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mtable class='align' columnalign='left' displaystyle='true'>
 <mtr><mtd class='align-odd' columnalign='right'><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi>i</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub><mi>t</mi></mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi>i</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><mi>t</mi></mrow></msup><mspace class='nbsp' width='0.33em'></mspace></mtd> <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-open' stretchy='false'>(</mo><mi>I</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>i</mi><msub><mrow><mi>H</mi></mrow><mrow>
<mn>1</mn></mrow></msub><mi>t</mi> <mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup><msubsup><mrow><mi>H</mi></mrow><mrow>
<mn>1</mn></mrow><mrow><mn>2</mn></mrow></msubsup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>t</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-open' stretchy='false'>(</mo><mi>I</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>i</mi><msub><mrow><mi>H</mi></mrow><mrow>
<mn>2</mn></mrow></msub><mi>t</mi> <mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup><msubsup><mrow><mi>H</mi></mrow><mrow>
<mn>2</mn></mrow><mrow><mn>2</mn></mrow></msubsup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>t</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo><mspace width='2em'></mspace></mtd> <mtd class='align-label' columnalign='right'></mtd> <mtd class='align-label'>
 <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>             <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mi>I</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi mathvariant='italic'>it</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-open' stretchy='false'>(</mo><msubsup><mrow><mi>H</mi></mrow><mrow>
<mn>1</mn></mrow><mrow><mn>2</mn></mrow></msubsup> <mo class='MathClass-bin' stretchy='false'>+</mo> <msubsup><mrow><mi>H</mi></mrow><mrow>
<mn>2</mn></mrow><mrow><mn>2</mn></mrow></msubsup><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>H</mi></mrow><mrow>
<mn>1</mn></mrow></msub><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>t</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo><mspace width='2em'></mspace></mtd>   <mtd class='align-label' columnalign='right'></mtd> <mtd class='align-label'>
 <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>             <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mi>I</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi mathvariant='italic'>it</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-open' stretchy='false'>(</mo><msubsup><mrow><mi>H</mi></mrow><mrow>
<mn>1</mn></mrow><mrow><mn>2</mn></mrow></msubsup> <mo class='MathClass-bin' stretchy='false'>+</mo> <msubsup><mrow><mi>H</mi></mrow><mrow>
<mn>2</mn></mrow><mrow><mn>2</mn></mrow></msubsup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>2</mn><msub><mrow><mi>H</mi></mrow><mrow>
<mn>1</mn></mrow></msub><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>t</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo><mspace width='2em'></mspace></mtd>      <mtd class='align-label' columnalign='right'>
<mstyle class='label' id='x9-181003r59'></mstyle><!-- endlabel --><mstyle class='maketag'><mtext>(7.59) </mtext></mstyle><mspace class='nbsp' width='0.33em'></mspace>
   </mtd></mtr></mtable></math>
<!-- l. 1184 --><p class='noindent'>where in the last step we grouped together the
<!-- l. 1184 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup></math>
terms. We see that Eqs. (<a href='#x9-181002r58'>7.58<!-- tex4ht:ref: eq:Trotter-taylor-true  --></a>) and (<a href='#x9-181003r59'>7.59<!-- tex4ht:ref: eq:Trotter-taylor-approx  --></a>) agree on the constant term and the
<!-- l. 1184 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>t</mi></math> term, but
differ on the <!-- l. 1184 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup></math>
term. Subtracting these two expressions gives:
</p><!-- tex4ht:inline --><!-- l. 1190 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mtable class='align' columnalign='left' displaystyle='true'>
   <mtr><mtd class='align-odd' columnalign='right'><mo class='MathClass-rel' stretchy='false'>∥</mo><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>+</mo><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub>
          </mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub>
</mrow></msup><mo class='MathClass-rel' stretchy='false'>∥</mo><mspace class='nbsp' width='0.33em'></mspace></mtd>   <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mo class='MathClass-rel' stretchy='false'>∥</mo><mfrac><mrow><mn>1</mn></mrow>
<mrow><mn>2</mn></mrow></mfrac><msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>H</mi></mrow><mrow>
<mn>2</mn></mrow></msub><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>−</mo> <msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>t</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>∥</mo><mspace width='2em'></mspace></mtd>      <mtd class='align-label' columnalign='right'><mstyle class='label' id='x9-181004r60'></mstyle><!-- endlabel --><mstyle class='maketag'><mtext>(7.60)</mtext></mstyle><mspace class='nbsp' width='0.33em'></mspace>
   </mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>                             <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>≤</mo><mspace class='nbsp' width='0.33em'></mspace><mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-rel' stretchy='false'>∥</mo><mo class='MathClass-open' stretchy='false'>[</mo><msub><mrow><mi>H</mi></mrow><mrow>
<mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>]</mo><mo class='MathClass-rel' stretchy='false'>∥</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>t</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-punc' stretchy='false'>.</mo><mspace width='2em'></mspace></mtd>             <mtd class='align-label' columnalign='right'><mstyle class='label' id='x9-181005r61'></mstyle><!-- endlabel --><mstyle class='maketag'><mtext>(7.61)</mtext></mstyle><mspace class='nbsp' width='0.33em'></mspace>
   </mtd></mtr></mtable></math>
<!-- l. 1191 --><p class='noindent'>As we’ve seen in Exercise <a href='#x9-172003r5'>7.5<!-- tex4ht:ref: exer:exponential-bound  --></a>, we don’t actually get the
<!-- l. 1191 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>t</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
term, and the first term in the inequality is already enough to bound
it. So if this derivation of the bound is worse, why did we do it?
Well, looking at these expansions and where they agree and disagree
tells us what we need to do to get better agreement. Looking at the
<!-- l. 1192 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup></math>
expressions in Eqs. (<a href='#x9-181002r58'>7.58<!-- tex4ht:ref: eq:Trotter-taylor-true  --></a>) and (<a href='#x9-181003r59'>7.59<!-- tex4ht:ref: eq:Trotter-taylor-approx  --></a>) we see that the
<!-- l. 1192 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup></math> terms are
                                                                     

                                                                     
respectively <!-- l. 1192 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mn>1</mn></mrow>
<mrow><mn>2</mn></mrow></mfrac><mo class='MathClass-open' stretchy='false'>(</mo><msubsup><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow><mrow><mn>2</mn></mrow></msubsup> <mo class='MathClass-bin' stretchy='false'>+</mo> <msubsup><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow><mrow><mn>2</mn></mrow></msubsup> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
and <!-- l. 1192 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mn>1</mn></mrow>
<mrow><mn>2</mn></mrow></mfrac><mo class='MathClass-open' stretchy='false'>(</mo><msubsup><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow><mrow><mn>2</mn></mrow></msubsup> <mo class='MathClass-bin' stretchy='false'>+</mo> <msubsup><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow><mrow><mn>2</mn></mrow></msubsup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>2</mn><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
So the only problem is that we get two copies of the term
<!-- l. 1192 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></math> instead of
<!-- l. 1192 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></math>. If we had
decomposed <!-- l. 1192 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></msup></mrow></math> instead
of <!-- l. 1192 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></msup></mrow></math>, then we would
have lacked the <!-- l. 1192 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></math>
term instead of the <!-- l. 1192 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></math>
term. This is pointing us towards the solution: we need to have both
<!-- l. 1192 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></msup></mrow></math> <span class='cmti-10x-x-109'>and</span>
<!-- l. 1192 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></msup></mrow></math> in
our decomposition. So let’s see what we get when we decompose the product of
these decompositions:
</p><!-- tex4ht:inline --><!-- l. 1198 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mtable class='align-star' columnalign='left' displaystyle='true'>
<mtr><mtd class='align-odd' columnalign='right'> <mrow><mo fence='true' form='prefix'>(</mo><mrow><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub>
          </mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub>
</mrow></msup></mrow><mo fence='true' form='postfix'>)</mo></mrow></mtd><mtd class='align-even'> <mrow><mo fence='true' form='prefix'>(</mo><mrow><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub>
          </mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub>
</mrow></msup></mrow><mo fence='true' form='postfix'>)</mo></mrow> <mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mi>I</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi mathvariant='italic'>it</mi><mo class='MathClass-open' stretchy='false'>(</mo><mn>2</mn><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>2</mn><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup></mrow> 
 <mrow><mn>2</mn></mrow></mfrac> <mo class='MathClass-open' stretchy='false'>(</mo><mn>2</mn><msubsup><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow><mrow><mn>2</mn></mrow></msubsup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>2</mn><msubsup><mrow><mi>H</mi></mrow><mrow>
<mn>2</mn></mrow><mrow><mn>2</mn></mrow></msubsup><mo class='MathClass-close' stretchy='false'>)</mo><mspace width='2em'></mspace></mtd>             <mtd class='align-label' columnalign='right'></mtd><mtd class='align-label'>
<mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>            <mtd class='align-even'> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-open' stretchy='false'>(</mo><mn>2</mn><msub><mrow><mi>H</mi></mrow><mrow>
<mn>1</mn></mrow></msub><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <msubsup><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow><mrow><mn>2</mn></mrow></msubsup> <mo class='MathClass-bin' stretchy='false'>+</mo> <msubsup><mrow><mi>H</mi></mrow><mrow>
<mn>2</mn></mrow><mrow><mn>2</mn></mrow></msubsup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mn>2</mn><msub><mrow><mi>H</mi></mrow><mrow>
<mn>2</mn></mrow></msub><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>t</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo><mspace width='2em'></mspace></mtd>                      <mtd class='align-label' columnalign='right'></mtd><mtd class='align-label'>
<mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>            <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mi>I</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>i</mi><mo class='MathClass-open' stretchy='false'>(</mo><mn>2</mn><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mn>2</mn><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mn>2</mn></mrow></msup></mrow> 
   <mrow><mn>2</mn></mrow></mfrac>   <mo class='MathClass-open' stretchy='false'>(</mo><msubsup><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow><mrow><mn>2</mn></mrow></msubsup> <mo class='MathClass-bin' stretchy='false'>+</mo> <msubsup><mrow><mi>H</mi></mrow><mrow>
<mn>2</mn></mrow><mrow><mn>2</mn></mrow></msubsup> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>H</mi></mrow><mrow>
<mn>1</mn></mrow></msub><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub> <mo class='MathClass-bin' stretchy='false'>+</mo> <msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>t</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-punc' stretchy='false'>.</mo><mspace width='2em'></mspace></mtd><mtd class='align-label' columnalign='right'></mtd><mtd class='align-label'>
   <mspace width='2em'></mspace></mtd></mtr></mtable></math>
<!-- l. 1199 --><p class='noindent'>Here in the last equality we suggestively grouped together the
<!-- l. 1199 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup></math> term in
terms of <!-- l. 1199 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mn>2</mn><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mn>2</mn></mrow></msup></math>.
We see that in this case we get the correct
<!-- l. 1199 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup></math> term from Eq. (<a href='#x9-181002r58'>7.58<!-- tex4ht:ref: eq:Trotter-taylor-true  --></a>).
So replacing <!-- l. 1199 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>t</mi></math>
by <!-- l. 1199 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mfrac><mrow><mn>1</mn></mrow>
<mrow><mn>2</mn></mrow></mfrac><mi>t</mi></mrow></math> to
ensure we get the correct constants, we see that: </p><table class='equation'><tr><td>
<!-- l. 1200 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 1200 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
              <mstyle class='label' id='x9-181006r62'></mstyle><!-- endlabel --><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>+</mo><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><mn>1</mn></mrow>
<mrow><mn>2</mn></mrow></mfrac><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub>
            </mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub>
          </mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><mn>1</mn></mrow>
<mrow><mn>2</mn></mrow></mfrac><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub>
</mrow></msup> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>t</mi></mrow><mrow><mn>3</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-punc' stretchy='false'>.</mo>
</mrow></math></td><td class='eq-no'>(7.62)</td></tr></table>
   <div class='newtheorem'>
<!-- l. 1203 --><p class='noindent'><span class='head'>
<a id='x9-181007r9'></a>
<span class='cmbx-10x-x-109'>Exercise* 7.9.</span>  </span>In this exercise we will find a way to lift Eq. (<a href='#x9-181006r62'>7.62<!-- tex4ht:ref: eq:Trotter-second-order-basic  --></a>) to a full-fledged
procedure for Hamiltonian simulation. Our goal is to find an approximation of
<!-- l. 1204 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>itH</mi></mrow></msup></math> where
<!-- l. 1204 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>H</mi> <mo class='MathClass-rel' stretchy='false'>=</mo><msubsup><mrow> <mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>j</mi><mo class='MathClass-rel' stretchy='false'>=</mo><mn>1</mn></mrow><mrow><mi>l</mi></mrow></msubsup><msub><mrow><mi>H</mi></mrow><mrow><mi>j</mi></mrow></msub></mrow></math> and we
have <!-- l. 1204 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>∥</mo><msub><mrow><mi>H</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>∥</mo><mo class='MathClass-rel' stretchy='false'>≤</mo> <mn>1</mn></mrow></math> for
all <!-- l. 1204 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>H</mi></mrow><mrow><mi>j</mi></mrow></msub></math>.
   </p><dl class='enumerate'><dt class='enumerate'>
a) </dt><dd class='enumerate'>
   <!-- l. 1206 --><p class='noindent'>Calculate the difference <!-- l. 1206 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>+</mo><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo> <msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><mn>1</mn></mrow>
<mrow><mn>2</mn></mrow></mfrac><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><mn>1</mn></mrow>
<mrow><mn>2</mn></mrow></mfrac><mi mathvariant='italic'>it</mi></mrow></msup></mrow></math>
   up to <!-- l. 1206 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>t</mi></mrow><mrow><mn>4</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
   terms. I.e. calculate the <!-- l. 1206 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>t</mi></mrow><mrow><mn>3</mn></mrow></msup></math>
   term of this difference.
   </p></dd><dt class='enumerate'>
b) </dt><dd class='enumerate'>
   <!-- l. 1207 --><p class='noindent'>Express this difference in terms of (nested) commutators like <!-- l. 1207 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-open' stretchy='false'>[</mo><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo class='MathClass-open' stretchy='false'>[</mo><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>]</mo><mo class='MathClass-close' stretchy='false'>]</mo></mrow></math>
   and give an inequality of the difference in norm.
   </p></dd><dt class='enumerate'>
c) </dt><dd class='enumerate'>
   <!-- l. 1208 --><p class='noindent'>Let <!-- l. 1208 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mstyle mathvariant='script'><mi>S</mi></mstyle></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-open' stretchy='false'>{</mo><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>H</mi></mrow><mrow><mi>l</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>}</mo><mo class='MathClass-punc' stretchy='false'>,</mo><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-punc' stretchy='false'>:</mo><mo class='MathClass-rel' stretchy='false'>=</mo> <msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><mn>1</mn></mrow>
<mrow><mn>2</mn></mrow></mfrac><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></msup><mo class='MathClass-rel' stretchy='false'>⋯</mo><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><mn>1</mn></mrow>
<mrow><mn>2</mn></mrow></mfrac><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mi>l</mi></mrow></msub></mrow></msup><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><mn>1</mn></mrow>
<mrow><mn>2</mn></mrow></mfrac><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mi>l</mi></mrow></msub></mrow></msup><mo class='MathClass-rel' stretchy='false'>⋯</mo><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mfrac><mrow><mn>1</mn></mrow>
<mrow><mn>2</mn></mrow></mfrac><mi mathvariant='italic'>it</mi><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></msup></mrow></math>.
   Give an upper bound on </p><table class='equation-star'><tr><td>
                                                                     

                                                                     
   <!-- l. 1209 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                                <mo class='MathClass-rel' stretchy='false'>∥</mo><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><munderover accent='false' accentunder='false'><mrow><mo>∑</mo>
  </mrow><mrow><mi>j</mi></mrow><mrow><mi>l</mi></mrow></munderover><msub><mrow><mi>H</mi></mrow><mrow><mi>j</mi></mrow></msub>
              </mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo><msub><mrow><mstyle mathvariant='script'><mi>S</mi></mstyle></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-open' stretchy='false'>{</mo><msub><mrow><mi>H</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>}</mo><mo class='MathClass-punc' stretchy='false'>,</mo><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-rel' stretchy='false'>∥</mo>
</mrow></math></td></tr></table>
   <!-- l. 1210 --><p class='noindent'>which depends on <!-- l. 1210 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>t</mi></mrow><mrow><mn>3</mn></mrow></msup></math>
   (while ignoring the <!-- l. 1210 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>t</mi></mrow><mrow><mn>4</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
   terms).
   </p></dd><dt class='enumerate'>
d) </dt><dd class='enumerate'>
   <!-- l. 1211 --><p class='noindent'>Give an upper bound to the difference in norm of <!-- l. 1211 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>∥</mo><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><msubsup><mrow><mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>j</mi></mrow><mrow><mi>l</mi></mrow></msubsup><msub><mrow><mi>H</mi></mrow><mrow><mi>j</mi></mrow></msub></mrow></msup> <mo class='MathClass-bin' stretchy='false'>−</mo><msub><mrow><mstyle mathvariant='script'><mi>S</mi></mstyle></mrow><mrow><mn>2</mn></mrow></msub><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-open' stretchy='false'>{</mo><msub><mrow><mi>H</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>}</mo><mo class='MathClass-punc' stretchy='false'>,</mo> <mfrac><mrow><mi>t</mi></mrow> 
<mrow><mi>n</mi></mrow></mfrac><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi>n</mi></mrow></msup><mo class='MathClass-rel' stretchy='false'>∥</mo></mrow></math>
   and use this to show that if we want to make this difference smaller than
   <!-- l. 1211 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>𝜀</mi></math>,
   that we can then choose <!-- l. 1211 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>t</mi></mrow><mrow><mn>3</mn><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn></mrow></msup><msup><mrow><mi>l</mi></mrow><mrow><mn>3</mn><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn></mrow></msup><mo class='MathClass-bin' stretchy='false'>∕</mo><msup><mrow><mi>𝜀</mi></mrow><mrow><mn>1</mn><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>2</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
   </p></dd></dl>
   </div>
<!-- l. 1213 --><p class='indent'>    This approach is known as <span class='cmbx-10x-x-109'>second-order Trotterization</span>. It is called second order
because it recovers <!-- l. 1214 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-bin' stretchy='false'>+</mo><msub><mrow><mi>H</mi></mrow><mrow><mn>2</mn></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo></mrow></msup></math>
correctly up to the second order. It is possible to generalise this technique to
<!-- l. 1214 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>th order. This
involves a map <!-- l. 1214 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mstyle mathvariant='script'><mi>S</mi></mstyle></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-open' stretchy='false'>{</mo><msub><mrow><mi>H</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>}</mo><mo class='MathClass-punc' stretchy='false'>,</mo><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> that
approximates <!-- l. 1214 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><msub><mrow><mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>j</mi></mrow></msub><msub><mrow><mi>H</mi></mrow><mrow><mi>j</mi></mrow></msub></mrow></msup></math> up to a
<!-- l. 1214 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>t</mi></mrow><mrow><mi>k</mi><mo class='MathClass-bin' stretchy='false'>+</mo><mn>1</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> error. To approximate
it up to an error <!-- l. 1214 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>𝜀</mi></math>
we then split <!-- l. 1214 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>t</mi></math>
up into <!-- l. 1214 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>n</mi></math> pieces
where <!-- l. 1214 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mi mathvariant='italic'>tl</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mn>1</mn><mo class='MathClass-bin' stretchy='false'>+</mo><mn>1</mn><mo class='MathClass-bin' stretchy='false'>∕</mo><mi>k</mi></mrow></msup><msup><mrow><mi>𝜀</mi></mrow><mrow><mn>1</mn><mo class='MathClass-bin' stretchy='false'>∕</mo><mi>k</mi></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>.
While this looks like it is then better to use higher and higher-order
Trotterisations, there are some hidden constants here: the number of terms in
<!-- l. 1214 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mstyle mathvariant='script'><mi>S</mi></mstyle></mrow><mrow><mi>k</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-open' stretchy='false'>{</mo><msub><mrow><mi>H</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>}</mo><mo class='MathClass-punc' stretchy='false'>,</mo><mi>t</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math> scales
exponentially with <!-- l. 1214 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>k</mi></math>.
As a result it is often not beneficial to go beyond
<!-- l. 1214 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>2</mn></mrow></math>, and essentially
never to go beyond <!-- l. 1214 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>8</mn></mrow></math>.
</p>
   <h4 class='subsectionHead' id='randomised-compiling'><span class='titlemark'>7.8.3   </span> <a id='x9-1820007.8.3'></a>Randomised compiling*</h4>
<!-- l. 1216 --><p class='noindent'>It turns out that if we want to approximate a unitary we can also do
                                                                     

                                                                     
this using an ensemble of, somewhat randomly chosen, unitaries instead
of just a single approximating unitary. This turns out to have several
benefits. Let’s see how this could work. Let’s again consider a Hamiltonian
<!-- l. 1217 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>H</mi> <mo class='MathClass-rel' stretchy='false'>=</mo><msubsup><mrow> <mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>j</mi></mrow><mrow><mi>l</mi></mrow></msubsup><msub><mrow><mi>λ</mi></mrow><mrow><mi>j</mi></mrow></msub><msub><mrow><mi>H</mi></mrow><mrow><mi>j</mi></mrow></msub></mrow></math>. Here we choose the
decomposition of <!-- l. 1217 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math>
such that <!-- l. 1217 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>λ</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mn>0</mn></mrow></math>
and <!-- l. 1217 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>∥</mo><msub><mrow><mi>H</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>∥</mo> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math> for all
<!-- l. 1217 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>j</mi></math>. Then the unitary channel
corresponding to a <!-- l. 1217 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mn>1</mn><mo class='MathClass-bin' stretchy='false'>∕</mo><mi>n</mi></mrow></math>
fraction of the total time evolution is
</p><!-- tex4ht:inline --><!-- l. 1221 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mtable class='align' columnalign='left' displaystyle='true'>
         <mtr><mtd class='align-odd' columnalign='right'><msub><mrow><mstyle mathvariant='script'><mi>U</mi></mstyle></mrow><mrow><mi>n</mi></mrow></msub><mo class='MathClass-open' stretchy='false'>(</mo><mi>ρ</mi><mo class='MathClass-close' stretchy='false'>)</mo><mspace class='nbsp' width='0.33em'></mspace></mtd>         <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi> <mfrac><mrow><mi>t</mi></mrow>
<mrow><mi>n</mi></mrow></mfrac><mi>H</mi></mrow></msup><mi>ρ</mi><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi>i</mi> <mfrac><mrow><mi>t</mi></mrow>
<mrow><mi>n</mi></mrow></mfrac><mi>H</mi></mrow></msup><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mi>ρ</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>i</mi> <mfrac><mrow><mi>t</mi></mrow>
<mrow><mi>n</mi></mrow></mfrac><mo class='MathClass-open' stretchy='false'>(</mo><mi mathvariant='italic'>Hρ</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi mathvariant='italic'>ρH</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>O</mi> <mrow><mo fence='true' form='prefix'>(</mo><mrow> <mfrac><mrow><msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup></mrow>
<mrow><msup><mrow><mi>n</mi></mrow><mrow><mn>2</mn></mrow></msup></mrow></mfrac> </mrow><mo fence='true' form='postfix'>)</mo></mrow><mspace width='2em'></mspace></mtd>         <mtd class='align-label' columnalign='right'></mtd>         <mtd class='align-label'>
         <mspace width='2em'></mspace></mtd></mtr><mtr><mtd class='align-odd' columnalign='right'></mtd>              <mtd class='align-even'> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mi>ρ</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>i</mi><munder class='msub'><mrow><mo>∑</mo>
   </mrow><mrow><mi>j</mi></mrow></munder><mfrac><mrow><mi>t</mi><msub><mrow><mi>h</mi></mrow><mrow><mi>j</mi></mrow></msub></mrow> 
 <mrow><mi>n</mi></mrow></mfrac> <mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>H</mi></mrow><mrow><mi>j</mi></mrow></msub><mi>ρ</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi>ρ</mi><msub><mrow><mi>H</mi></mrow><mrow><mi>j</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>O</mi> <mrow><mo fence='true' form='prefix'>(</mo><mrow> <mfrac><mrow><msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup></mrow>
<mrow><msup><mrow><mi>n</mi></mrow><mrow><mn>2</mn></mrow></msup></mrow></mfrac> </mrow><mo fence='true' form='postfix'>)</mo></mrow> <mo class='MathClass-punc' stretchy='false'>.</mo><mspace width='2em'></mspace></mtd>                       <mtd class='align-label' columnalign='right'><mstyle class='label' id='x9-182001r63'></mstyle><!-- endlabel --><mstyle class='maketag'><mtext>(7.63)</mtext></mstyle><mspace class='nbsp' width='0.33em'></mspace>
   </mtd></mtr></mtable></math>
<!-- l. 1222 --><p class='noindent'>We see that up to some error term, this unitary channel can be
written as a sum over some expression involving just a single
<!-- l. 1222 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>H</mi></mrow><mrow><mi>j</mi></mrow></msub></math>. This
suggests we should be able to find a probabilistic channel that can approximate
<!-- l. 1222 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mstyle mathvariant='script'><mi>U</mi></mstyle></mrow><mrow><mi>n</mi></mrow></msub></math>, just by sampling
from <!-- l. 1222 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>H</mi></mrow><mrow><mi>j</mi></mrow></msub></math>. Let’s give this
a try. Let’s define <!-- l. 1222 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle mathvariant='script'><mi>E</mi></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mi>ρ</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow> <mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>j</mi></mrow></msub><msub><mrow><mi>p</mi></mrow><mrow><mi>j</mi></mrow></msub><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>iτ</mi><msub><mrow><mi>H</mi></mrow><mrow><mi>j</mi></mrow></msub></mrow></msup><mi>ρ</mi><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>iτ</mi><msub><mrow><mi>H</mi></mrow><mrow><mi>j</mi></mrow></msub></mrow></msup></mrow></math>.
Here <!-- l. 1222 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>p</mi></mrow><mrow><mi>j</mi></mrow></msub></math>
is some probability distribution over the terms
<!-- l. 1222 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>H</mi></mrow><mrow><mn>1</mn></mrow></msub><mo class='MathClass-punc' stretchy='false'>,</mo><mo>…</mo><mo class='MathClass-punc' stretchy='false'>,</mo><msub><mrow><mi>H</mi></mrow><mrow><mi>l</mi></mrow></msub></mrow></math>, and
<!-- l. 1222 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>τ</mi></math> is some
fixed number that we will try to determine later. Now let’s see what happens when we
expand <!-- l. 1223 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mstyle mathvariant='script'><mi>E</mi></mstyle></math> in
terms of <!-- l. 1223 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>τ</mi></math>:
</p><table class='equation'><tr><td>
<!-- l. 1224 --><p class='indent'>
                                                                     

                                                                     
</p><!-- l. 1224 --><math class='equation' display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
               <mstyle class='label' id='x9-182002r64'></mstyle><!-- endlabel --><mstyle mathvariant='script'><mi>E</mi></mstyle><mo class='MathClass-open' stretchy='false'>(</mo><mi>ρ</mi><mo class='MathClass-close' stretchy='false'>)</mo><mspace class='nbsp' width='0.33em'></mspace> <mo class='MathClass-rel' stretchy='false'>=</mo> <mspace class='nbsp' width='0.33em'></mspace><mi>ρ</mi> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>i</mi><munder class='msub'><mrow><mo>∑</mo>
   </mrow><mrow><mi>j</mi></mrow></munder><msub><mrow><mi>p</mi></mrow><mrow><mi>j</mi></mrow></msub><mi>τ</mi><mo class='MathClass-open' stretchy='false'>(</mo><msub><mrow><mi>H</mi></mrow><mrow><mi>j</mi></mrow></msub><mi>ρ</mi> <mo class='MathClass-bin' stretchy='false'>−</mo> <mi mathvariant='italic'>ρH</mi><mo class='MathClass-close' stretchy='false'>)</mo> <mo class='MathClass-bin' stretchy='false'>+</mo> <mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>τ</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-close' stretchy='false'>)</mo>
</mrow></math></td><td class='eq-no'>(7.64)</td></tr></table>
<!-- l. 1227 --><p class='indent'>   We see that this matches the expansion in Eq. (<a href='#x9-182001r63'>7.63<!-- tex4ht:ref: eq:QDRIFT-unitary  --></a>) when we have
<!-- l. 1227 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>p</mi></mrow><mrow><mi>j</mi></mrow></msub><mi>τ</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <msub><mrow><mi>h</mi></mrow><mrow><mi>j</mi></mrow></msub> <mfrac><mrow><mi>t</mi></mrow> 
<mrow><mi>n</mi></mrow></mfrac></mrow></math>. Since the
<!-- l. 1227 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>p</mi></mrow><mrow><mi>j</mi></mrow></msub></math> must form a probability
distribution, we have <!-- l. 1227 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>j</mi></mrow></msub><msub><mrow><mi>p</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math>,
and hence
<!-- tex4ht:inline --></p><!-- l. 1228 --><math display='block' xmlns='http://www.w3.org/1998/Math/MathML'><mrow>
                    <mi>τ</mi> <mo class='MathClass-rel' stretchy='false'>=</mo><munder class='msub'><mrow><mo> ∑</mo>
   </mrow><mrow><mi>j</mi></mrow></munder><msub><mrow><mi>p</mi></mrow><mrow><mi>j</mi></mrow></msub><mi>τ</mi> <mo class='MathClass-rel' stretchy='false'>=</mo><munder class='msub'><mrow><mo> ∑</mo>
   </mrow><mrow><mi>j</mi></mrow></munder><msub><mrow><mi>h</mi></mrow><mrow><mi>j</mi></mrow></msub> <mfrac><mrow><mi>t</mi></mrow> 
<mrow><mi>n</mi></mrow></mfrac> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi mathvariant='normal'>Λ</mi> <mfrac><mrow><mi>t</mi></mrow>
<mrow><mi>n</mi></mrow></mfrac><mo class='MathClass-punc' stretchy='false'>,</mo>
</mrow></math>
<!-- l. 1228 --><p class='nopar'> where we have set <!-- l. 1229 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='normal'>Λ</mi> <mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow> <mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>j</mi></mrow></msub><msub><mrow><mi>h</mi></mrow><mrow><mi>j</mi></mrow></msub></mrow></math>.
Then solving for <!-- l. 1229 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>p</mi></mrow><mrow><mi>j</mi></mrow></msub></math>
we get <!-- l. 1229 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>p</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mfrac><mrow><msub><mrow><mi>h</mi></mrow><mrow><mi>j</mi></mrow></msub></mrow> 
 <mrow><mi mathvariant='normal'>Λ</mi></mrow></mfrac> </mrow></math>.
This means we can approximate the unitary channel
<!-- l. 1230 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mstyle mathvariant='script'><mi>U</mi></mstyle></mrow><mrow><mi>n</mi></mrow></msub></math> up to a
second order <!-- l. 1230 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo> <mfrac><mrow><msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup></mrow>
<mrow><msup><mrow><mi>n</mi></mrow><mrow><mn>2</mn></mrow></msup></mrow></mfrac><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
error using a channel that is a probabilistic combination of
unitaries, each of which is just a single simple conjugation with
<!-- l. 1230 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>iτ</mi><msub><mrow><mi>H</mi></mrow><mrow><mi>j</mi></mrow></msub></mrow></msup></math>, as long as
we choose <!-- l. 1230 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>τ</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi mathvariant='normal'>Λ</mi> <mfrac><mrow><mi>t</mi></mrow>
<mrow><mi>n</mi></mrow></mfrac></mrow></math>
and <!-- l. 1230 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>p</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mfrac><mrow><msub><mrow><mi>h</mi></mrow><mrow><mi>j</mi></mrow></msub></mrow> 
 <mrow><mi mathvariant='normal'>Λ</mi></mrow></mfrac> </mrow></math>. Here
<!-- l. 1230 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='normal'>Λ</mi></math> is the sum of all
the weights <!-- l. 1230 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>h</mi></mrow><mrow><mi>j</mi></mrow></msub></math> of the
sub-Hamiltonians <!-- l. 1230 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>H</mi></mrow><mrow><mi>j</mi></mrow></msub></math>.
But of course, we don’t want to approximate
<!-- l. 1231 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mstyle mathvariant='script'><mi>U</mi></mstyle></mrow><mrow><mi>n</mi></mrow></msub></math>, but
<!-- l. 1231 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msubsup><mrow><mstyle mathvariant='script'><mi>U</mi></mstyle></mrow><mrow><mi>n</mi></mrow><mrow><mi>n</mi></mrow></msubsup></math>.
Using a similar type of analysis as we have done before (but adapted to work
                                                                     

                                                                     
with channels instead of unitaries), we can show that we can approximate
<!-- l. 1231 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msubsup><mrow><mstyle mathvariant='script'><mi>U</mi></mstyle></mrow><mrow><mi>n</mi></mrow><mrow><mi>n</mi></mrow></msubsup></math> with
<!-- l. 1231 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mstyle mathvariant='script'><mi>E</mi></mstyle></mrow><mrow><mi>n</mi></mrow></msup></math> up to an
error <!-- l. 1231 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>𝜀</mi></math>, by
choosing <!-- l. 1231 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mn>2</mn><msup><mrow><mi mathvariant='normal'>Λ</mi></mrow><mrow><mn>2</mn></mrow></msup><msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-bin' stretchy='false'>∕</mo><mi>𝜀</mi></mrow></math>.
This is interesting because the amount of terms we need does not depend on
<!-- l. 1232 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>l</mi></math>, the amount of
terms in <!-- l. 1232 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>H</mi></math>, but
rather on <!-- l. 1232 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='normal'>Λ</mi></math>, the
sum of the weights of the terms. This method hence works better than the non-randomised
technique when <!-- l. 1232 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>l</mi></math>
is large, but <!-- l. 1232 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi mathvariant='normal'>Λ</mi></math>
is not so large. But even in the worst case, when we have
<!-- l. 1232 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi mathvariant='normal'>Λ</mi> <mo class='MathClass-rel' stretchy='false'>=</mo> <mi>l</mi></mrow></math> (this is
when <!-- l. 1232 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>λ</mi></mrow><mrow><mi>j</mi></mrow></msub> <mo class='MathClass-rel' stretchy='false'>=</mo> <mn>1</mn></mrow></math> for
all <!-- l. 1232 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>j</mi></math>), the
scaling is <!-- l. 1232 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mn>2</mn><msup><mrow><mi>l</mi></mrow><mrow><mn>2</mn></mrow></msup><msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-bin' stretchy='false'>∕</mo><mi>𝜀</mi></mrow></math>,
which is still better than the non-randomised version: recall that we got
<!-- l. 1232 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>n</mi> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mfrac><mrow><mn>1</mn></mrow> 
<mrow><mn>2</mn></mrow></mfrac><msup><mrow><mi>l</mi></mrow><mrow><mn>2</mn></mrow></msup><msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-bin' stretchy='false'>∕</mo><mi>𝜀</mi></mrow></math>. But additionally, each
iteration required every <!-- l. 1232 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><msub><mrow><mi>λ</mi></mrow><mrow><mi>j</mi></mrow></msub><msub><mrow><mi>H</mi></mrow><mrow><mi>j</mi></mrow></msub></mrow></msup></math>
to be placed, so that each iteration consists of
<!-- l. 1232 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>l</mi></math> term, giving a total
gate count scaling of <!-- l. 1232 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>l</mi></mrow><mrow><mn>3</mn></mrow></msup><msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-bin' stretchy='false'>∕</mo><mi>𝜀</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>,
instead of <!-- l. 1232 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><msup><mrow><mi>l</mi></mrow><mrow><mn>2</mn></mrow></msup><msup><mrow><mi>t</mi></mrow><mrow><mn>2</mn></mrow></msup><mo class='MathClass-bin' stretchy='false'>∕</mo><mi>𝜀</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
in the randomised case.
</p>
   <div class='newtheorem'>
<!-- l. 1233 --><p class='noindent'><span class='head'>
<a id='x9-182003r2'></a>
<span class='cmbx-10x-x-109'>Remark 7.8.2.</span>  </span>You might find it very weird or counter-intuitive that we
could approximate a specific unitary by creating an ensemble of random
‘bad’ approximations. However, remember that at the end of a quantum
circuit we need to do measurements, and that our output, the only thing
we  can  really  ‘see’,  is  just  a  probability  distribution  over  measurement
outcomes.  So  the  only  thing  we  need  for  something  to  approximate  a
quantum circuit well, is for all the measurement outcomes to follow the
correct probability distribution. So even though every single run of this
protocol might not be a good approximation to the unitary, because we use
a different one for every run of measurement, the errors can cancel out. We
will see a similar idea explored in Section <a href='main_htmlch10.html#computational-universality-via-catalysis'>10.5.2<!-- tex4ht:ref: sec:comp-universal  --></a>.
</p>
                                                                     

                                                                     
   </div>
<!-- l. 1235 --><p class='indent'>    This technique here is a variation on Trotterisation.
There are however also other techniques that can approximate
<!-- l. 1236 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mo class='MathClass-bin' stretchy='false'>−</mo><mi mathvariant='italic'>it</mi><msub><mrow><mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>j</mi></mrow></msub><msub><mrow><mi>H</mi></mrow><mrow><mi>j</mi></mrow></msub></mrow></msup></math> in
quite a different way that also result in very favourable scaling. See the
References of this chapter for more on this.
</p>
   <h3 class='sectionHead' id='references-and-further-reading5'><span class='titlemark'>7.9   </span> <a id='x9-1830007.9'></a>References and further reading</h3>
<!-- l. 1238 --><p class='noindent'><span class='paragraphHead' id='pathsums'><a id='x9-184000'></a><span class='cmbx-10x-x-109'>Path-sums</span></span>
   It is hard to pinpoint the earliest appearance of phase polynomials and/or
path-sum techniques in the literature, since essentially any computation involving
Dirac notation and summations is, in some sense, a path-sum calculation. A
notable feature of such a calculation is that it makes it clear that one doesn’t
need exponential space to compute a single amplitude of a state vector prepared
using a polynomial-sized quantum circuit. This insight plays an important role in
proving some of the first complexity bounds for quantum computation, as in
e.g. [<a href='main_htmlli2.html#Xbqp'>29</a>], [<a href='main_htmlli2.html#Xadleman1997quantum'>3</a>], and [<a href='main_htmlli2.html#Xfortnow1999complexity'>97</a>]. The “wire labelling” trick that we used for computing
phase polynomials in Section <a href='#phase-polynomials'>7.1.1<!-- tex4ht:ref: sec:phase-polys  --></a> seems to first appear in the work of [<a href='main_htmlli2.html#Xdawson2005quantum'>72</a>],
under the name <span class='cmbx-10x-x-109'>annotated circuits</span>. The authors use this technique to show
that sum-over-path expressions can be efficiently computed from circuits over a
universal gate set (in their case Toffoli+Hadamard), yielding a simple way to
relate quantum circuit simulation to counting problems involving boolean
polynomials. This was used to give a simplified proof of the inclusion
<!-- l. 1240 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mstyle class='text'><mtext class='textbf' mathvariant='bold'>BQP</mtext></mstyle> <mo class='MathClass-rel' stretchy='false'>⊆</mo><msup><mrow><mstyle class='text'><mtext class='textbf' mathvariant='bold'>P</mtext></mstyle></mrow><mrow><mstyle class='text'><mtext class='textbf' mathvariant='bold'>P</mtext></mstyle><mi>♯</mi></mrow></msup> <mo class='MathClass-rel' stretchy='false'>⊆</mo><mstyle class='text'><mtext class='textbf' mathvariant='bold'>PSPACE</mtext></mstyle></mrow></math>
of [<a href='main_htmlli2.html#Xbqp'>29</a>].
</p>
<!-- l. 1241 --><p class='noindent'><span class='paragraphHead' id='optimisation-with-phase-polynomials'><a id='x9-185000'></a><span class='cmbx-10x-x-109'>Optimisation with phase polynomials</span></span>
   Dawson <span class='cmti-10x-x-109'>et al. </span>only consider phase-polynomial expressions of the form
<!-- l. 1242 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mn>1</mn><mo class='MathClass-close' stretchy='false'>)</mo></mrow><mrow><mi>f</mi></mrow></msup></math> for
<!-- l. 1242 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>f</mi> <mo class='MathClass-punc' stretchy='false'>:</mo> <msubsup><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow><mrow><mi>m</mi></mrow></msubsup> <mo class='MathClass-rel' stretchy='false'>→</mo> <msub><mrow><mi>𝔽</mi></mrow><mrow><mn>2</mn></mrow></msub></mrow></math> a
boolean polynomial. More general expressions that can capture T-like phases (i.e.
<!-- l. 1242 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi>i</mi><mfrac><mrow><mi>π</mi></mrow>
<mrow><mn>4</mn></mrow></mfrac> <mo class='MathClass-bin' stretchy='false'>⋅</mo><mi>f</mi></mrow></msup></math>) were
used by [<a href='main_htmlli2.html#Xamy2013meet'>15</a>] to represent CNOT+T circuits and synthesise exact depth-optimal
circuits for low numbers of qubits. The first algorithm to use phase polynomials
to efficiently optimise large circuits was T-par [<a href='main_htmlli2.html#Xamy2014polynomial'>14</a>], which used the phase
polynomial representation and matroid partitioning to reduce T-depth.
The circuit synthesis algorithm we gave in Section <a href='#synthesis-from-phase-polynomials'>7.2.1<!-- tex4ht:ref: sec:synth-gauss  --></a> is essentially a
simplified version of this technique. Subsequently, phase polynomials were
                                                                     

                                                                     
used extensively in circuit optimisation. These essentially fall into two
categories: those that are agnostic to the particular values of non-Clifford
phases, such as ‘phase folding’ and parity network optimisation, and
those that rely on phases taking particular values such as multiples of
<!-- l. 1242 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>π</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><mn>4</mn></mrow></math> (or more
generally <!-- l. 1242 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>π</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><msup><mrow><mn>2</mn></mrow><mrow><mi>k</mi></mrow></msup></mrow></math>
for <!-- l. 1242 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>k</mi> <mo class='MathClass-rel' stretchy='false'>≥</mo> <mn>2</mn></mrow></math>).
We will discuss the latter kinds of optimisations in more detail in Chapter <a href='main_htmlch10.html#cliffordt'>10<!-- tex4ht:ref: ch:clifford-t  --></a>.
Good overviews of phase-polynomial-based synthesis and optimisation
methods can be found in the PhD theses of [<a href='main_htmlli2.html#Xamy2019thesis'>11</a>] and [<a href='main_htmlli2.html#Xgoubault2020thesis'>116</a>]. There are
also techniques for constructing a circuit from a phase-polynomial that
takes into account hardware constraints on two-qubit interactions, see for
instance [<a href='main_htmlli2.html#Xmeijer-vandegriend2023architectureaware'>173</a>].
</p>
<!-- l. 1243 --><p class='noindent'><span class='paragraphHead' id='phase-gadgets-and-pauli-gadgets'><a id='x9-186000'></a><span class='cmbx-10x-x-109'>Phase gadgets and Pauli gadgets</span></span>
   A unitary <!-- l. 1244 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi class='qopname'>exp</mi><mo> ⁡<!-- FUNCTION APPLICATION --> </mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><mo class='MathClass-bin' stretchy='false'>−</mo><mi>i</mi><mfrac><mrow><mi>α</mi></mrow>
<mrow><mn>2</mn></mrow></mfrac> <mi>Z</mi> <mo class='MathClass-bin' stretchy='false'>⊗</mo> <mi>Z</mi><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
is sometimes called an <span class='cmti-10x-x-109'>Ising-type interaction </span>and is (up to a global basis change)
the unitary that is implemented by the natural 2-qubit interaction in ion
trap quantum computers, the <span class='cmti-10x-x-109'>Mølmer-Sørensen interaction</span> [<a href='main_htmlli2.html#Xmolmersorensen1999'>215</a>]. The
diagrammatic form of this expression was first given in [<a href='main_htmlli2.html#Xkissinger2017MBQC'>145</a>], and it was
called a <span class='cmti-10x-x-109'>phase gadget </span>for the first time in [<a href='main_htmlli2.html#Xkissinger2019tcount'>147</a>], where the optimisation
routine of Section <a href='#simplifying-universal-diagrams'>7.6<!-- tex4ht:ref: sec:simp-universal  --></a> is from. The compilation of an arbitrary circuit to a
series of Pauli exponentials followed by a Clifford circuit is described
in [<a href='main_htmlli2.html#XLitinski2019gameofsurfacecodes'>164</a>], where it is used to argue that a simple set of fault-tolerant
operations on the surface code that correspond to Pauli exponentials
is sufficient for implementing any computation. For more about how
this works, see Chapter <a href='main_htmlch11.html#quantum-error-correction'>11<!-- tex4ht:ref: ch:qec  --></a> The original form of Pauli exponentials as
ZX-diagrams was given in [<a href='main_htmlli2.html#XphaseGadgetSynth'>64</a>]. The observation that we get a unitary out of
a measurement box if we plug in a Z-spider, but get a projector if we
plug in an X-spider, can be explained in an abstract way as a duality
between measurements and observables that occurs for any pair of strongly
complementary observables [<a href='main_htmlli2.html#Xgogioso_LIPIcs_2019_11447'>110</a>].
</p>
<!-- l. 1247 --><p class='noindent'><span class='paragraphHead' id='trotter-decompositions'><a id='x9-187000'></a><span class='cmbx-10x-x-109'>Trotter decompositions</span></span>
   Trotterisation is named after H. F. Trotter, for the techniques he found
in [<a href='main_htmlli2.html#Xtrotter1959product'>221</a>]. Masuo Suzuki studied these decompositions in a series of papers,
culminating in the definition of higher-order Trotterisations that are now also
called Suzuki-Trotter decompositions [<a href='main_htmlli2.html#Xsuzuki1991general'>219</a>]. The result from Lie theory that any
basis of the Lie algebra generates the connected part of its Lie group can for
instance be found in [<a href='main_htmlli2.html#Xhall2013lie'>124</a>, Corollary 3.47]. The randomised Trotterisation
technique is known as QDRIFT and was developed by Earl [<a href='main_htmlli2.html#XCambell2019RandomCompiler'>47</a>]. The current
                                                                     

                                                                     
state-of-the-art higher-order Trotter decompositions are given in [<a href='main_htmlli2.html#Xmorales_greatly_2022'>183</a>],
where they find some settings wherein an 8th order decomposition is the
best possible for some realistic Hamiltonians. The bound on the error of
Hamiltonian approximations of Exercise* <a href='#x9-172003r5'>7.5<!-- tex4ht:ref: exer:exponential-bound  --></a> is from [<a href='main_htmlli2.html#XGluza2024doublebracket'>109</a>, Appendix
A]
</p>
<!-- l. 1250 --><p class='noindent'><span class='paragraphHead' id='other-techniques-for-hamiltonian-simulation'><a id='x9-188000'></a><span class='cmbx-10x-x-109'>Other techniques for Hamiltonian simulation</span></span>
   Instead of using Suzuki-Trotter decompositions, there are a couple of other
techniques that can be used to do Hamiltonian simulation. There is the technique
of <span class='cmbx-10x-x-109'>linear combination of unitaries </span>(LCU). This gives an approach
to approximately and with some probability implement a linear map
<!-- l. 1252 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math> where
<!-- l. 1252 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math> is given as a sum
of unitaries <!-- l. 1252 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>M</mi> <mo class='MathClass-rel' stretchy='false'>=</mo><msubsup><mrow> <mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>j</mi></mrow><mrow><mi>m</mi></mrow></msubsup><msub><mrow><mi>α</mi></mrow><mrow><mi>j</mi></mrow></msub><msub><mrow><mi>V</mi> </mrow><mrow><mi>j</mi></mrow></msub></mrow></math> [<a href='main_htmlli2.html#XBerry2015Simulating'>30</a>].
This technique works as long as we can implement a controlled version of the
<!-- l. 1252 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>V</mi> </mrow><mrow><mi>j</mi></mrow></msub></math>,
and is efficient when these implementations are efficient and
<!-- l. 1252 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>m</mi></math> is not too large.
As long as <!-- l. 1252 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>M</mi></math>
is close to being unitary itself, this technique succeeds with high probability. To use
this for Hamiltonian simulation we realise that by cutting off the Taylor expansion
of <!-- l. 1252 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msup><mrow><mi>e</mi></mrow><mrow><mi mathvariant='italic'>it</mi><msub><mrow><mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>j</mi></mrow></msub><msub><mrow><mi>H</mi></mrow><mrow><mi>j</mi></mrow></msub></mrow></msup></math>
at a certain order, that we get a linear combination of products
<!-- l. 1252 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi>H</mi></mrow><mrow><msub><mrow><mi>j</mi></mrow><mrow><mn>1</mn></mrow></msub></mrow></msub><mo class='MathClass-rel' stretchy='false'>⋯</mo><msub><mrow><mi>H</mi></mrow><mrow><msub><mrow><mi>j</mi></mrow><mrow><mi>k</mi></mrow></msub></mrow></msub></mrow></math>. As long as
each of the <!-- l. 1252 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><msub><mrow><mi>H</mi></mrow><mrow><msub><mrow><mi>j</mi></mrow><mrow><mi>i</mi></mrow></msub></mrow></msub></math>
is unitary itself (for instance, when it is a Pauli string), we
can use the LCU method. This requires a circuit consisting of
<!-- l. 1252 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>O</mi><mo class='MathClass-open' stretchy='false'>(</mo><mi mathvariant='italic'>lt</mi><mi class='loglike'>log</mi><mo>⁡<!-- FUNCTION APPLICATION --></mo><!-- nolimits --><mo class='MathClass-open' stretchy='false'>(</mo><mi mathvariant='italic'>lt</mi><mo class='MathClass-bin' stretchy='false'>∕</mo><mi>𝜀</mi><mo class='MathClass-close' stretchy='false'>)</mo><mo class='MathClass-close' stretchy='false'>)</mo></mrow></math>
components. While this is better than any of the Trotter techniques
asymptotically, the circuits themselves are more complex and require
ancillae, so that in practice it might not always be better to use this
technique.
</p>
<!-- l. 1253 --><p class='noindent'><span class='paragraphHead' id='stabiliser-decompositions1'><a id='x9-189000'></a><span class='cmbx-10x-x-109'>Stabiliser decompositions</span></span>
   Using the efficiency of simulating Clifford operations in order to boost this to
an exponential-time universal quantum circuit simulation scheme was first
proposed by [<a href='main_htmlli2.html#Xaaronsongottesman2004'>1</a>]. However, the idea of grouping together magic states in order to
decompose them into fewer terms and get better simulation time is from [<a href='main_htmlli2.html#Xbravyi2016trading'>37</a>]
where they used a simulated annealing algorithm to find a decomposition of 6
<!-- l. 1254 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>
states into 7 terms. This was later improved to a 6 term decomposition in [<a href='main_htmlli2.html#XQassim2021improvedupperbounds'>194</a>],
                                                                     

                                                                     
where they also showed that more complicated arrangements of magic
states into the shape of a ‘cat’ state allow for even better decompositions.
Combining stabiliser decomposition methods with ZX-based optimising
was introduced by [<a href='main_htmlli2.html#Xkissinger2021simulating'>148</a>]. In the follow-up work [<a href='main_htmlli2.html#Xkissinger2022classical'>150</a>] ‘cat’ states were
shown to be related to phase gadgets, giving a nice way to incorporate the
better decompositions for these states into the ZX pipeline. This paper
also introduced the idea of a ‘partial magic state decomposition’, where
the terms in the decomposition don’t necessarily have to be stabiliser
themselves, they only have to have fewer non-Clifford resources then
in the ‘mother’ state. Using this idea, they find a decomposition of
<!-- l. 1254 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><msup><mrow><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow><mrow><mo class='MathClass-bin' stretchy='false'>⊗</mo><mn>5</mn></mrow></msup></mrow></math>
into 3 terms, each of which contain a single
<!-- l. 1254 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>, this hence ‘effectively’
removes 4 <!-- l. 1254 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>T</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>’s
at the cost of 3 terms. This is currently the best known generic decomposition.
</p>
<!-- l. 1255 --><p class='noindent'><span class='paragraphHead' id='stabiliser-extent-and-weak-simulation'><a id='x9-190000'></a><span class='cmbx-10x-x-109'>Stabiliser extent and weak simulation</span></span>
   A stabiliser decomposition allows for exact strong simulation by just
enumerating all the different terms of the computation. However, we don’t need
this exactness when wanting to do sampling, i.e. weak simulation. In [<a href='main_htmlli2.html#XPhysRevLett.116.250501'>33</a>] they
introduce the concept of an <span class='cmti-10x-x-109'>approximate </span>stabiliser decomposition, which
only gives the desired state up to some small error. This already greatly
improves the simulation time. The approximate stabiliser rank of a state
<!-- l. 1256 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math> can be
bounded using the <span class='cmti-10x-x-109'>stabiliser extent</span>, which was introduced by [<a href='main_htmlli2.html#XBravyi2019simulationofquantum'>32</a>], and is equal to
<!-- l. 1256 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
   <!-- nolimits --></mrow><mrow><mi>i</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>λ</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math> minimised over all
stabiliser decompositions <!-- l. 1256 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mo class='MathClass-rel' stretchy='false'>|</mo><mi>ψ</mi><mo class='MathClass-close' stretchy='false'>⟩</mo> <mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow> <mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>i</mi></mrow></msub><msub><mrow><mi>λ</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>ϕ</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo></mrow></math>.
A closely related concept is the <span class='cmti-10x-x-109'>robustness of magic</span> [<a href='main_htmlli2.html#XPhysRevLett.118.090501'>131</a>] which is defined for a mixed state
<!-- l. 1256 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mi>ρ</mi></math> as the minimum
of <!-- l. 1256 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><msub><mrow><mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>i</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>λ</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math> over all
decompositions <!-- l. 1256 --><math display='inline' xmlns='http://www.w3.org/1998/Math/MathML'><mrow><mi>ρ</mi> <mo class='MathClass-rel' stretchy='false'>=</mo><msub><mrow> <mi class='MathClass-op'>∑</mi><mo> ⁡<!-- FUNCTION APPLICATION --></mo>
  <!-- nolimits --></mrow><mrow><mi>i</mi></mrow></msub><msub><mrow><mi>λ</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo><msub><mrow><mi>ϕ</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class='MathClass-close' stretchy='false'>⟩</mo><mspace class='negthinspace' width='-0.17em'></mspace><mo class='MathClass-open' stretchy='false'>⟨</mo><msub><mrow><mi>ϕ</mi></mrow><mrow><mi>i</mi></mrow></msub><mo class='MathClass-rel' stretchy='false'>|</mo></mrow></math>.
Robustness of magic directly upper bounds the weak simulation cost of a
computation [<a href='main_htmlli2.html#XPhysRevLett.118.090501'>131</a>]. Note that these techniques based on approximate
stabiliser rank and robustness of magic are instances of <span class='cmbx-10x-x-109'>quasiprobabilistic
simulation techniques</span>. Here the ‘quasi’ means that the probabilities are
allowed to be negative, and there also other techniques that belong to
this family [<a href='main_htmlli2.html#XPhysRevLett.115.070501'>190</a>]. In these methods you have a set of states that are
‘free’ (like Clifford states), and then you write your non-free states as a
quasiprobabilistic combination over the free states, with the cost of simulation
scaling with the 1-norm of the quasiprobability distribution (the sum of
the absolute weights, also called the <span class='cmti-10x-x-109'>negativity </span>of the distribution). The
‘gate-by-gate‘ simulation technique of Section* <a href='#gatebygate-simulation'>7.8.1.2<!-- tex4ht:ref: sec:simulation-gate-by-gate  --></a> was introduced
                                                                     

                                                                     
in [<a href='main_htmlli2.html#XPhysRevLett.128.220503'>34</a>], where they also already observed that this combines well with the
stabiliser decomposition approach.    </p><!-- l. 7 --><div class='crosslinks'><p class='noindent'>[<a href='main_htmlch8.html'>next</a>] [<a href='main_htmlch6.html'>prev</a>] [<a href='main_htmlch6.html#tailmain_htmlch6.html'>prev-tail</a>] [<a href='main_htmlch7.html'>front</a>] [<a href='main_html.html#main_htmlch7.html'>up</a>]
</p></div>
<!-- l. 7 --><p class='indent'>   <a id='tailmain_htmlch7.html'></a></p> 
<script type="text/javascript" src="proof_collapse.js"></script> 
<script type="text/javascript" src="navigation_menu.js"></script> </body> 
</html>